// TODO Dominic, move into Limiter class
//#include "kernels/GaussLegendreQuadrature.h"
//#include "kernels/GaussLobattoQuadrature.h"
//#include "kernels/KernelUtils.h"
//#include <stdlib.h>

/**
 * Compute the DG to FV projectors.
 * 
 * We simply evaluate the DG basis functions at the centres of the finite volumes.
 */
void {{project}}::{{solver}}::internal::computeDG2FVProjector() {
  constexpr int basisSize    = Order+1;
  constexpr int basisSizeLim = PatchSize;
  constexpr double dxi = 1. / basisSizeLim;

  assertionSmallerEquals(basisSize,basisSizeLim);
  
  double phi[basisSize] = {0.0};
  {
    idx2 idx(basisSize, basisSizeLim);
    for(int i=0; i<basisSizeLim; i++) {
      const double xLeft = i*dxi;
      for(int j=0; j<basisSize; j++) {
        const double xi = xLeft + dxi*gaussLegendreNodes[basisSize-1][j];
        gaussLegendreBasisFunctions<Order>(phi, xi, basisSize);
        for(int k=0; k<basisSize; k++) { //
          uh2lim[idx(k,i)] += gaussLegendreWeights[basisSize-1][j]*phi[k];
        }
      }
    }
  }
}

/**
 * There are typically more finite volumes than DG basis functions per patch and per space dimension.
 * Therefore, we need to solve a minimisation problem to derive a DG solution.
 * We use a simple least-squares minisation subject to mass conservation, i.e. 
 * the average DG solution over the patch must equal the average FV solution over the patch.
 * 
 * @precondition The DG-to-FV projector must be computed before calling this function.
 */
void {{project}}:{{solver}}::internal::computeFV2DGProjector() {
  constexpr int basisSize    = Order+1;
  constexpr int basisSizeLim = PatchSize;
  
  assertionSmallerEquals(basisSize,basisSizeLim);
  
  double lsqm  [(basisSize+1)*(basisSize+1)] = {0.0};
  double lsqrhs[basisSizeLim*(basisSize+1) ] = {0.0};
  
  idx2 idx(basisSizeLim, basisSize);
  idx2 idxLSQM((basisSize+1),(basisSize+1));
  idx2 idxLSQrhs(basisSizeLim,(basisSize+1));
  idx2 idxUh2Lim(basisSize, basisSizeLim);
  const double dxi = 1.0 / basisSizeLim;
  for(int i=0; i<basisSize; i++) {
    for(int j=0; j<basisSize; j++) {
      lsqm[idxLSQM(i,j)] = 0.;
      for(int k=0; k<basisSizeLim; k++) {
        lsqm[idxLSQM(i,j)] += 2* uh2lim[idxUh2Lim(i,k)] * uh2lim[idxUh2Lim(j,k)];
      }
    }
    lsqm[idxLSQM(i,basisSize)] = gaussLegendreWeights[basisSize-1][i];
  }
  for(int i=0; i<basisSize; i++) {
    lsqm[idxLSQM(basisSize,i)] = -gaussLegendreWeights[basisSize-1][i];
  }
  lsqm[idxLSQM(basisSize,basisSize)] = 0.;

  double* ilsqm = matrixInverse(basisSize+1, lsqm);   

  for(int i=0; i<basisSizeLim; i++) {
    for(int j=0; j<basisSize; j++) {
      lsqrhs[idxLSQrhs(i,j)] = 2*uh2lim[idxUh2Lim(j,i)];
    }
    lsqrhs[idxLSQrhs(i,basisSize)] = dxi;
  }

  for(int i=0; i<basisSizeLim; i++) {
    for(int j=0; j<basisSize; j++) {
      lim2uh[idx(i,j)] = 0.;
      for(int k=0; k<basisSize+1; k++) {
        lim2uh[idx(i,j)] += ilsqm[idxLSQM(k,j)] * lsqrhs[idxLSQrhs(i,k)];
      }
    }
  }
}

//  double uh2lim[basisSize*basisSizeLim] = {0.0};
//  double uh2lob[basisSize*basisSize] = {0.0};
//  double lim2uh[basisSizeLim*basisSize] = {0.0};

void {{project}::{{solver}}::internal::computeLegendre2LobattoProjectors
  constexpr int basisSize    = Order+1;
  constexpr int basisSizeLim = PatchSize;
  
  double phi[basisSize] = {0.0};
  idx2 idx(basisSize, basisSize);

  for(int i=0; i<basisSize; i++) {
    gaussLegendreBasisFunctions<Order>(phi, gaussLobattoNodes[Order][i], basisSize);
    for(int j=0; j<basisSize; j++) {
      uh2lob[idx(j,i)] = phi[j]; //Fortran: uh2lob(ii,:) = phi(:) 
    }
  }
}