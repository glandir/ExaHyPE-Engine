#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/GaussLobattoQuadrature.h"
#include "kernels/KernelUtils.h"
#include <stdlib.h>

namespace internal {
  
  template <int n>
  double matrixInverse(double (&ia) [n][n],const double (&a) [n][n]) {
    //TODO JMG remove when generated value
    double ia[n*n] = {0.0};
    double c[n*n*2] = {0.0};

    idx2 idx(n,n);
    idx2 idxC(n,2*n);

    double tmp, piv, mlV;

    for(int i=0; i<n; i++) {
      for(int j=0; j<n; j++) {
        c[idxC(i,j)] = a[idx(j,i)];
      }
      for(; j<2*n; j++) {
        c[idxC(i,j)] = 0.;
      }
      c[idxC(i,i+n)] = 1.;
    }

    //Forward elimination and row swapping (if necessary)
    for(int i=0; i<n; i++) {
      ml = i;
      mlV = std::abs(static_cast<double>(c[idxC(i,i)]));
      for(int j=i+1; j<n; j++) {
        if(std::abs(c[idxC(j,i)]) > mlV) {
          ml = j;
          mlV = c[idxC(j,i)];
        }
      }

      for(int k=0; k<2*n; k++) {
        tmp = c[idxC(ml,k)];
        c[idxC(ml,k)] = c[idxC(i,k)];
        c[idxC(i,k)] = tmp;
      }
      if(c[idxC(i,i)] == 0) {
        //logError("matrixInverse()", "Matrix is singular" );
        return nullptr;
      }
      piv = 1. / c[idxC(i,i)];
      for(int k=0; k<2*n; k++) {
        c[idxC(i,k)] *= piv;
      }
      for(int j=i+1; j<n; j++) {
        tmp = c[idxC(j,i)];
        for(int k=0; k<2*n; k++) {
          c[idxC(j,k)] -= tmp*c[idxC(i,k)];
        }
      }
    }

    //Back substitution
    for(int i=n-1; i>=0; i--) {
      for(int j=i-1; j>=0; j--) {
        tmp = c[idxC(j,i)];
        for(int k=0; k<2*n; k++) {
          c[idxC(j,k)] -= tmp*c[idxC(i,k)];
        }
      }
    }

    for(int i=0; i<n; i++) {
      for(int j=0; j<n; j++) {
        ia[idx(j,i)] = c[idxC(i,j+n)];
      }
    }
  }

  
  template <int order>
  void gaussLegendreBasisFunctions(double (&phi) [order+1], double xi) {
    constexpr int basisSize = order+1;

    for(int i=0; i<basisSize; i++) {
      phi[i] = 1;
    }
    for(m=0; m<basisSize; m++) {
      for(int j=0; j<basisSize; j++) {
        if(j == m) continue;
        phi[m] = phi[m]*(xi - kernels::gaussLegendreNodes[order][j])/(kernels::gaussLegendreNodes[order][m]-kernels::gaussLegendreNodes[order][j]);
      }
    }
  }
  
  /**
   * Compute a projector to switch from Gauss-Legendre basis functions
   * to Gauss-Lobatto basis functions.
   */
  void computeLegendre2LobattoProjector();

  /**
   * Compute the DG to FV projectors.
   * 
   * We simply evaluate the DG basis functions at the centres of the finite volumes.
   */
  void computeDG2FVProjector();

  /**
   * There are typically more finite volumes than (Legendre) DG basis functions per patch and per space dimension.
   * Therefore, we need to solve a minimisation problem to derive a DG solution.
   * We use a simple least-squares minisation subject to mass conservation, i.e. 
   * the average DG solution over the patch must equal the average FV solution over the patch.
   * 
   * @precondition The DG-to-FV projector must be computed before calling this function.
   */
  void computeFV2DGProjector();
}; // end namespace internal