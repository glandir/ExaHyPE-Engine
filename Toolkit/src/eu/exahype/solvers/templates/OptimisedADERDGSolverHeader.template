#ifndef __{{Solver}}_CLASS_HEADER__
#define __{{Solver}}_CLASS_HEADER__

// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================

#include <ostream>

#include "{{AbstractSolver}}.h"

{{ProfilerInclude}}
{{ParserInclude}}

namespace {{Project}}{
  class {{Solver}};
}

class {{Project}}::{{Solver}}: public {{Project}}::{{AbstractSolver}} {
  public: 
/*
  static int nbCalled;
  
  static double adjPointSolc;
  static double eigenc;
  static double fluxc;
  static double sourcec;
  static double ncpc;
  static double matbc;
  static double boundc;
*/  
  
//    ~{{Solver}}();  
    {{Solver}}(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs{{SolverConstructorSignatureExtension}});

    bool useAlgebraicSource()        const override;
    bool useNonConservativeProduct() const override;
    bool usePointSource()            const override;
    AdjustSolutionValue useAdjustSolution(const tarch::la::Vector<DIMENSIONS,double>& centre,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) const override;
    
    void init(std::vector<std::string>& cmdlineargs{{SolverInitSignatureExtension}});
    static void flux(const double* const Q, double** F);
    static void eigenvalues(const double* const Q, const int normalNonZeroIndex, double* lambda);
    static void adjustPointSolution(const double* const x,const double w,const double t,const double dt,double* Q);
    static void algebraicSource(const double* const Q, double* S);
    static void boundaryValues(const double* const x,const double t, const double dt, const int faceIndex, const int normalNonZero, const double * const fluxIn, const double* const stateIn, double *fluxOut, double* stateOut);
    static void nonConservativeProduct(const double* const Q, const double* const gradQ, double* BgradQ);
    static void coefficientMatrix(const double* const Q, const int normalNonZero, double* Bn);
    exahype::solvers::Solver::RefinementControl refinementCriterion(const double* luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int level) override;

    //TODO JMG
    //Not implemented
    void pointSource(const double* const x,const double t,const double dt, double* forceVector, double* x0); //TODO KD
    bool isPhysicallyAdmissible(const double* const QMin,const double* const QMax) const override;
};

#endif // __{{Solver}}_CLASS_HEADER__
