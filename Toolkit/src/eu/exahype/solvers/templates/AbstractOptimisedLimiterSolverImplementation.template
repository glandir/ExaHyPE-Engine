// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "{{abstractSolver}}.h"

#include "{{optKernelPath}}/Kernels.h"


// Just call parent constructor
{{project}}::{{abstractSolver}}::{{abstractSolver}}(std::string identifier, std::unique_ptr<exahype::solvers::ADERDGSolver> solver, std::unique_ptr<exahype::solvers::FiniteVolumesSolver> limiter, const double DMPRelaxationParameter, const double DMPDifferenceScaling, const int iterationsToCureTroubledCell):
  exahype::solvers::LimitingADERDGSolver(identifier, std::move(solver), std::move(limiter), DMPRelaxationParameter, DMPDifferenceScaling, iterationsToCureTroubledCell) {
}

void {{project}}::{{abstractSolver}}::projectOnFVLimiterSpace(const double* const luh, double* const lim) const {
  {{optNamespace}}::projectOnFVLimiterSpace(luh, lim);
}

void {{project}}::{{abstractSolver}}::projectOnDGSpace(const double* const lim, double* const luh) const {
  {{optNamespace}}::projectOnDGSpace(lim, luh);
}

bool {{project}}::{{abstractSolver}}::discreteMaximumPrincipleAndMinAndMaxSearch(const double* const luh, double* boundaryMinPerVariables, double* boundaryMaxPerVariables) {
  return {{optNamespace}}::discreteMaximumPrincipleAndMinAndMaxSearch(luh, _solver.get(), _DMPMaximumRelaxationParameter, _DMPDifferenceScaling, boundaryMinPerVariables, boundaryMaxPerVariables);
}

void {{project}}::{{abstractSolver}}::findCellLocalMinAndMax(const double* const luh, double* const localMinPerVariables, double* const localMaxPerVariable) {
  {{optNamespace}}::findCellLocalMinAndMax(luh, _solver.get(), localMinPerVariables, localMaxPerVariable);
}
void {{project}}::{{abstractSolver}}::findCellLocalLimiterMinAndMax(const double* const lim, double* const localMinPerObservable, double* const localMaxPerObservable) {
  {{optNamespace}}::findCellLocalLimiterMinAndMax(lim, _solver.get(), localMinPerObservable,localMaxPerObservable);
}