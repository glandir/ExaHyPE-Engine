// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include "Abstract{{Solver}}.h"

#include "kernels/finitevolumes/{{FiniteVolumesType}}/c/2d/{{FiniteVolumesType}}.cpph"
#include "kernels/finitevolumes/{{FiniteVolumesType}}/c/3d/{{FiniteVolumesType}}.cpph"
#include "kernels/finitevolumes/commons/c/commons.h"

#include "{{Solver}}.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.


#include <cstdlib> // abort()
#include "kernels/KernelUtils.h" // idx

{{Project}}::{{Solver}}::{{Solver}}(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs{{SolverConstructorSignatureExtension}}):
  Abstract{{Solver}}::Abstract{{Solver}}(maximumMeshSize,timeStepping{{SolverConstructorArgumentExtension}}) {
  init(cmdlineargs);
}

{{Project}}::Abstract{{Solver}}::Abstract{{Solver}}(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping{{SolverConstructorSignatureExtension}}):
  exahype::solvers::FiniteVolumesSolver("{{Solver}}",NumberOfVariables,NumberOfParameters,PatchSize,
                                        GhostLayerWidth,maximumMeshSize,timeStepping{{SolverConstructorArgumentExtension}}) {
}

void {{Project}}::Abstract{{Solver}}::constantsToString(std::ostream& os) {
	// This string is used in the --version output to identify compile time constants
	os << "{{Project}}::Abstract{{Solver}}("
	   << "nVar=" << NumberOfVariables << ", "
	   << "nParam=" << NumberOfParameters << ", "
	   << "PatchSize=" << PatchSize << ", "
	   << "GhostLayerWidth=" << GhostLayerWidth
	   << ")";
}

void {{Project}}::Abstract{{Solver}}::solutionUpdate(double* luhNew,const double* luh,double** tempStateSizedArrays,double** tempUnknowns,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt,double& maxAdmissibleDt) {
  maxAdmissibleDt = kernels::finitevolumes::{{FiniteVolumesType}}::c::solutionUpdate<{{Solver}}>(*static_cast<{{Solver}}*>(this),luhNew,luh,tempStateSizedArrays,tempUnknowns,dx,dt);
}


double {{Project}}::Abstract{{Solver}}::stableTimeStepSize(const double* const luh,double* tempEigenvalues,const tarch::la::Vector<DIMENSIONS,double>& dx) {
  double maxAdmissibleDt = kernels::finitevolumes::commons::c::stableTimeStepSize<{{Solver}}>(*static_cast<{{Solver}}*>(this),luh,tempEigenvalues,dx);
  return maxAdmissibleDt;
}

void {{Project}}::Abstract{{Solver}}::adjustSolution(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) {
  kernels::finitevolumes::commons::c::solutionAdjustment<{{Solver}}>(*static_cast<{{Solver}}*>(this),luh,center,dx,t,dt);
}

void {{Project}}::Abstract{{Solver}}::boundaryConditions(double* luhbndOutside,const double* const luhbndInside,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {
  kernels::finitevolumes::commons::c::boundaryConditions<{{Solver}}>(*static_cast<{{Solver}}*>(this),luhbndOutside,luhbndInside,cellCentre,cellSize,t,dt,faceIndex,normalNonZero);
}


void {{Project}}::Abstract{{Solver}}::ghostLayerFilling(double* luh,const double* luhNeighbour,const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) {
  kernels::finitevolumes::commons::c::ghostLayerFilling<{{Solver}}>(*static_cast<{{Solver}}*>(this),luh,luhNeighbour,neighbourPosition);
}

void {{Project}}::Abstract{{Solver}}::ghostLayerFillingAtBoundary(double* luh,const double* luhbnd,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::commons::c::ghostLayerFillingAtBoundary<{{Solver}}>(*static_cast<{{Solver}}*>(this),luh,luhbnd,boundaryPosition);
}

void {{Project}}::Abstract{{Solver}}::boundaryLayerExtraction(double* luhbnd,const double* luh,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::commons::c::boundaryLayerExtraction<{{Solver}}>(*static_cast<{{Solver}}*>(this),luhbnd,luh,boundaryPosition);
}


void {{Project}}::Abstract{{Solver}}::nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) {
      assertionMsg(false,"If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
      abort();
}

void {{Project}}::Abstract{{Solver}}::coefficientMatrix(const double* const Q,const int d,double* Bn) {
	// By default, if not given, fallback to nonConservativeProduct
	kernels::idx2 idx_gradQ(DIMENSIONS, NumberOfVariables+NumberOfParameters);
	kernels::idx2 idx_Bn(NumberOfVariables, NumberOfVariables);
	
	// build gradQ from normal vector and fill up Bn.
	double gradQ[DIMENSIONS * (NumberOfVariables + NumberOfParameters)] = {0.};
	for(int i=0; i<NumberOfVariables; i++) {
		std::fill_n(gradQ, idx_gradQ.size, 0.0);
		gradQ[idx_gradQ(d, i)] = 1.0;
		nonConservativeProduct(Q, gradQ, Bn + idx_Bn(i,0));
	}
}

void {{Project}}::Abstract{{Solver}}::algebraicSource(const double* const Q,double* S) {
      assertionMsg(false,"If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
      abort();
}

void {{Project}}::Abstract{{Solver}}::fusedSource(const double* const Q, const double* const gradQ, double* S) {
      algebraicSource(Q, S);
      if(useNonConservativeProduct()) {
        double ncp[NumberOfVariables];
        nonConservativeProduct(Q, gradQ, ncp);
        for(int l=0; l<NumberOfVariables; l++) {
          S[l] -= ncp[l];
        }
      }
}
