// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "Abstract{{Solver}}.h"

#include "kernels/aderdg/generic/Kernels.h"

#include "{{Solver}}.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

// failure verbosely even without assertions turned on.
#include <stdio.h>
void abortForWrongAPI(const char* const msg) {
	puts(msg);
	abort();
}

// Code generation information.
{{defineLinear}}
{{defineFortran}}

// We define the constructor of the actual solver here in order to regenerate it easily.
{{Project}}::{{Solver}}::{{Solver}}(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs{{SolverConstructorSignatureExtension}}):
  Abstract{{Solver}}::Abstract{{Solver}}(maximumMeshSize,timeStepping{{SolverConstructorArgumentExtension}}) {
  init(cmdlineargs{{SolverInitCallExtension}});
}


{{Project}}::Abstract{{Solver}}::Abstract{{Solver}}(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping{{SolverConstructorSignatureExtension}}):
  exahype::solvers::ADERDGSolver("{{Solver}}",NumberOfVariables,NumberOfParameters,Order+1,
                                 maximumMeshSize,timeStepping{{SolverConstructorArgumentExtension}}) {
}

void {{Project}}::Abstract{{Solver}}::constantsToString(std::ostream& os) {
	// This string is used in the --version output to identify compile time constants
	os << "{{Project}}::Abstract{{Solver}}("
	   << "nVar=" << NumberOfVariables << ", "
	   << "nParam=" << NumberOfParameters << ", "
	   << "Order=" << Order
	   << ")";
}

void {{Project}}::Abstract{{Solver}}::spaceTimePredictor(double* lQhbnd,double* lFhbnd,double** tempSpaceTimeUnknowns,double** tempSpaceTimeFluxUnknowns,double* tempUnknowns,double* tempFluxUnknowns,double* tempStateSizedVectors,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt, double* pointForceSources) {
{{BeforeSpaceTimePredictor}}
#ifdef isFortran
  kernels::aderdg::generic::fortran::spaceTimePredictor{{NonlinearOrLinear}}<{{Solver}}>(*static_cast<{{Solver}}*>(this),lQhbnd,lFhbnd,tempSpaceTimeUnknowns,tempSpaceTimeFluxUnknowns,tempUnknowns,tempFluxUnknowns,tempStateSizedVectors,luh,dx,dt, pointForceSources);
#else
#ifdef isLinear
  kernels::aderdg::generic::c::spaceTimePredictorLinear<{{Solver}}>(*static_cast<{{Solver}}*>(this),lQhbnd,lFhbnd,tempSpaceTimeUnknowns,tempSpaceTimeFluxUnknowns,tempUnknowns,tempFluxUnknowns,tempStateSizedVectors,luh,dx,dt, pointForceSources);
#else

  // For some reason, we compile here the SpaceTimepRedictorNonLinear (STPNL) for all possible
  // combinations, even if the guards have no other possibility than staying constant for the whole
  // run (which means they could be constexpr). I have no clue why we need this overhead here. In
  // my eyes it's waste of time. Maybe somebody can explain it to me.  -- Sven, 2017-04-07.

#define STPNL(useSource, useFlux, useNCP) \
    kernels::aderdg::generic::c::spaceTimePredictorNonlinear<useSource, useFlux, useNCP, {{Solver}}>(\
        *static_cast<{{Solver}}*>(this), lQhbnd, lFhbnd,\
        tempSpaceTimeUnknowns,tempSpaceTimeFluxUnknowns,tempUnknowns,tempFluxUnknowns,tempStateSizedVectors,\
        luh,dx,dt);
  
  if(useAlgebraicSource()) {
    if(useConservativeFlux()) {
      if(useNonConservativeProduct()) {
        STPNL(true,true,true);
      } else {
        STPNL(true,true,false);
      }
    } else {
      if(useNonConservativeProduct()) {
        STPNL(true,false,true);
      } else {
        STPNL(true,false,false);
      }
    }
  } else {
    if(useConservativeFlux()) {
      if(useNonConservativeProduct()) {
        STPNL(false,true,true);
      } else {
        STPNL(false,true,false);
      }
    } else {
      if(useNonConservativeProduct()) {
        STPNL(false,false,true);
      } else {
        STPNL(false,false,false);
      }
    }
  } 
#endif // isLinear
#endif // isFortran
{{AfterSpaceTimePredictor}}
}



void {{Project}}::Abstract{{Solver}}::solutionUpdate(double* luh,const double* const lduh,const double dt) {
{{BeforeSolutionUpdate}}
  kernels::aderdg::generic::{{Language}}::solutionUpdate<{{Solver}}>(*static_cast<{{Solver}}*>(this),luh,lduh,dt);
{{AfterSolutionUpdate}}
}



void {{Project}}::Abstract{{Solver}}::volumeIntegral(double* lduh,const double* const lFhi,const tarch::la::Vector<DIMENSIONS,double>& dx) {
{{BeforeVolumeIntegral}}
#ifdef isFortran
  kernels::aderdg::generic::fortran::volumeIntegral{{NonlinearOrLinear}}(lduh,lFhi,dx,getNumberOfVariables(),getNumberOfParameters(),getNodesPerCoordinateAxis());
#endif
#ifndef isFortran
#ifdef isLinear
  kernels::aderdg::generic::c::volumeIntegralLinear<NumberOfVariables,Order+1>(lduh,lFhi,dx);
#else
  if(useAlgebraicSource() || useNonConservativeProduct()) {
    kernels::aderdg::generic::c::volumeIntegralNonlinear<true,NumberOfVariables,Order+1>(lduh,lFhi,dx);
  } else {
    kernels::aderdg::generic::c::volumeIntegralNonlinear<false,NumberOfVariables,Order+1>(lduh,lFhi,dx);
  }
#endif // isLinear
#endif // !isFortran
{{AfterVolumeIntegral}}
}



void {{Project}}::Abstract{{Solver}}::surfaceIntegral(double* lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& dx) {
{{BeforeSurfaceIntegral}}
  kernels::aderdg::generic::{{Language}}::surfaceIntegral{{NonlinearOrLinear}}<NumberOfVariables,Order+1>(lduh,lFhbnd,dx);
{{AfterSurfaceIntegral}}
}



void {{Project}}::Abstract{{Solver}}::riemannSolver(double* FL,double* FR,const double* const QL,const double* const QR,double* tempFaceUnknownsArray,double** tempStateSizedVectors,double** tempStateSizedSquareMatrices,const double dt,const int normalNonZeroIndex) {
  assertion2(normalNonZeroIndex>=0,dt,normalNonZeroIndex);
  assertion2(normalNonZeroIndex<DIMENSIONS,dt,normalNonZeroIndex);
{{BeforeRiemannSolver}}
#ifdef isFortran
  kernels::aderdg::generic::fortran::riemannSolver{{NonlinearOrLinear}}<{{Solver}}>(*static_cast<{{Solver}}*>(this),FL,FR,QL,QR,tempFaceUnknownsArray,tempStateSizedVectors,tempStateSizedSquareMatrices,dt,normalNonZeroIndex);
#endif
#ifndef isFortran
#ifdef isLinear
   kernels::aderdg::generic::c::riemannSolverLinear<{{Solver}}>(*static_cast<{{Solver}}*>(this),FL,FR,QL,QR,tempFaceUnknownsArray,tempStateSizedVectors,tempStateSizedSquareMatrices,dt,normalNonZeroIndex);
#else
  if(useNonConservativeProduct()) {
    kernels::aderdg::generic::c::riemannSolverNonlinear<true,{{Solver}}>(*static_cast<{{Solver}}*>(this),FL,FR,QL,QR,tempFaceUnknownsArray,tempStateSizedVectors,tempStateSizedSquareMatrices,dt,normalNonZeroIndex);
  } else {
    kernels::aderdg::generic::c::riemannSolverNonlinear<false,{{Solver}}>(*static_cast<{{Solver}}*>(this),FL,FR,QL,QR,tempFaceUnknownsArray,tempStateSizedVectors,tempStateSizedSquareMatrices,dt,normalNonZeroIndex);
  }
#endif // isLinear
#endif // !isFortran
{{AfterRiemannSolver}}
}



void {{Project}}::Abstract{{Solver}}::boundaryConditions(double* fluxOut,double* stateOut,const double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {
{{BeforeBoundaryConditions}}
  kernels::aderdg::generic::c::boundaryConditions<{{Solver}}>(*static_cast<{{Solver}}*>(this),fluxOut,stateOut,fluxIn,stateIn,cellCentre,cellSize,t,dt,faceIndex,normalNonZero);
{{AfterBoundaryConditions}}
}



double {{Project}}::Abstract{{Solver}}::stableTimeStepSize(const double* const luh,double* tempEigenvalues,const tarch::la::Vector<DIMENSIONS,double>& dx) {
{{BeforeStableTimeStepSize}}
  double d = kernels::aderdg::generic::{{Language}}::stableTimeStepSize<{{Solver}}>(*static_cast<{{Solver}}*>(this),luh,tempEigenvalues,dx);
{{AfterStableTimeStepSize}}
  return d;
}



void {{Project}}::Abstract{{Solver}}::adjustSolution(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) {
{{BeforeSolutionAdjustment}}
  switch (useAdjustSolution(center, dx, t, dt)) {
    case AdjustSolutionValue::No:
      abortForWrongAPI("Branch may not be entered. Solver spec clarifies that adjust solution is not to be called, but kernel nevertheless invokes adjustSolution." );
      break;
    case AdjustSolutionValue::PointWisely:
      kernels::aderdg::generic::{{Language}}::solutionAdjustment<{{Solver}}>(*static_cast<{{Solver}}*>(this),luh,center,dx,t,dt);
      break;
    case AdjustSolutionValue::PatchWisely:
      adjustPatchSolution(
        center, dx, t, dt, luh);
      break;
  }
{{AfterSolutionAdjustment}}
}



void {{Project}}::Abstract{{Solver}}::faceUnknownsProlongation(double* lQhbndFine,double* lFhbndFine,const double* lQhbndCoarse,const double* lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{{BeforeFaceUnknownsProlongation}}
  kernels::aderdg::generic::c::faceUnknownsProlongation<NumberOfVariables,NumberOfParameters,Order+1>(lQhbndFine,lFhbndFine,lQhbndCoarse,lFhbndCoarse,coarseGridLevel,fineGridLevel,subfaceIndex);
{{AfterFaceUnknownsProlongation}}
}



void {{Project}}::Abstract{{Solver}}::faceUnknownsRestriction(double* lQhbndCoarse,double* lFhbndCoarse,const double* lQhbndFine,const double* lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{{BeforeFaceUnknownsRestriction}}
  kernels::aderdg::generic::c::faceUnknownsRestriction<NumberOfVariables,NumberOfParameters,Order+1>(lQhbndCoarse,lFhbndCoarse,lQhbndFine,lFhbndFine,coarseGridLevel,fineGridLevel,subfaceIndex);
{{AfterFaceUnknownsRestriction}}
}



void {{Project}}::Abstract{{Solver}}::volumeUnknownsProlongation(double* luhFine,const double* luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{{BeforeVolumeUnknownsProlongation}}
  kernels::aderdg::generic::c::volumeUnknownsProlongation<NumberOfVariables,NumberOfParameters,Order+1>(luhFine,luhCoarse,coarseGridLevel,fineGridLevel,subcellIndex);
{{AfterVolumeUnknownsProlongation}}
}



void {{Project}}::Abstract{{Solver}}::volumeUnknownsRestriction(double* luhCoarse,const double* luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{{BeforeVolumeUnknownsRestriction}}
  kernels::aderdg::generic::c::volumeUnknownsRestriction<NumberOfVariables,NumberOfParameters,Order+1>(luhCoarse,luhFine,coarseGridLevel,fineGridLevel,subcellIndex);
{{AfterVolumeUnknownsRestriction}}
}




void {{Project}}::Abstract{{Solver}}::pointSource(const double t,const double dt, const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx, double* tempPointForceSources) {
{{BeforePointSource}}
  kernels::aderdg::generic::c::pointSource<{{Solver}}>(*static_cast<{{Solver}}*>(this), t, dt, center, dx, getNumberOfVariables(),getNumberOfParameters(),getNodesPerCoordinateAxis(), tempPointForceSources);
{{AfterPointSource}}
}

void {{Project}}::Abstract{{Solver}}::fusedSource(const double* const Q, const double* const gradQ, double* S) {
      algebraicSource(Q, S);
      if(useNonConservativeProduct()) {
        double ncp[NumberOfVariables];
        nonConservativeProduct(Q, gradQ, ncp);
        for(int l=0; l<NumberOfVariables; l++) {
          S[l] -= ncp[l];
        }
      }
}

void {{Project}}::Abstract{{Solver}}::flux(const double* const Q,double** F) {
      abortForWrongAPI("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{Project}}::Abstract{{Solver}}::algebraicSource(const double* const Q,double* S) {
      abortForWrongAPI("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}
        
void {{Project}}::Abstract{{Solver}}::nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) {
      abortForWrongAPI("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{Project}}::Abstract{{Solver}}::coefficientMatrix(const double* const Q,const int d,double* Bn) {
	// By default, if not given, fallback to nonConservativeProduct
	kernels::idx2 idx_gradQ(DIMENSIONS, NumberOfVariables+NumberOfParameters);
	kernels::idx2 idx_Bn(NumberOfVariables, NumberOfVariables);
	
	// build gradQ from normal vector and fill up Bn.
	double gradQ[DIMENSIONS * (NumberOfVariables + NumberOfParameters)] = {0.0};
	for(int i=0; i<NumberOfVariables; i++) {
		std::fill_n(gradQ, idx_gradQ.size, 0.0);
		gradQ[idx_gradQ(d, i)] = 1.0;
		nonConservativeProduct(Q, gradQ, Bn + idx_Bn(i,0));
	}
}

void {{Project}}::Abstract{{Solver}}::pointSource(const double* const x,const double t,const double dt, double* forceVector, double* x0) {
      abortForWrongAPI("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{Project}}::Abstract{{Solver}}::adjustPointSolution(const double* const x,const double w,const double t,const double dt,double* Q) {
      abortForWrongAPI("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );}

void {{Project}}::Abstract{{Solver}}::adjustPatchSolution(
      const tarch::la::Vector<DIMENSIONS, double>& cellCentre,
      const tarch::la::Vector<DIMENSIONS, double>& dx,
      const double t,
      const double dt,
      double* luh) {
      abortForWrongAPI("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

