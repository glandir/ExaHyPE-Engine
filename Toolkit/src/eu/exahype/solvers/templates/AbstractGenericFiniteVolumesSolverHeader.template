#ifndef __Abstract{{Solver}}_CLASS_HEADER__
#define __Abstract{{Solver}}_CLASS_HEADER__

// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include <ostream>

#include "exahype/Parser.h"
#include "exahype/solvers/FiniteVolumesSolver.h"

/**
 * We include Peano's assertion collection here.
 */
#include "tarch/Assertions.h"

{{ProfilerInclude}}

namespace {{Project}}{
  class Abstract{{Solver}};
  class {{Solver}};
}

class {{Project}}::Abstract{{Solver}} : public exahype::solvers::FiniteVolumesSolver {
  public:
    static constexpr int NumberOfVariables  = {{NumberOfVariables}};
    static constexpr int NumberOfParameters = {{NumberOfParameters}};
    static constexpr int PatchSize          = {{PatchSize}};
    static constexpr int GhostLayerWidth    = {{GhostLayerWidth}};
    static constexpr double CFL             = 0.9;
  
    class Variables;
    class ReadOnlyVariables;
    class Fluxes;
    class VariableShortcuts;
    class VariableNames;
{{NamingSchemes}}
    
    Abstract{{Solver}}(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping{{SolverConstructorSignatureExtension}});
    
    void solutionUpdate(double* luhNew,const double* luh,double** tempStateSizedArrays,double** tempUnknowns,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt,double& maxAdmissibleDt) override;
    
    double stableTimeStepSize(const double* const luh,double* tempEigenvalues,const tarch::la::Vector<DIMENSIONS,double>& dx) override;
    void adjustSolution(double* luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) override;
    
    void ghostLayerFilling(double* luh,const double* luhNeighbour,const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) override;
    void ghostLayerFillingAtBoundary(double* luh,const double* luhbnd,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) override;
    void boundaryLayerExtraction(double* luhbnd,const double* luh,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) override;
    void boundaryConditions(double* stateOut,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) override;

    /// Apr 18, Coding Week: Riemann Solvers in FV. Hopefully inlined as evaluated point wise.
    double riemannSolver(double* fL, double *fR, const double* qL, const double* qR, int normalNonZero) override;

    static void constantsToString(std::ostream& os);
    static void abortWithMsg(const char* const msg);
    
    /**
     * Please overwrite in user's solver. See superclass for documentation.
     */
    bool useAdjustSolution(
      const tarch::la::Vector<DIMENSIONS, double>& cellCentre,
      const tarch::la::Vector<DIMENSIONS, double>& dx,
      const double t,
      const double dt) const override {return false;}

    bool useAlgebraicSource()        const override { return false; }
    
    /**
     * Note that our FV kernels do not have the point sources included yet,
     * as far as I know (Sven).
     **/
    bool usePointSource()            const override { return false; }
    bool useNonConservativeProduct() const override { return false; }
    bool useConservativeFlux()       const override { return true; }

    /**
     * Please overwrite in user's solver. See superclass for documentation.
     */

    /* New April 2017 API changes */
    void nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) override;
    void coefficientMatrix(const double* const Q,const int d,double* Bn) override;
    void algebraicSource(const double* const Q,double* S) override;
    void fusedSource(const double* const Q, const double* const gradQ, double* S) override;
    void flux(const double* const Q,double** F) override;
    
    /* New May 2017 API changes */
    void pointSource(const double* const x,const double t,const double dt, double* forceVector, double* x0) override;
};


#endif // __Abstract{{Solver}}_CLASS_HEADER__
