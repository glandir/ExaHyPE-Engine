// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "{{abstractSolver}}.h"
#include "{{optKernelPath}}/Kernels.h"

#include "{{solver}}.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include <stdio.h>

// We define the constructor of the actual solver here in order to regenerate it easily.
{{project}}::{{solver}}::{{solver}}(double maximumMeshSize,int maximumAdaptiveMeshDepth,int DMPObservables,int limiterHelperLayers,exahype::solvers::Solver::TimeStepping timeStepping {%- if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %}):
  {{abstractSolver}}::{{abstractSolver}}(maximumMeshSize,maximumAdaptiveMeshDepth,DMPObservables,limiterHelperLayers,timeStepping {%- if enableProfiler %}, std::move(profiler) {%- endif %}) {
}



{{project}}::{{abstractSolver}}::{{abstractSolver}}(double maximumMeshSize,int maximumAdaptiveMeshDepth,int DMPObservables,int limiterHelperLayers,exahype::solvers::Solver::TimeStepping timeStepping {%- if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler {%- endif %} ):
  exahype::solvers::ADERDGSolver("{{solver}}",{{optNamespace}}::getNumberOfVariable(),{{optNamespace}}::getNumberOfParameter(),{{optNamespace}}::getBasisSize(),
                                 maximumMeshSize,maximumAdaptiveMeshDepth,DMPObservables,limiterHelperLayers,timeStepping {%- if enableProfiler %}, std::move(profiler){% endif %}) {
}



void {{project}}::{{abstractSolver}}::constantsToString(std::ostream& os) {
	// This string is used in the --version output to identify compile time constants
	os << "{{project}}::{{abstractSolver}}("
	   << "nVar=" << NumberOfVariables << ", "
	   << "nParam=" << NumberOfParameters << ", "
	   << "nDim=" << Dimensions << ", "
	   << "order=" << Order
	   << ")";
}

//fusedSpaceTimePredictorVolumeIntegral(double* lduh, double* lQhbnd,double* lFhbnd,double** tempSpaceTimeUnknowns,double** tempSpaceTimeFluxUnknowns,double* tempUnknowns,double* tempFluxUnknowns,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& inverseDx,const double dt, double** tempPointForceSources) {

int {{project}}::{{abstractSolver}}::fusedSpaceTimePredictorVolumeIntegral(double* lduh, double* lQhbnd, double* lFhbnd, const double* const luh, const tarch::la::Vector<DIMENSIONS, double>& center, const tarch::la::Vector<DIMENSIONS, double>& dx, const double t, const double dt) {
{%- if enableProfiler %}
  _profiler->start("fusedSpaceTimePredictorVolumeIntegral");
{%- endif %}

{%- if tempVarsOnStack %}
  double lQi[{{optNamespace}}::getlQiSize()] __attribute__((aligned(ALIGNMENT)));
  {%- if useFlux %}
  double lFi[{{optNamespace}}::getlFiSize()] __attribute__((aligned(ALIGNMENT)));
  {%- else %}
  constexpr double* lFi = nullptr;
  {%- endif %}
  {%- if (!isLinear && useNCP) || useSource %}
  double lSi[{{optNamespace}}::getlSiSize()] __attribute__((aligned(ALIGNMENT)));
  {%- else %}
  constexpr double* lSi = nullptr;
  {%- endif %}
  double lQhi[{{optNamespace}}::getlQhiSize()] __attribute__((aligned(ALIGNMENT)));
  {%- if useFlux %}
  double lFhi[{{optNamespace}}::getlFhiSize()] __attribute__((aligned(ALIGNMENT)));
  {%- else %}
  constexpr double* lFhi = nullptr;
  {%- endif %}
  {%- if (!isLinear && useNCP) || useSource %}
  double lShi[{{optNamespace}}::getlShiSize()] __attribute__((aligned(ALIGNMENT)));
  {%- else %}
  constexpr double* lShi = nullptr;
  {%- endif %}
  {%- if useNCP %}
  double gradQ[{{optNamespace}}::getgradQSize()] __attribute__((aligned(ALIGNMENT)));
  {%- else %}
  constexpr double* gradQ = nullptr;
  {%- endif %}
  {%- if !isLinear %}
  double rhs[{{optNamespace}}::getlQiSize()] __attribute__((aligned(ALIGNMENT))); //same size as lQi
  {% endif %}
  {%- if usePointSources %} 
  double PSi[{{optNamespace}}::getPSiSize()] __attribute__((aligned(ALIGNMENT)));
  double PSderivatives[{{optNamespace}}::getPSiSize()] __attribute__((aligned(ALIGNMENT)));
  {%- else %}
  constexpr double* PSi = nullptr;
  constexpr double* PSderivatives = nullptr;
  {%- endif %}
{%- else %}
  double* lQi = allocateArray({{optNamespace}}::getlQiSize());
  {%- if useFlux %}
  double* lFi = allocateArray({{optNamespace}}::getlFiSize());
  {%- else %}
  constexpr double* lFi = nullptr;
  {%- endif %}
  {%- if (!isLinear && useNCP) || useSource %}
  double* lSi = allocateArray({{optNamespace}}::getlSiSize());
  {%- else %}
  constexpr double* lSi = nullptr;
  {%- endif %}
  double* lQhi = allocateArray({{optNamespace}}::getlQhiSize());
  {%- if useFlux %}
  double* lFhi = allocateArray({{optNamespace}}::getlFhiSize());
  {%- else %}
  constexpr double* lFhi = nullptr;
  {%- endif %}
  {%- if (!isLinear && useNCP) || useSource %}
  double* lShi = allocateArray({{optNamespace}}::getlShiSize());
  {%- else %}
  constexpr double* lShi = nullptr;
  {%- endif %}
  {%- if useNCP %}
  double* gradQ = allocateArray({{optNamespace}}::getgradQSize());
  {%- else %}
  constexpr double* gradQ = nullptr;
  {%- endif %}
  {%- if !isLinear %}
  double* rhs = allocateArray({{optNamespace}}::getlQiSize()); //same size as lQi
  {% endif %}
  {%- if usePointSources %} 
  double* PSi = allocateArray({{optNamespace}}::getPSiSize());
  double* PSderivatives = allocateArray({{optNamespace}}::getPSiSize());
  {%- else %}
  constexpr double* PSi = nullptr;
  constexpr double* PSderivatives = nullptr;
  {%- endif %}
{%- endif %}  

{%- if  isLinear %}
{%- if usePointSources %}
  int picardIt = -1;
  std::vector<int>* pointSources = {{optNamespace}}::getPointSources(*static_cast<{{solver}}*>(this),center,dx);
   
  if(pointSources != nullptr) {
  // perform pointsource
    {{optNamespace}}::deltaDistribution(*static_cast<{{solver}}*>(this), luh, t, dt, center, dx, pointSources, PSi);
    picardIt = {{optNamespace}}::fusedSpaceTimePredictorVolumeIntegral(*static_cast<{{solver}}*>(this), lduh, lQhbnd, lFhbnd, lQi, lFi, lSi, lQhi, lFhi, lShi, gradQ, PSi, PSderivatives, luh, tarch::la::invertEntries(dx) /*inverseDx*/, dt);
  } else {
    picardIt = {{optNamespace}}::fusedSpaceTimePredictorVolumeIntegral_WithoutPS(*static_cast<{{solver}}*>(this), lduh, lQhbnd, lFhbnd, lQi, lFi, lSi, lQhi, lFhi, lShi, gradQ, PSi, PSderivatives, luh, tarch::la::invertEntries(dx) /*inverseDx*/, dt);
  }
{%- else %}
  const int picardIt = {{optNamespace}}::fusedSpaceTimePredictorVolumeIntegral(*static_cast<{{solver}}*>(this), lduh, lQhbnd, lFhbnd, lQi, lFi, lSi, lQhi, lFhi, lShi, gradQ, PSi, PSderivatives, luh, tarch::la::invertEntries(dx) /*inverseDx*/, dt);
{%- endif %}
  
{%- else %}
  const int picardIt = {{optNamespace}}::fusedSpaceTimePredictorVolumeIntegral(*static_cast<{{solver}}*>(this), lduh, lQhbnd, lFhbnd, lQi, rhs, lFi, lSi, lQhi, lFhi, lShi, gradQ, luh, tarch::la::invertEntries(dx) /*inverseDx*/, dt);
{%- endif %}

{%- if !tempVarsOnStack %}
  freeArray(lQi);
  {%- if useFlux %}
  freeArray(lFi);
  {%- endif %}
  {%- if (!isLinear && useNCP) || useSource %}
  freeArray(lSi);
  {%- endif %}
  freeArray(lQhi);
  {%- if useFlux %}
  freeArray(lFhi);
  {%- endif %}
  {%- if (!isLinear && useNCP) || useSource %}
  freeArray(lShi);
  {%- endif %}
  {%- if useNCP %}
  freeArray(gradQ);
  {%- endif %}
  {%- if !isLinear %}
  freeArray(rhs);
  {% endif %}
  {%- if usePointSources %} 
  freeArray(PSi);
  freeArray(PSderivatives);
  {%- endif %}
{%- endif %}
  
{%- if enableProfiler %}
  _profiler->stop("fusedSpaceTimePredictorVolumeIntegral");
{%- endif %}

  return picardIt;
}



void {{project}}::{{abstractSolver}}::solutionUpdate(double* luh,const double* const lduh,const double dt) {
{%- if enableProfiler %}
  _profiler->start("solutionUpdate");
{%- endif %}
  {{optNamespace}}::solutionUpdate( luh, lduh, dt );
{%- if enableProfiler %}
  _profiler->stop("solutionUpdate");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::surfaceIntegral(double* lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
{%- if enableProfiler %}
  _profiler->start("surfaceIntegral");
{%- endif %}
  {{optNamespace}}::surfaceIntegral( lduh, lFhbnd, inverseDx );
{%- if enableProfiler %}
  _profiler->stop("surfaceIntegral");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::riemannSolver(double* FL,double* FR,const double* const QL,const double* const QR,const double dt,const int normalNonZeroIndex,bool isBoundaryFace, int faceIndex) {
  assertion2(normalNonZeroIndex>=0,dt,normalNonZeroIndex);
  assertion2(normalNonZeroIndex<DIMENSIONS,dt,normalNonZeroIndex);
{%- if enableProfiler %}
  _profiler->start("riemannSolver");
{%- endif %}
  {{optNamespace}}::riemannSolver(*static_cast<{{solver}}*>(this), FL, FR, QL, QR, dt, normalNonZeroIndex {%- if enableDeepProfiler %}, _profiler.get(){% endif %});
{%- if enableProfiler %}
  _profiler->stop("riemannSolver");
{%- endif %}
}



//void {{project}}::{{abstractSolver}}::boundaryConditions(double* fluxOut,double* stateOut,const double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {
void {{project}}::{{abstractSolver}}::boundaryConditions(double* fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int direction) {
{%- if enableProfiler %}
  _profiler->start("boundaryConditions");
{%- endif %}

{%- if tempVarsOnStack %}
  double stateOut[{{optNamespace}}::getBndFaceSize()] __attribute__((aligned(ALIGNMENT)));
  double fluxOut[ {{optNamespace}}::getBndFluxSize()] __attribute__((aligned(ALIGNMENT)));
{%- else %}
  double* stateOut = allocateArray({{optNamespace}}::getBndFaceSize());
  double* fluxOut  =  allocateArray({{optNamespace}}::getBndFluxSize());
{%- endif %}

  {{optNamespace}}::boundaryConditions(*static_cast<{{solver}}*>(this), fluxOut, stateOut, fluxIn, stateIn, cellCentre, cellSize, t, dt, faceIndex, direction);
  
  if (faceIndex % 2 == 0) {
    riemannSolver(fluxOut,fluxIn,stateOut,stateIn,dt,direction,true,faceIndex);
  }
  else {
    riemannSolver(fluxIn,fluxOut,stateIn,stateOut,dt,direction,true,faceIndex);
  }
  
{%- if !tempVarsOnStack %}
  freeArray(stateOut);
  freeArray(fluxOut);
{%- endif %}
  
{%- if enableProfiler %}
  _profiler->stop("boundaryConditions");
{%- endif %}
}



double {{project}}::{{abstractSolver}}::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
{%- if enableProfiler %}
  _profiler->start("stableTimeStepSize");
{%- endif %}
  double d = {{optNamespace}}::stableTimeStepSize(*static_cast<{{solver}}*>(this), luh, inverseDx );
{%- if enableProfiler %}
  _profiler->stop("stableTimeStepSize");
{%- endif %}
  return d;
}



{%- if !patchwiseAdjust %}
void {{project}}::{{abstractSolver}}::adjustSolution(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) {
{%- if enableProfiler %}
  _profiler->start("solutionAdjustment");
{%- endif %}
  {{optNamespace}}::solutionAdjustment(*static_cast<{{solver}}*>(this), luh, center, dx, t, dt );

{%- if enableProfiler %}
  _profiler->stop("solutionAdjustment");
{%- endif %}
}
{%- endif %}

/*
//legacy
void {{project}}::{{abstractSolver}}::deltaDistribution(const double t,const double dt, const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx, double** tempPointForceSources) {
{%- if usePointSources %}
{%- if enableProfiler %}
  _profiler->start("deltaDistribution");
{%- endif %}
  {{optNamespace}}::deltaDistribution(*static_cast<{{solver}}*>(this), t, dt, center, dx, tempPointForceSources);
{%- if enableProfiler %}
  _profiler->stop("deltaDistribution");
{%- endif %}
{%- else %}
  //Point sources aren't defined, this method should be empty
{%- endif %}
}
*/


void {{project}}::{{abstractSolver}}::faceUnknownsProlongation(double* lQhbndFine,double* lFhbndFine,const double* lQhbndCoarse,const double* lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{%- if enableProfiler %}
  _profiler->start("faceUnknownsProlongation");
{%- endif %}
  {{optNamespace}}::faceUnknownsProlongation( lQhbndFine, lFhbndFine, lQhbndCoarse, lFhbndCoarse, coarseGridLevel, fineGridLevel, subfaceIndex);
{%- if enableProfiler %}
  _profiler->start("faceUnknownsProlongation");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::faceUnknownsRestriction(double* lQhbndCoarse,double* lFhbndCoarse,const double* lQhbndFine,const double* lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{%- if enableProfiler %}
  _profiler->start("faceUnknownsRestriction");
{%- endif %}
  {{optNamespace}}::faceUnknownsRestriction( lQhbndCoarse, lFhbndCoarse, lQhbndFine, lFhbndFine, coarseGridLevel, fineGridLevel, subfaceIndex);
{%- if enableProfiler %}
  _profiler->stop("faceUnknownsRestriction");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::volumeUnknownsProlongation(double* luhFine,const double* luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{%- if enableProfiler %}
  _profiler->start("volumeUnknownsProlongation");
{%- endif %}
  {{optNamespace}}::volumeUnknownsProlongation( luhFine, luhCoarse, coarseGridLevel, fineGridLevel, subcellIndex);
{%- if enableProfiler %}
  _profiler->stop("volumeUnknownsProlongation");
{%- endif %}
}



void {{project}}::{{abstractSolver}}::volumeUnknownsRestriction(double* luhCoarse,const double* luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{%- if enableProfiler %}
  _profiler->start("volumeUnknownsRestriction");
{%- endif %}
  {{optNamespace}}::volumeUnknownsRestriction( luhCoarse, luhFine, coarseGridLevel, fineGridLevel, subcellIndex);
{%- if enableProfiler %}
  _profiler->stop("volumeUnknownsRestriction");
{%- endif %}
}

//--------

void {{project}}::{{abstractSolver}}::abortWithMsg(const char* const msg) {
	// verbosily fail even without assertions turned on
	puts(msg);
	abort();
}

void {{project}}::{{abstractSolver}}::flux(const double* const Q,double** F) {
  abortWithMsg("If this operation is entered (flux), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::algebraicSource(const double* const Q,double* S) {
  abortWithMsg("If this operation is entered (algebraicSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}
        
void {{project}}::{{abstractSolver}}::nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) {
  abortWithMsg("If this operation is entered (nonConservativeProduct), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::pointSource(const double* const Q,const double* const x,const double t,const double dt, double* forceVector,int n) {
  abortWithMsg("If this operation is entered (pointSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}
