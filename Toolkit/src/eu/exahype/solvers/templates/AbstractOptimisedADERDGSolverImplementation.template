// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "{{AbstractSolver}}.h"
#include "{{optKernelPath}}/Kernels.h"

#include "{{Solver}}.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include <stdio.h>

// We define the constructor of the actual solver here in order to regenerate it easily.
{{Project}}::{{Solver}}::{{Solver}}(double maximumMeshSize,int maximumAdaptiveMeshDepth,int DMPObservables,int limiterHelperLayers,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs{{SolverConstructorSignatureExtension}}):
  {{AbstractSolver}}::{{AbstractSolver}}(maximumMeshSize,maximumAdaptiveMeshDepth,DMPObservables,limiterHelperLayers,timeStepping{{AbstractSolverConstructorArgumentExtension}}) {
  init(cmdlineargs{{SolverInitCallExtension}});
}

{{Project}}::{{AbstractSolver}}::{{AbstractSolver}}(double maximumMeshSize,int maximumAdaptiveMeshDepth,int DMPObservables,int limiterHelperLayers,exahype::solvers::Solver::TimeStepping timeStepping{{AbstractSolverConstructorSignatureExtension}}):
  exahype::solvers::ADERDGSolver("{{Solver}}",{{optNamespace}}::getNumberOfVariable(),{{optNamespace}}::getNumberOfParameter(),{{optNamespace}}::getBasisSize(),
                                 maximumMeshSize,maximumAdaptiveMeshDepth,DMPObservables,limiterHelperLayers,timeStepping{{SolverConstructorArgumentExtension}}) {
}

void {{Project}}::{{AbstractSolver}}::constantsToString(std::ostream& os) {
	// This string is used in the --version output to identify compile time constants
	os << "{{Project}}::{{AbstractSolver}}("
	   << "nVar=" << NumberOfVariables << ", "
	   << "nParam=" << NumberOfParameters << ", "
	   << "nDim=" << Dimensions << ", "
	   << "order=" << Order
	   << ")";
}

void {{Project}}::{{AbstractSolver}}::spaceTimePredictor(double* lQhbnd,double* lFhbnd,double** tempSpaceTimeUnknowns,double** tempSpaceTimeFluxUnknowns,double* tempUnknowns,double* tempFluxUnknowns,double* tempStateSizedVectors,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& inverseDx,const double dt, double* pointForceSources) {
{{BeforeSpaceTimePredictor}} 

#if DIMENSIONS==2
  constexpr int lSi_offset  = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  constexpr int lShi_offset = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded();//nDim*(nDof**nDim)*nVarPad
#else
  constexpr int lSi_offset  = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  constexpr int lShi_offset = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded();//nDim*(nDof**nDim)*nVarPad
#endif

#ifdef NO_TIME_AVERAGING
  {{optNamespace}}::picardLoopNonlinear(*static_cast<{{Solver}}*>(this), luh, dt, inverseDx, tempSpaceTimeUnknowns[0], tempSpaceTimeUnknowns[1], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], tempSpaceTimeFluxUnknowns[1], tempStateSizedVectors{{DeepProfilerArg}}); //lSi, gradQ, BGradQ
  {{optNamespace}}::extrapolatorNonlinear(tempSpaceTimeUnknowns[0], tempSpaceTimeFluxUnknowns[0], lQhbnd, lFhbnd);
#else
  {{optNamespace}}::picardLoopNonlinear(*static_cast<{{Solver}}*>(this), luh, dt, inverseDx, tempSpaceTimeUnknowns[0], tempSpaceTimeUnknowns[1], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], tempSpaceTimeFluxUnknowns[1], tempStateSizedVectors{{DeepProfilerArg}}); //lSi, gradQ, BGradQ
  {{optNamespace}}::predictorNonlinear(tempSpaceTimeUnknowns[0], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], tempUnknowns, tempFluxUnknowns, &tempFluxUnknowns[lShi_offset]);
  {{optNamespace}}::extrapolatorNonlinear(tempUnknowns, tempFluxUnknowns, lQhbnd, lFhbnd);
#endif
  
{{AfterSpaceTimePredictor}}
}



void {{Project}}::{{AbstractSolver}}::solutionUpdate(double* luh,const double* const lduh,const double dt) {
{{BeforeSolutionUpdate}}
  {{optNamespace}}::solutionUpdate( luh, lduh, dt );
{{AfterSolutionUpdate}}
}



void {{Project}}::{{AbstractSolver}}::volumeIntegral(double* lduh,const double* const lFhi,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
{{BeforeVolumeIntegral}}

#if DIMENSIONS==2
  constexpr int lSi_offset  = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  constexpr int lShi_offset = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded();//nDim*(nDof**nDim)*nVarPad
#else
  constexpr int lSi_offset  = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  constexpr int lShi_offset = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded();//nDim*(nDof**nDim)*nVarPad
#endif

#ifdef NO_TIME_AVERAGING
  {{optNamespace}}::volumeIntegral( lduh, lFhi, &lFhi[lSi_offset], inverseDx ); //lFhi is actually lFi
#else
  {{optNamespace}}::volumeIntegral( lduh, lFhi, &lFhi[lShi_offset], inverseDx );
#endif

{{AfterVolumeIntegral}}
}



void {{Project}}::{{AbstractSolver}}::surfaceIntegral(double* lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
{{BeforeSurfaceIntegral}}
  {{optNamespace}}::surfaceIntegral( lduh, lFhbnd, inverseDx );
{{AfterSurfaceIntegral}}
}



void {{Project}}::{{AbstractSolver}}::riemannSolver(double* FL,double* FR,const double* const QL,const double* const QR,double* tempFaceUnknownsArray,double** tempStateSizedVectors,double** tempStateSizedSquareMatrices,const double dt,const int normalNonZeroIndex,bool isBoundaryFace) {
  assertion2(normalNonZeroIndex>=0,dt,normalNonZeroIndex);
  assertion2(normalNonZeroIndex<DIMENSIONS,dt,normalNonZeroIndex);
{{BeforeRiemannSolver}}

  {{optNamespace}}::riemannSolver(*static_cast<{{Solver}}*>(this), FL, FR, QL, QR, dt, normalNonZeroIndex{{DeepProfilerArg}});

{{AfterRiemannSolver}}
}



void {{Project}}::{{AbstractSolver}}::boundaryConditions(double* fluxOut,double* stateOut,const double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {
{{BeforeBoundaryConditions}}
  {{optNamespace}}::boundaryConditions(*static_cast<{{Solver}}*>(this), fluxOut, stateOut, fluxIn, stateIn, cellCentre, cellSize, t, dt, faceIndex, normalNonZero );
{{AfterBoundaryConditions}}
}



double {{Project}}::{{AbstractSolver}}::stableTimeStepSize(const double* const luh,double* tempEigenvalues,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
{{BeforeStableTimeStepSize}}
  double d = {{optNamespace}}::stableTimeStepSize(*static_cast<{{Solver}}*>(this), luh, inverseDx );
{{AfterStableTimeStepSize}}
  return d;
}



void {{Project}}::{{AbstractSolver}}::adjustSolution(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) {
{{BeforeSolutionAdjustment}}
  switch (useAdjustSolution(center, dx, t, dt)) {
    case AdjustSolutionValue::No:
      assertionMsg(false, "Branch may not be entered. Solver spec clarifies that adjust solution is not to be called, but kernel nevertheless invokes adjustSolution." );
      break;
    case AdjustSolutionValue::PointWisely:
      {{optNamespace}}::adjustPointSolution(*static_cast<{{Solver}}*>(this), luh, center, dx, t, dt );
      break;
    case AdjustSolutionValue::PatchWisely:
      printf("\nAdjustSolutionValue::PatchWisely not implemented ! \n");
      exit(1);
     //TODO JMG not implemented
      break;
  }
{{AfterSolutionAdjustment}}
}



void {{Project}}::{{AbstractSolver}}::faceUnknownsProlongation(double* lQhbndFine,double* lFhbndFine,const double* lQhbndCoarse,const double* lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{{BeforeFaceUnknownsProlongation}}
  // {{optNamespace}}::faceUnknownsProlongation( lQhbndFine, lFhbndFine, lQhbndCoarse, lFhbndCoarse, coarseGridLevel, fineGridLevel, subfaceIndex, getNumberOfVariables(), getNumberOfParameters(), getNodesPerCoordinateAxis() ); //TODO JMG, uncomment in Toolkit when kernel implemented
{{AfterFaceUnknownsProlongation}}
}



void {{Project}}::{{AbstractSolver}}::faceUnknownsRestriction(double* lQhbndCoarse,double* lFhbndCoarse,const double* lQhbndFine,const double* lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{{BeforeFaceUnknownsRestriction}}
  // {{optNamespace}}::faceUnknownsRestriction( lQhbndCoarse, lFhbndCoarse, lQhbndFine, lFhbndFine, coarseGridLevel, fineGridLevel, subfaceIndex, getNumberOfVariables(), getNumberOfParameters(), getNodesPerCoordinateAxis() ); //TODO JMG, uncomment in Toolkit when kernel implemented
{{AfterFaceUnknownsRestriction}}
}



void {{Project}}::{{AbstractSolver}}::volumeUnknownsProlongation(double* luhFine,const double* luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{{BeforeVolumeUnknownsProlongation}}
  // {{optNamespace}}::volumeUnknownsProlongation( luhFine, luhCoarse, coarseGridLevel, fineGridLevel, subcellIndex, getNumberOfVariables(), getNumberOfParameters(), getNodesPerCoordinateAxis() ); //TODO JMG, uncomment in Toolkit when kernel implemented
{{AfterVolumeUnknownsProlongation}}
}



void {{Project}}::{{AbstractSolver}}::volumeUnknownsRestriction(double* luhCoarse,const double* luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{{BeforeVolumeUnknownsRestriction}}
  // {{optNamespace}}::volumeUnknownsRestriction( luhCoarse, luhFine, coarseGridLevel, fineGridLevel, subcellIndex, getNumberOfVariables(), getNumberOfParameters(), getNodesPerCoordinateAxis() ); //TODO JMG, uncomment in Toolkit when kernel implemented
{{AfterVolumeUnknownsRestriction}}
}

//--------

void {{Project}}::{{AbstractSolver}}::abortWithMsg(const char* const msg) {
	// verbosily fail even without assertions turned on
	puts(msg);
	abort();
}


void {{Project}}::{{AbstractSolver}}::pointSource(const double t,const double dt, const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx, double* tempPointForceSources) {
  //TODO JMG
}

void {{Project}}::{{AbstractSolver}}::flux(const double* const Q,double** F) {
  abortWithMsg("If this operation is entered (flux), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{Project}}::{{AbstractSolver}}::algebraicSource(const double* const Q,double* S) {
  abortWithMsg("If this operation is entered (algebraicSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}
        
void {{Project}}::{{AbstractSolver}}::nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) {
  abortWithMsg("If this operation is entered (nonConservativeProduct), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{Project}}::{{AbstractSolver}}::pointSource(const double* const x,const double t,const double dt, double* forceVector, double* x0) {
  abortWithMsg("If this operation is entered (pointSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{Project}}::{{AbstractSolver}}::adjustPointSolution(const double* const x,const double w,const double t,const double dt,double* Q) {
  abortWithMsg("If this operation is entered (adjustPointSolution), you have activated the corresponding guard. Then you have to re-implement this routine, too." );}

void {{Project}}::{{AbstractSolver}}::adjustPatchSolution(
  const tarch::la::Vector<DIMENSIONS, double>& cellCentre,
  const tarch::la::Vector<DIMENSIONS, double>& dx,
  const double t,
  const double dt,
  double* luh) {
  abortWithMsg("If this operation is entered (adjustPatchSolution), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}


void {{Project}}::{{AbstractSolver}}::fusedSource(const double* const Q, const double* const gradQ, double* S) {
  abortWithMsg("If this operation is entered (fusedSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{Project}}::{{AbstractSolver}}::coefficientMatrix(const double* const Q,const int d,double* Bn) {
  // needed ?
}
