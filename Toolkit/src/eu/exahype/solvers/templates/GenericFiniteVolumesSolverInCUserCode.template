#include "{{Solver}}.h"

#include "{{Solver}}_Variables.h"


tarch::logging::Log {{Project}}::{{Solver}}::_log( "{{Project}}::{{Solver}}" );


void {{Project}}::{{Solver}}::init(std::vector<std::string>& cmdlineargs{{SolverInitSignatureExtension}}) {
  // @todo Please implement/augment if required
}

void {{Project}}::{{Solver}}::adjustSolution(const double* const x,const double w,const double t,const double dt, double* Q) {
  // Dimensions             = {{Dimensions}}
  // Number of variables    = {{Elements}} + #parameters
  
  // @todo Please implement/augment if required
{{AdjustedSolutionValues}}
}

exahype::solvers::Solver::RefinementControl {{Project}}::{{Solver}}::refinementCriterion(const double* luh, const tarch::la::Vector<DIMENSIONS, double>& center,const tarch::la::Vector<DIMENSIONS, double>& dx, double t,const int level) {
  // @todo Please implement/augment if required
  return exahype::solvers::Solver::RefinementControl::Keep;
}


void {{Project}}::{{Solver}}::eigenvalues(const double* const Q, const int dIndex, double* lambda) {
  // Dimensions             = {{Dimensions}}
  // Number of variables    = {{Elements}} + #parameters
  
  // @todo Please implement/augment if required
{{Eigenvalues}}
}

void {{Project}}::{{Solver}}::flux(const double* const Q, double** F) {
  // Dimensions             = {{Dimensions}}
  // Number of variables    = {{Elements}} + #parameters
  
  // @todo Please implement/augment if required
{{Flux}}
}



void {{Project}}::{{Solver}}::boundaryValues(
    const double* const x,
    const double t,const double dt,
    const int faceIndex,
    const int d,
    const double* const stateInside,
    double* stateOutside) {
  // Dimensions             = {{Dimensions}}
  // Number of variables    = {{Elements}} + #parameters

  // @todo Please implement/augment if required
{{BoundaryValues}}
}



{%- if useNCP %}
void {{Project}}::{{Solver}}::nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) {
  // @todo Please implement/augment if required
} 
{%- endif %}

{%- if useSource %}
void {{Project}}::{{Solver}}::algebraicSource(const double* const Q,double* S) {
  // @todo Please implement/augment if required
}
{%- endif %}
    
{%- if useFlux %}
void {{Project}}::{{Solver}}::flux(const double* const Q,double** F) {
  // @todo Please implement/augment if required
}
{%- endif %}
    
{%- if usePointSource %}
void {{Project}}::{{Solver}}::pointSource(const double* const x,const double t,const double dt, double* forceVector, double* x0) {
  // @todo Please implement/augment if required
}
{%- endif %}
