// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#ifndef __{{Solver}}_Variables_CLASS_HEADER__
#define __{{Solver}}_Variables_CLASS_HEADER__

#include "Abstract{{Solver}}.h"

#include <algorithm>

#include "tarch/la/Matrix.h"

/**
 * Generic information about the variable string as it was declared in the
 * specification file
 **/
struct {{Project}}::Abstract{{Solver}}::VariableMetrics {
  static constexpr int numDistinctVariables = {{variablesMapSize}};
  static constexpr int SizeVariables = {{NumberOfVariables}}; 
  static constexpr int SizeParameters = {{NumberOfParameters}};
  static constexpr int Size           = {{NumberOfVariables}}+{{NumberOfParameters}};
  static constexpr int Dimensions    = DIMENSIONS;
};

/**
 * Positions of fields in the vector of unkonwns.
 *
 * With these constants, you can write Q[g11], Q[K22] and Q[B33] instead of
 * Q[0], Q[9] and Q[34]. Your code is meaningful in terms of physics while
 * you still access on a C-array level.
 *
 * You might want to use a typedef to shorten the notation or create 
 * an instance of this class.
 **/
class {{Project}}::Abstract{{Solver}}::VariableShortcuts : public {{Project}}::Abstract{{Solver}}::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
  int _Q[numDistinctVariables + 1] = { {{VariableShortcutsArray}} };

{{VariableShortcuts}}

  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableShortcuts

/**
 * Lengths (multplicities) of each field inside the unknown vector Q.
 * For instance, 0 means "scalar field" while any value >0 may mean a vector field or
 * even a "linearized" tensor field
 **/
class {{Project}}::Abstract{{Solver}}::VariableMultiplicities : public {{Project}}::Abstract{{Solver}}::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
  int _Q[numDistinctVariables + 1] = { {{VariableMultiplicitiesArray}} };

{{VariableMultiplicities}}

  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableMultiplicities

/**
 * Variable names as strings as given in the toolkit.
 * 
 * These names might want to be used for plotting, output, etc.
 *
 **/
class {{Project}}::Abstract{{Solver}}::VariableNames : public {{Project}}::Abstract{{Solver}}::VariableMetrics {
public:
  char const *_Q[numDistinctVariables + 1] = { {{VariableNamesArray}} };

{{VariableNames}}

  const char* const* asArray() const { return _Q; } // type: whatever
  const char* operator [] (int index) const { return _Q[index]; }
  const char* operator () (int index) const { return _Q[index]; }
}; // end of VariableNames

/**
 * Positions of fields in the vector of unknowns,
 * available as namespace constants.
 * 
 * You can use this namespace similar to the class "VariableShortcuts"
 * but you don't need an object, ie. your notation can get slimmer.
 * 
 * Usage is like:
 * 
 *    void somewhere() {
 *       using namespace {{Project}}::{{Solver}}_Variables::shortcuts;
 *       Q[foo] = 17;
 *    }
 *
 * instead of
 * 
 *    void somewhere() {
 *       {{Project}}::Abstract{{Solver}}::VariableNames q;
 *       Q[q.foo] = 17;
 *    }
 *
 **/
namespace {{Project}} {
	namespace {{Solver}}_Variables {
		namespace shortcuts {
			{{VariableShortcuts}}
		} // namespace shortcuts
		namespace names {
			{{VariableNames}}
		} // namespace names
	} // end of namespace {{Project}}::{{Solver}}_Variables 
} // end of namespace {{Project}}

/*
 * Another class idea:
 * 
 * class ....::VariablePointers {
 *   private:   double* Q;
 *   public:
 *      double &varfoo;
 *      double &varbar;
 *      VariablePointers(double*Q) : varfoo(Q[0]), bar(Q[1]), ... {}
 * }
 * 
 * Advantages: Use as positions in Q.
 *
 */


class {{Project}}::Abstract{{Solver}}::ReadOnlyVariables : public {{Project}}::Abstract{{Solver}}::VariableMetrics {
  private:
    const double* const _Q;
  public:
    ReadOnlyVariables(const double* const Q) : _Q(Q) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    const double* data() const {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // Java-generated code for VariablesGetters:

{{VariablesGetters}}
}; // end of ReadOnlyVariables


class {{Project}}::Abstract{{Solver}}::Variables : public {{Project}}::Abstract{{Solver}}::VariableMetrics{
  private:
    double* _Q;
  public:
    static constexpr int SizeVariables  = {{NumberOfVariables}};
    static constexpr int SizeParameters = {{NumberOfParameters}};
    static constexpr int Size           = {{NumberOfVariables}}+{{NumberOfParameters}};
  
    Variables(double* Q) : _Q(Q) {}
    
    void operator = (Variables& variables) {
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    void operator = (ReadOnlyVariables& variables) {
      assertion(variables.variables()==SizeVariables);
      assertion(variables.parameters()==SizeParameters);
      assertion(variables.size()==Size);
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double* data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // Java-generated code for VariablesGetters:

{{VariablesGetters}}

    // Java-generated code for VariablesSetters:

{{VariablesSetters}}
}; // end of Variables


class {{Project}}::Abstract{{Solver}}::Fluxes : public {{Project}}::Abstract{{Solver}}::VariableMetrics {
  private:
    double** _F;
  public:
    Fluxes(double** F) : _F(F) {}
    
    /** The rows of the flux tensor. */
    int variables() const {
      return SizeVariables;
    }
    
    /** The columns of the flux tensor. */
    int dimensions() const {
      return Dimensions;
    }


    // Java-generated code for FluxGetters:

{{FluxesGetters}}

    // Java-generated code for FluxSetters:

{{FluxesSetters}}
}; // end of Fluxes

// NamingSchemes:
{{NamingSchemes}}

#endif
