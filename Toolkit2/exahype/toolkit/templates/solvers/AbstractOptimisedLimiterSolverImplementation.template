// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "{{abstractSolver}}.h"

#include "{{optKernelPath}}/Kernels.h"

{% if countFlops  %}
#include <chrono>
#include <ratio>
{% endif %}

{% if countFlops  %}
std::atomic_ulong {{project}}::{{abstractSolver}}::total_flops = 0;
std::atomic_ulong {{project}}::{{abstractSolver}}::total_time = 0;

std::atomic_ulong {{project}}::{{abstractSolver}}::projectOnFVLimiterSpace_f = 0;
std::atomic_ulong {{project}}::{{abstractSolver}}::projectOnFVLimiterSpace_t = 0;
std::atomic_ulong {{project}}::{{abstractSolver}}::projectOnFVLimiterSpace_c = 0;
  
std::atomic_ulong {{project}}::{{abstractSolver}}::projectOnDGSpace_f = 0;
std::atomic_ulong {{project}}::{{abstractSolver}}::projectOnDGSpace_t = 0;
std::atomic_ulong {{project}}::{{abstractSolver}}::projectOnDGSpace_c = 0;
    
std::atomic_ulong {{project}}::{{abstractSolver}}::discreteMaximumPrincipleAndMinAndMaxSearch_f = 0;
std::atomic_ulong {{project}}::{{abstractSolver}}::discreteMaximumPrincipleAndMinAndMaxSearch_t = 0;
std::atomic_ulong {{project}}::{{abstractSolver}}::discreteMaximumPrincipleAndMinAndMaxSearch_c = 0;
    
std::atomic_ulong {{project}}::{{abstractSolver}}::findCellLocalMinAndMax_f = 0;
std::atomic_ulong {{project}}::{{abstractSolver}}::findCellLocalMinAndMax_t = 0;
std::atomic_ulong {{project}}::{{abstractSolver}}::findCellLocalMinAndMax_c = 0;
    
std::atomic_ulong {{project}}::{{abstractSolver}}::findCellLocalLimiterMinAndMax_f = 0;
std::atomic_ulong {{project}}::{{abstractSolver}}::findCellLocalLimiterMinAndMax_t = 0;
std::atomic_ulong {{project}}::{{abstractSolver}}::findCellLocalLimiterMinAndMax_c = 0;
{% endif %}

// Just call parent constructor
{{project}}::{{abstractSolver}}::{{abstractSolver}}(
        const double maximumMeshSize,
        const int maximumMeshDepth,
        const int haloCells,
        const int regularisedFineGridLevels,
        const exahype::solvers::Solver::TimeStepping timeStepping,
        const int DMPObservables,
        const int limiterHelperLayers,
        const double DMPRelaxationParameter,
        const double DMPDifferenceScaling,
        const int iterationsToCureTroubledCell 
        {% if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %}) :
  exahype::solvers::LimitingADERDGSolver::LimitingADERDGSolver(
    {{solver}},
    new {{project}}::{{ADERDGSolver}}(
      maximumMeshSize,maximumMeshDepth,haloCells,regularisedFineGridLevels,timeStepping,DMPObservables,limiterHelperLayers),
    new {{project}}::{{FVSolver}}(
      maximumMeshSize, timeStepping),
    DMPRelaxationParameter,
    DMPDifferenceScaling,
iterationsToCureTroubledCell) {}

void {{project}}::{{abstractSolver}}::projectOnFVLimiterSpace(const double* const luh, double* const lim) const {
{% if countFlops  %}
  const std::chrono::high_resolution_clock::time_point timeStart = std::chrono::high_resolution_clock::now();
{% endif %}
  
  {{optNamespace}}::projectOnFVLimiterSpace(luh, lim);

{% if countFlops  %}
  double time = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now()-timeStart).count();
  const unsigned long time_ul = (unsigned long) time;
  const unsigned long f ={{optNamespace}}::projectOnFVLimiterSpace_flops;
  total_flops += f;
  total_time += time_ul;
  projectOnFVLimiterSpace_f += f;
  projectOnFVLimiterSpace_t += time_ul;
  projectOnFVLimiterSpace_c += 1;
{% endif %} 
}

void {{project}}::{{abstractSolver}}::projectOnDGSpace(const double* const lim, double* const luh) const {
{% if countFlops  %}
  const std::chrono::high_resolution_clock::time_point timeStart = std::chrono::high_resolution_clock::now();
{% endif %}
  
  {{optNamespace}}::projectOnDGSpace(lim, luh);

{% if countFlops  %}
  double time = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now()-timeStart).count();
  const unsigned long time_ul = (unsigned long) time;
  const unsigned long f ={{optNamespace}}::projectOnDGSpace_flops;
  total_flops += f;
  total_time += time_ul;
  projectOnDGSpace_f += f;
  projectOnDGSpace_t += time_ul;
  projectOnDGSpace_c += 1;
{% endif %} 
}

bool {{project}}::{{abstractSolver}}::discreteMaximumPrincipleAndMinAndMaxSearch(const double* const luh, double* boundaryMinPerVariables, double* boundaryMaxPerVariables) {
{% if countFlops  %}
  const std::chrono::high_resolution_clock::time_point timeStart = std::chrono::high_resolution_clock::now();
{% endif %}
  
  const bool r =  {{optNamespace}}::discreteMaximumPrincipleAndMinAndMaxSearch(luh, _solver.get(), _DMPMaximumRelaxationParameter, _DMPDifferenceScaling, boundaryMinPerVariables, boundaryMaxPerVariables);

{% if countFlops  %}
  double time = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now()-timeStart).count();
  const unsigned long time_ul = (unsigned long) time;
  const unsigned long f ={{optNamespace}}::discreteMaximumPrincipleAndMinAndMaxSearch_flops;
  total_flops += f;
  total_time += time_ul;
  discreteMaximumPrincipleAndMinAndMaxSearch_f += f;
  discreteMaximumPrincipleAndMinAndMaxSearch_t += time_ul;
  discreteMaximumPrincipleAndMinAndMaxSearch_c += 1;
{% endif %}

  return r;
}

void {{project}}::{{abstractSolver}}::findCellLocalMinAndMax(const double* const luh, double* const localMinPerVariables, double* const localMaxPerVariable) {
{% if countFlops  %}
  const std::chrono::high_resolution_clock::time_point timeStart = std::chrono::high_resolution_clock::now();
{% endif %}
  
  {{optNamespace}}::findCellLocalMinAndMax(luh, _solver.get(), localMinPerVariables, localMaxPerVariable);

{% if countFlops  %}
  double time = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now()-timeStart).count();
  const unsigned long time_ul = (unsigned long) time;
  const unsigned long f ={{optNamespace}}::findCellLocalMinAndMax_flops;
  total_flops += f;
  total_time += time_ul;
  findCellLocalMinAndMax_f += f;
  findCellLocalMinAndMax_t += time_ul;
  findCellLocalMinAndMax_c += 1;
{% endif %} 
}

void {{project}}::{{abstractSolver}}::findCellLocalLimiterMinAndMax(const double* const lim, double* const localMinPerObservable, double* const localMaxPerObservable) {
{% if countFlops  %}
  const std::chrono::high_resolution_clock::time_point timeStart = std::chrono::high_resolution_clock::now();
{% endif %}
  
  {{optNamespace}}::findCellLocalLimiterMinAndMax(lim, _solver.get(), localMinPerObservable,localMaxPerObservable);

{% if countFlops  %}
  double time = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now()-timeStart).count();
  const unsigned long time_ul = (unsigned long) time;
  const unsigned long f ={{optNamespace}}::findCellLocalLimiterMinAndMax_flops;
  total_flops += f;
  total_time += time_ul;
  findCellLocalLimiterMinAndMax_f += f;
  findCellLocalLimiterMinAndMax_t += time_ul;
  findCellLocalLimiterMinAndMax_c += 1;
{% endif %} 
}
