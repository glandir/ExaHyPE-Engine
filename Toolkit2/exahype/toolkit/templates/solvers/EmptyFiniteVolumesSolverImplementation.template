{% set solver            = data["solver"]["name"] + "_FV" if data["solver"]["type"]=="Limiting-ADER-DG" else "" %}
{% set abstractSolver    = "Abstract"+solver %}
{% set patchSize         = 2*data["solver"]["order"]+1 if data["solver"]["type"]=="Limiting-ADER-DG" else data["solver"]["patch_size"] %}
{% set kernel            = data["solver"]["fv_kernel"] %}
{% set finiteVolumesType = data["solver"]["fv_kernel"].get("scheme","godunov") %}
{% set _ghostLayers      = { "godunov" : 1, "musclhancock" : 2 } %}
{% set ghostLayerWidth   = _ghostLayers[finiteVolumesType] %}
{% set tempVarsOnStack   = kernel.get("allocate_temporary_arrays","heap")=="stack"       %}
{% set patchwiseAdjust   = kernel.get("adjust_solution","pointwise")     =="patchwise"   %}
{% set useFlux           = "flux" in kernel["terms"]               %}
{% set useSource         = "source" in kernel["terms"]             %}
{% set useNCP            = "ncp" in kernel["terms"]                %}
{% set usePointSources   = "pointsources" in kernel["terms"]       %}
{% set useMaterialParam  = "materialparameters" in kernel["terms"] %}
#include "{{Solver}}.h"

#include "tarch/la/ScalarOperations.h"

{{Project}}::{{Solver}}::{{Solver}}(int cellsPerCoordinateAxis, double maximumMeshSize, exahype::solvers::Solver::TimeStepping timeStepping{{SolverConstructorSignatureExtension}}):
  exahype::solvers::FiniteVolumesSolver("{{Solver}}", {{NumberOfVariables}}, {{NumberOfParameters}}, cellsPerCoordinateAxis, 1 /* ghost layer width */, maximumMeshSize, timeStepping{{SolverConstructorArgumentExtension}}) {
  // @todo Please implement/augment if required
}

double {{Project}}::{{Solver}}::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx) {
  // @todo Please implement/augment if required
  return std::numeric_limits<double>::max();
}

void {{Project}}::{{Solver}}::solutionUpdate(double* luhNew,const double* luh,const tarch::la::Vector<DIMENSIONS, double>& dx,const double dt, double& maxAdmissibleDt) {
  // @todo Please implement/augment if required
  maxAdmissibleDt = std::numeric_limits<double>::max();
}

void {{Project}}::{{Solver}}::adjustSolution(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) {
  // @todo Please implement/augment if required
}

void {{Project}}::{{Solver}}::ghostLayerFilling(double* luh,const double* luhNeighbour,const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) {
  // @todo Please implement/augment if required
}

void {{Project}}::{{Solver}}::ghostLayerFillingAtBoundary(double* luh,const double* luhbnd,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  // @todo Please implement/augment if required
}

void {{Project}}::{{Solver}}::boundaryLayerExtraction(double* luhbnd,const double* luh,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  // @todo Please implement/augment if required
}

void {{Project}}::{{Solver}}::boundaryConditions(double* stateOut,const double* const stateIn,const tarch::la::Vector<DIMENSIONS, double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {
  // @todo Please implement/augment if required
}

exahype::solvers::Solver::RefinementControl {{Project}}::{{Solver}}::refinementCriterion(const double* luh, const tarch::la::Vector<DIMENSIONS, double>& center,const tarch::la::Vector<DIMENSIONS, double>& dx, double t,const int level) {
  // @todo Please implement/augment if required
  return exahype::solvers::Solver::RefinementControl::Keep;
}
