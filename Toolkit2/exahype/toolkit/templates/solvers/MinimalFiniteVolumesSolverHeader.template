{% set solver            = data["solver"]["name"] + "_FV" if data["solver"]["type"]=="Limiting-ADER-DG" else "" %}
{% set abstractSolver    = "Abstract"+solver %}
{% set patchSize         = 2*data["solver"]["order"]+1 if data["solver"]["type"]=="Limiting-ADER-DG" else data["solver"]["patch_size"] %}
{% set kernel            = data["solver"]["fv_kernel"] %}
{% set finiteVolumesType = data["solver"]["fv_kernel"].get("scheme","godunov") %}
{% set _ghostLayers      = { "godunov" : 1, "musclhancock" : 2 } %}
{% set ghostLayerWidth   = _ghostLayers[finiteVolumesType] %}
{% set tempVarsOnStack   = kernel.get("allocate_temporary_arrays","heap")=="stack"       %}
{% set patchwiseAdjust   = kernel.get("adjust_solution","pointwise")     =="patchwise"   %}
{% set useFlux           = "flux" in kernel["terms"]               %}
{% set useSource         = "source" in kernel["terms"]             %}
{% set useNCP            = "ncp" in kernel["terms"]                %}
{% set usePointSources   = "pointsources" in kernel["terms"]       %}
{% set useMaterialParam  = "materialparameters" in kernel["terms"] %}
// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include "exahype/parser/Parser.h"
#include "exahype/solvers/FiniteVolumesSolver.h"
{{ProfilerInclude}}

namespace {{Project}}{
  class {{Solver}};
}

class {{Project}}::{{Solver}} : public exahype::solvers::FiniteVolumesSolver {
  public:
    {{Solver}}(int cellsPerCoordinateAxis,double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping{{ConstructorSignatureExtension}})
    double stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx) override;
    void adjustSolution(double* luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) override;
    void solutionUpdate(double* luhNew,const double* luh,double** tempStateSizedArrays,double** tempUnknowns,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt,double& maxAdmissibleDt) override;
    void ghostLayerFilling(double* luh,const double* luhNeighbour,const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) override;
    void ghostLayerFillingAtBoundary(double* luh,const double* luhbnd,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) override;
    void boundaryLayerExtraction(double* luhbnd,const double* luh,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) override;
    void boundaryConditions(double* luhbndBnd,const double* const luhbnd,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) override;
};
