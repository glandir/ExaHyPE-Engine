// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include <sstream>
#include <ostream>
#include "exahype/plotters/Plotter.h"
#include "exahype/profilers/ProfilerFactory.h"
#include "exahype/solvers/Solver.h"
#include "exahype/solvers/SolverCoupling.h"
#include "kernels/KernelCalls.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/GaussLobattoQuadrature.h"
#include "kernels/LimiterProjectionMatrices.h"
#include "kernels/DGMatrices.h"
#include "kernels/DGBasisFunctions.h"
#include "buildinfo.h"

{% for subPath in data["includePaths"] %}
#include "{{subPath}}/Quadrature.h"
#include "{{subPath}}/DGMatrices.h"
{% endfor %}

{% for solver in data["solvers"] %}
// includes for solver '{{solver["name"]}}'
#include "{{solver["header_path"]}}"
{% for plotter in solver["plotters"] %}
#include "{{plotter.header_path}}"
{% endfor %}
{% endfor %}


void kernels::registerSolvers(exahype::parser::Parser& parser) {
{% for solver in data["solvers"] %}
{%set solver_loop = loop %}
  // register solver '{{solver["name"]}}' (type: '{{solver["type"]}}')
  {
{%   if solver["type"] == "ADER-DG" %}
    exahype::solvers::RegisteredSolvers.push_back(\n"
      new {{data["project_name"]}}::{{solver["name"]}}("{{solver["name"]}}",
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getMaximumMeshDepth({{loop.index0}}),
          parser.getHaloCells({{loop.index0}}),
          parser.getRegularisedFineGridLevels({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}}),
          0,
          0
      )
    );
{%   elif solver["type"] == "Limiting-ADER-DG" %}
    exahype::solvers::RegisteredSolvers.push_back(\n"
      new {{data["project_name"]}}::{{solver["name"]}}("{{solver["name"]}}",
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getMaximumMeshDepth({{loop.index0}}),
          parser.getHaloCells({{loop.index0}}),
          parser.getRegularisedFineGridLevels({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}}),
          parser.getLimiterHelperLayers({{loop.index0}}),
          parser.getDMPObservables({{loop.index0}}),
          parser.getDMPRelaxationParameter({{loop.index0}}),
          parser.getDMPDifferenceScaling({{loop.index0}}),
          parser.getStepsTillCured({{loop.index0}})
      )
    );
{%   elif solver["type"] == "Finite-Volumes" %}
    exahype::solvers::RegisteredSolvers.push_back(\n"
      new {{data["project_name"]}}::{{solver["name"]}}("{{solver["name"]}}",
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}})
      )
    );
{%   endif %}
    parser.checkSolverConsistency({{loop.index0}});
    
{%   for plotter in solver["plotters"] %}
    // register plotter '{{plotter["name"]}}'
{%     if plotter["type_as_str"] == "user::defined" %}
    exahype::plotters::RegisteredPlotters.push_back( 
      new exahype::plotters::Plotter({{solver_loop.index0}},{{loop.index0}},parser, 
        new {{data["project_name"]}}::{{plotter["name"]}}()
      )
    );
{%     else %}
    exahype::plotters::RegisteredPlotters.push_back( 
      new exahype::plotters::Plotter({{solver_loop.index0}},{{loop.index0}},parser, new {{data["project_name"]}}::{{plotter["name"]}}(
          *static_cast<{{data["project_name"]}}::{{solver["name"]}}*>(exahype::solvers::RegisteredSolvers[{{solver_loop.index0}}])) 
      )
    );
{%     endif %}
{%   endfor %}
  }
{% endfor %}
}
