// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include <sstream>
#include <ostream>
#include <memory>
#include <array>
#include <unistd.h> // POSIX pipes
#include <stdio.h>

#include "exahype/plotters/Plotter.h"
#include "exahype/profilers/ProfilerFactory.h"
#include "exahype/solvers/Solver.h"
#include "exahype/solvers/SolverCoupling.h"
#include "kernels/KernelCalls.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/GaussLobattoQuadrature.h"
#include "kernels/LimiterProjectionMatrices.h"
#include "kernels/DGMatrices.h"
#include "kernels/DGBasisFunctions.h"
#include "buildinfo.h"

{% for codegenContext in codegeneratorContextsList %}
#include "{{codegenContext.pathToOptKernel}}/Quadrature.h"
#include "{{codegenContext.pathToOptKernel}}/DGMatrices.h"
{% endfor %}

{% for solver in solvers %}
// includes for solver '{{solver.name}}'
#include "{{solver.headerPath}}"
{% for plotter in solver.plotters %}
#include "{{plotter.headerPath}}"
{% endfor %}
{% endfor %}


void kernels::registerSolvers(exahype::parser::Parser& parser) {
{% for solver in solvers %}
{%set solver_loop = loop %}
  // register solver '{{solver.name}}' (type: '{{solver.type}}')
  {
{% if solver.type == "ADER-DG" %}
    exahype::solvers::RegisteredSolvers.push_back(
      new {{project}}::{{solver.name}}(
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getMaximumMeshDepth({{loop.index0}}),
          parser.getHaloCells({{loop.index0}}),
          parser.getRegularisedFineGridLevels({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}}),
          0,
          0
      )
    );
{% elif solver.type == "Limiting-ADER-DG" %}
    exahype::solvers::RegisteredSolvers.push_back(
      new {{project}}::{{solver.name}}(
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getMaximumMeshDepth({{loop.index0}}),
          parser.getHaloCells({{loop.index0}}),
          parser.getRegularisedFineGridLevels({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}}),
          parser.getLimiterHelperLayers({{loop.index0}}),
          parser.getDMPObservables({{loop.index0}}),
          parser.getDMPRelaxationParameter({{loop.index0}}),
          parser.getDMPDifferenceScaling({{loop.index0}}),
          parser.getStepsTillCured({{loop.index0}})
      )
    );
{% elif solver.type == "Finite-Volumes" %}
    exahype::solvers::RegisteredSolvers.push_back(
      new {{project}}::{{solver.name}}(
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}})
      )
    );
{% endif %}
    parser.checkSolverConsistency({{loop.index0}});
    
{% for plotter in solver.plotters %}
    // register plotter '{{plotter.name}}'
{% if plotter.type_as_str == "user::defined" %}
    exahype::plotters::RegisteredPlotters.push_back( 
      new exahype::plotters::Plotter({{solver_loop.index0}},{{loop.index0}},parser, 
        new {{project}}::{{plotter.name}}()
      )
    );
{% else %}
    exahype::plotters::RegisteredPlotters.push_back( 
      new exahype::plotters::Plotter({{solver_loop.index0}},{{loop.index0}},parser, new {{project}}::{{plotter.name}}(
          *static_cast<{{project}}::{{solver.name}}*>(exahype::solvers::RegisteredSolvers[{{solver_loop.index0}}])) 
      )
    );
{% endif %}
{% endfor %}
  }
{% endfor %}
  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::initGaussLegendreNodesAndWeights(orders);
  kernels::initGaussLobattoNodesAndWeights(orders);
  kernels::initLimiterProjectionMatrices(orders);
  kernels::initDGMatrices(orders);
  kernels::initBasisFunctions(orders);
{% for codegenContext in codegeneratorContextsList %}
  {{codegenContext.namespace}}::initQuadratureNodesAndWeights(orders);
  {{codegenContext.namespace}}::initDGMatrices();
{% endfor %}
}

void kernels::toString(std::ostream& ostream) {
  /* Generated solver registration code by the toolkit */
  ostream << "inputFileName:  {{specfileName}}\n";
  ostream << "projectName:    {{project}}\n";
{% for solver in solvers %}
  ostream << "Solver[{{loop.index0}}].type:             {{solver.type}}\n";
  ostream << "Solver[{{loop.index0}}].class:            {{solver.class}}\n";
{%   if solver.type=="Limiting-ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].class[ADERDG]:    {{solver.class}}_ADERDG\n";
  ostream << "Solver[{{loop.index0}}].abstract[ADERDG]: ";
  {{solver.class}}_ADERDG::constantsToString(ostream);
  ostream << "Solver[{{loop.index0}}].class[FV]:        {{solver.class}}_FV\n";
  ostream << "Solver[{{loop.index0}}].abstract[FV]: ";
  {{solver.class}}_FV::constantsToString(ostream);
{%   elif solver["type"]=="ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].abstract: ";
  {{solver.class}}::constantsToString(ostream);
{%   elif solver.type=="Finite-Volumes" %}
  ostream << "Solver[{{loop.index0}}].abstract: ";
  {{solver.class}}::constantsToString(ostream);
{%   endif %}
  ostream << "Solver[{{loop.index0}}].variables:           [ {{solver.variables_as_str}} ]\n";
  ostream << "Solver[{{loop.index0}}].material_parameters: [ {{solver.material_parameters_as_str}} ]\n";
  ostream << "Solver[{{loop.index0}}].global_observables:  [ {{solver.global_observables_as_str}} ]\n";
{# /* //TODO JMG
{%   if solver.type=="Limiting-ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].limiter:      [\n{% for item in solver["limiter"].items() %}    {{item[0]}} : {{item[1]}}{% if not loop.last %},{% endif %}\n{% endfor %} ]\n";
  ostream << "Solver[{{loop.index0}}].kernelADERDG: [\n{% for item in solver["aderdg_kernel"].items() %}    {{item[0]}} : {{item[1]}}{% if not loop.last %},{% endif %}\n{% endfor %} ]\n";
  ostream << "Solver[{{loop.index0}}].kernelFV:     [\n{% for item in solver["fv_kernel"].items() %}    {{item[0]}} : {{item[1]}}{% if not loop.last %},{% endif %}\n{% endfor %} ]\n";
{%   elif solver["type"]=="ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].kernelADERDG: {{solver["aderdg_kernel"]}}\n";
{%   elif solver["type"]=="Finite-Volumes" %}
  ostream << "Solver[{{loop.index0}}].kernelFV: {{solver["fv_kernel"]}}\n";
{%   endif %}
*/ #}
{%   set solver_loop=loop %}
{%   for plotter in solver.plotters %}
  ostream << "Solver[{{solver_loop.index0}}].Plotter[{{loop.index0}}]: {{project}}::{{plotter.name}}(variables={{plotter.variables_as_str}})\n";
{%   endfor %}
{% endfor %}
 
// TODO not used yet
//  ostream << "\n";
//  ostream << "Kernel[0].hasConstants: true\n";
//  ostream << "Kernel[0].Plotter[0]: Euler::ErrorPlotter(variables=15)\n";
}

void kernels::finalise() {
  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::freeGaussLegendreNodesAndWeights(orders);
  kernels::freeGaussLobattoNodesAndWeights(orders);
  kernels::freeLimiterProjectionMatrices(orders);
  kernels::freeDGMatrices(orders);
  kernels::freeBasisFunctions(orders);
{% for codegenContext in codegeneratorContextsList %}
  {{codegenContext.namespace}}::freeQuadratureNodesAndWeights(orders);
  {{codegenContext.namespace}}::freeDGMatrices();
{% endfor %}

  for (auto solver : exahype::solvers::RegisteredSolvers) {
    delete solver;
  }
  exahype::solvers::RegisteredSolvers.clear();

  for (auto plotter : exahype::plotters::RegisteredPlotters) {
    delete plotter;
  }
  exahype::plotters::RegisteredPlotters.clear();
  for (auto coupling : exahype::solvers::RegisteredSolverCouplings) {
    delete coupling;
  }
  exahype::solvers::RegisteredSolverCouplings.clear();
}

std::string kernels::readSpecificationFileToJSON(const std::string& filename) {
  // Call the ExaHyPE Python Toolkit and grab stdout. stderr instead passes.
  // Things where this could be improved:
  //  - Harmonize logging of subcommand into Tarch's logging
  //  - Pipe the specfile into the external parser instead of passing a filename
  
  static tarch::logging::Log _log("kernels");
  constexpr int buffer_size = 512;
  
  // These variables are generated by the toolkit itself and should make it
  // safe to call a similar python environment as the toolkit has found it from
  // anywhere on the same computer/cluster. If you encounter problems, you
  // can change them here (note that KernelCalls.cpp is overwritten by every
  // toolkit run.
  std::string command = "{{externalParserCommand}} " + filename;
  
  logInfo("readSpecificationFileToJSON()", "Invoking external command " << command);

  std::array<char, buffer_size> buffer;
  std::string stdout;
  std::shared_ptr<FILE> pipe(popen(command.c_str(), "r"), pclose);
  if (!pipe) throw std::runtime_error(std::string("Could not call external command with popen(") + command + ").");

  while (!feof(pipe.get()))
    if (fgets(buffer.data(), buffer_size, pipe.get()) != nullptr)
        stdout += buffer.data();

  return stdout;
}

const char* kernels::compiledSpecfile() {
  /* This is a hexdump of the specfile which was used to create this registration file.     */
  /* Run ExaHyPE with --help to learn how to view it's contents and/or run ExaHyPE with it. */
  static const char ret[] =
  {
    {{ specFileAsHex|wordwrap|indent }}
  };
  return ret;
}
