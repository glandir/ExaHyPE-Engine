// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include <sstream>
#include <ostream>
#include "exahype/plotters/Plotter.h"
#include "exahype/profilers/ProfilerFactory.h"
#include "exahype/solvers/Solver.h"
#include "exahype/solvers/SolverCoupling.h"
#include "kernels/KernelCalls.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/GaussLobattoQuadrature.h"
#include "kernels/LimiterProjectionMatrices.h"
#include "kernels/DGMatrices.h"
#include "kernels/DGBasisFunctions.h"
#include "buildinfo.h"

{% for subPath in data["includePaths"] %}
#include "{{subPath}}/Quadrature.h"
#include "{{subPath}}/DGMatrices.h"
{% endfor %}

{% for solver in data["solvers"] %}
// includes for solver '{{solver["name"]}}'
#include "{{solver["header_path"]}}"
{% for plotter in solver["plotters"] %}
#include "{{plotter.header_path}}"
{% endfor %}
{% endfor %}


void kernels::registerSolvers(exahype::parser::Parser& parser) {
{% for solver in data["solvers"] %}
{%set solver_class = loop %}
  // register solver '{{solver["name"]}}' (type: '{{solver["type"]}}')
  {
{%   if solver["type"] == "ADER-DG" %}
    exahype::solvers::RegisteredSolvers.push_back(\n"
      new {{data["project_name"]}}::{{solver["name"]}}("{{solver["name"]}}",
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getMaximumMeshDepth({{loop.index0}}),
          parser.getHaloCells({{loop.index0}}),
          parser.getRegularisedFineGridLevels({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}}),
          0,
          0
      )
    );
{%   elif solver["type"] == "Limiting-ADER-DG" %}
    exahype::solvers::RegisteredSolvers.push_back(\n"
      new {{data["project_name"]}}::{{solver["name"]}}("{{solver["name"]}}",
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getMaximumMeshDepth({{loop.index0}}),
          parser.getHaloCells({{loop.index0}}),
          parser.getRegularisedFineGridLevels({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}}),
          parser.getLimiterHelperLayers({{loop.index0}}),
          parser.getDMPObservables({{loop.index0}}),
          parser.getDMPRelaxationParameter({{loop.index0}}),
          parser.getDMPDifferenceScaling({{loop.index0}}),
          parser.getStepsTillCured({{loop.index0}})
      )
    );
{%   elif solver["type"] == "Finite-Volumes" %}
    exahype::solvers::RegisteredSolvers.push_back(\n"
      new {{data["project_name"]}}::{{solver["name"]}}("{{solver["name"]}}",
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}})
      )
    );
{%   endif %}
    parser.checkSolverConsistency({{loop.index0}});
    
{%   for plotter in solver["plotters"] %}
    // register plotter '{{plotter["name"]}}'
{%     if plotter["type_as_str"] == "user::defined" %}
    exahype::plotters::RegisteredPlotters.push_back( 
      new exahype::plotters::Plotter({{solver_class.index0}},{{loop.index0}},parser, 
        new {{data["project_name"]}}::{{plotter["name"]}}()
      )
    );
{%     else %}
    exahype::plotters::RegisteredPlotters.push_back( 
      new exahype::plotters::Plotter({{solver_class.index0}},{{loop.index0}},parser, new {{data["project_name"]}}::{{plotter["name"]}}(
          *static_cast<{{data["project_name"]}}::{{solver["name"]}}*>(exahype::solvers::RegisteredSolvers[{{solver_class.index0}}])) 
      )
    );
{%     endif %}
{%   endfor %}
  }
{% endfor %}
  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::initGaussLegendreNodesAndWeights(orders);
  kernels::initGaussLobattoNodesAndWeights(orders);
  kernels::initLimiterProjectionMatrices(orders);
  kernels::initDGMatrices(orders);
  kernels::initBasisFunctions(orders);
}

void kernels::toString(std::ostream& ostream) {
  /* Generated solver registration code by the toolkit */
  ostream << "inputFileName:  {{data["spec_file"]}}\n";
  ostream << "projectName:    {{data["project_name"]}}\n";
{% for solver in data["solvers"] %}
{%   set solver_class=data["project_name"]+"::"+solver["name"] %}
  ostream << "Solver[{{loop.index0}}].type:             {{solver["type"]}}\n";
  ostream << "Solver[{{loop.index0}}].class:            {{solver_class}}\n";
{%   if solver["type"]=="Limiting-ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].class[ADERDG]:    {{solver_class}}_ADERDG\n";
  ostream << "Solver[{{loop.index0}}].abstract[ADERDG]: ";
  {{solver_class}}_ADERDG::constantsToString(ostream);
  ostream << "Solver[{{loop.index0}}].class[FV]:        {{solver_class}}_FV\n";
  ostream << "Solver[{{loop.index0}}].abstract[FV]: ";
  {{solver_class}}_FV::constantsToString(ostream);
{%   elif solver["type"]=="ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].abstract: ";
  {{solver_class}}::constantsToString(ostream);
{%   elif solver["type"]=="Finite-Volumes" %}
  ostream << "Solver[{{loop.index0}}].abstract: ";
  {{solver_class}}::constantsToString(ostream);
{%   endif %}
  ostream << "Solver[{{loop.index0}}].variables:           [ {{solver["variables_as_str"]}} ]\n";
  ostream << "Solver[{{loop.index0}}].material_parameters: [ {{solver["material_parameters_as_str"]}} ]\n";
  ostream << "Solver[{{loop.index0}}].global_observables:  [ {{solver["global_observables_as_str"]}} ]\n";
{%   if solver["type"]=="Limiting-ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].limiter:      [\n{% for item in solver["limiter"].items() %}    {{item[0]}} : {{item[1]}}{% if not loop.last %},{% endif %}\n{% endfor %} ]\n";
  ostream << "Solver[{{loop.index0}}].kernelADERDG: [\n{% for item in solver["aderdg_kernel"].items() %}    {{item[0]}} : {{item[1]}}{% if not loop.last %},{% endif %}\n{% endfor %} ]\n";
  ostream << "Solver[{{loop.index0}}].kernelFV:     [\n{% for item in solver["fv_kernel"].items() %}    {{item[0]}} : {{item[1]}}{% if not loop.last %},{% endif %}\n{% endfor %} ]\n";
{%   elif solver["type"]=="ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].kernelADERDG: {{solver["aderdg_kernel"]}}\n";
{%   elif solver["type"]=="Finite-Volumes" %}
  ostream << "Solver[{{loop.index0}}].kernelFV: {{solver["fv_kernel"]}}\n";
{%   endif %}
{%   set solver_loop=loop %}
{%   for plotter in solver["plotters"] %}
  ostream << "Solver[{{solver_loop.index0}}].Plotter[{{loop.index0}}]: {{data["project_name"]}}::{{plotter["name"]}}(variables={{plotter["variables_as_str"]}})\n";
{%   endfor %}
{% endfor %}
 
// TODO not used yet
//  ostream << "\n";
//  ostream << "Kernel[0].hasConstants: true\n";
//  ostream << "Kernel[0].Plotter[0]: Euler::ErrorPlotter(variables=15)\n";
}

void kernels::finalise() {
  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::freeGaussLegendreNodesAndWeights(orders);
  kernels::freeGaussLobattoNodesAndWeights(orders);
  kernels::freeLimiterProjectionMatrices(orders);
  kernels::freeDGMatrices(orders);
  kernels::freeBasisFunctions(orders);

  for (auto solver : exahype::solvers::RegisteredSolvers) {
    delete solver;
  }
  exahype::solvers::RegisteredSolvers.clear();

  for (auto plotter : exahype::plotters::RegisteredPlotters) {
    delete plotter;
  }
  exahype::plotters::RegisteredPlotters.clear();
  for (auto coupling : exahype::solvers::RegisteredSolverCouplings) {
    delete coupling;
  }
  exahype::solvers::RegisteredSolverCouplings.clear();
}

const char* kernels::compiledSpecfile() {
  /* This is a hexdump of the specfile which was used to create this registration file.     */
  /* Run ExaHyPE with --help to learn how to view it's contents and/or run ExaHyPE with it. */
  static const char ret[] =
  {
    {{data["spec_file_as_hex"]}}// TODO(Sven)
  }
}
