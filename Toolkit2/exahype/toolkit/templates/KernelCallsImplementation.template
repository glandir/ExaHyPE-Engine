// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include <sstream>
#include <ostream>
#include "exahype/plotters/Plotter.h"
#include "exahype/profilers/ProfilerFactory.h"
#include "exahype/solvers/Solver.h"
#include "exahype/solvers/SolverCoupling.h"
#include "kernels/KernelCalls.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/GaussLobattoQuadrature.h"
#include "kernels/LimiterProjectionMatrices.h"
#include "kernels/DGMatrices.h"
#include "kernels/DGBasisFunctions.h"
#include "buildinfo.h"

{% for subPath in data["includePaths"] %}
#include "{{subPath}}/Quadrature.h"
#include "{{subPath}}/DGMatrices.h"
{% endfor %}

{% for solver in data["solvers"] %}
// includes for solver '{{solver["name"]}}'
#include "{{solver["header_path"]}}"
{% for plotter in solver["plotters"] %}
#include "{{plotter.header_path}}"
{% endfor %}
{% endfor %}


void kernels::registerSolvers(exahype::parser::Parser& parser) {
{% for solver in data["solvers"] %}
{%set solver_loop = loop %}
  // register solver '{{solver["name"]}}' (type: '{{solver["type"]}}')
  {
{%   if solver["type"] == "ADER-DG" %}
    exahype::solvers::RegisteredSolvers.push_back(\n"
      new {{data["project_name"]}}::{{solver["name"]}}("{{solver["name"]}}",
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getMaximumMeshDepth({{loop.index0}}),
          parser.getHaloCells({{loop.index0}}),
          parser.getRegularisedFineGridLevels({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}}),
          0,
          0
      )
    );
{%   elif solver["type"] == "Limiting-ADER-DG" %}
    exahype::solvers::RegisteredSolvers.push_back(\n"
      new {{data["project_name"]}}::{{solver["name"]}}("{{solver["name"]}}",
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getMaximumMeshDepth({{loop.index0}}),
          parser.getHaloCells({{loop.index0}}),
          parser.getRegularisedFineGridLevels({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}}),
          parser.getLimiterHelperLayers({{loop.index0}}),
          parser.getDMPObservables({{loop.index0}}),
          parser.getDMPRelaxationParameter({{loop.index0}}),
          parser.getDMPDifferenceScaling({{loop.index0}}),
          parser.getStepsTillCured({{loop.index0}})
      )
    );
{%   elif solver["type"] == "Finite-Volumes" %}
    exahype::solvers::RegisteredSolvers.push_back(\n"
      new {{data["project_name"]}}::{{solver["name"]}}("{{solver["name"]}}",
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}})
      )
    );
{%   endif %}
    parser.checkSolverConsistency({{loop.index0}});
    
{%   for plotter in solver["plotters"] %}
    // register plotter '{{plotter["name"]}}'
{%     if plotter["type_as_str"] == "user::defined" %}
    exahype::plotters::RegisteredPlotters.push_back( 
      new exahype::plotters::Plotter({{solver_loop.index0}},{{loop.index0}},parser, 
        new {{data["project_name"]}}::{{plotter["name"]}}()
      )
    );
{%     else %}
    exahype::plotters::RegisteredPlotters.push_back( 
      new exahype::plotters::Plotter({{solver_loop.index0}},{{loop.index0}},parser, new {{data["project_name"]}}::{{plotter["name"]}}(
          *static_cast<{{data["project_name"]}}::{{solver["name"]}}*>(exahype::solvers::RegisteredSolvers[{{solver_loop.index0}}])) 
      )
    );
{%     endif %}
{%   endfor %}
  }
{% endfor %}
  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::initGaussLegendreNodesAndWeights(orders);
  kernels::initGaussLobattoNodesAndWeights(orders);
  kernels::initLimiterProjectionMatrices(orders);
  kernels::initDGMatrices(orders);
  kernels::initBasisFunctions(orders);
}

void kernels::toString(std::ostream& ostream) {
  /* Generated solver registration code by the toolkit */
    ostream << "inputFileName: {{data["spec_file"]}}\n";
    ostream << "projectName: {{data["project_name"]}}\n";
{% for solver in data["solvers"] %}
{%   set solverClass=data["project_name"]::solver["name"] %}
  ostream << "Kernel[{{loop.index0}}].type: {{solver["type"]}}\n";
  ostream << "Kernel[{{loop.index0}}].class:         {{solverClass}}\n";
  //
  ostream << "Kernel[{{loop.index0}}].class[ADERDG]: {{solverClass}}_ADERDG\n";
  ostream << "Kernel[0].abstract[ADERDG]: ";
  Euler::AbstractEulerSolver_ADERDG::constantsToString(ostream);
  ostream << "Kernel[{{loop.index0}}].class[FV]:     {{solverClass}}_FV\n";
  ostream << "Kernel[{{loop.index0}}].abstract[FV]: ";
  Euler::AbstractEulerSolver_FV::constantsToString(ostream);
{% endfor %}
  ostream << "Kernel[0].registration: LimitingAderdgSolver\n";
  ostream << "Kernel[0].type[FV]: Euler::EulerSolver_FV\n";
  ostream << "Kernel[0].type[ADERDG]: Euler::EulerSolver_ADERDG\n";
  ostream << "Kernel[0].abstract[FV]: ";
  ostream << "\n";
 
  ostream << "\n";
  ostream << "Kernel[0].hasConstants: true\n";
  ostream << "Kernel[0].variables: rho 1 j 3 E 1 \n";
  ostream << "Kernel[0].kernelADERDG: (type: [nonlinear ], terms: [flux ], opt: [generic ])\n";
  ostream << "Kernel[0].kernelLimiter: (type: [musclhancock ], terms: [flux ], opt: [generic ])\n";
  ostream << "Kernel[0].Plotter[0]: Euler::ErrorPlotter(variables=15)\n";
}

void kernels::finalise() {
  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::freeGaussLegendreNodesAndWeights(orders);
  kernels::freeGaussLobattoNodesAndWeights(orders);
  kernels::freeLimiterProjectionMatrices(orders);
  kernels::freeDGMatrices(orders);
  kernels::freeBasisFunctions(orders);

  for (auto solver : exahype::solvers::RegisteredSolvers) {
    delete solver;
  }
  exahype::solvers::RegisteredSolvers.clear();

  for (auto plotter : exahype::plotters::RegisteredPlotters) {
    delete plotter;
  }
  exahype::plotters::RegisteredPlotters.clear();
  for (auto coupling : exahype::solvers::RegisteredSolverCouplings) {
    delete coupling;
  }
  exahype::solvers::RegisteredSolverCouplings.clear();
}

const char* kernels::compiledSpecfile() {
  /* This is a hexdump of the specfile which was used to create this registration file.     */
  /* Run ExaHyPE with --help to learn how to view it's contents and/or run ExaHyPE with it. */
  static const char ret[] =
  {
    '0x2F'// TODO(Sven)
  }
}
