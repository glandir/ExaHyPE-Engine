///**
// * This file is part of the ExaHyPE project.
// * Copyright (c) 2016  http://exahype.eu
// * All rights reserved.
// *
// * The project has received funding from the European Union's Horizon
// * 2020 research and innovation programme under grant agreement
// * No 671698. For copyrights and licensing, please consult the webpage.
// *
// * Released under the BSD 3 Open Source License.
// * For the full license text, see LICENSE.txt
// **/
//
//#include <cassert>
//#include <cmath>
//#include <limits>
//#include <utility>
//#include <vector>
//#include <algorithm>
//
//#include "tarch/la/Vector.h"
//#include "kernels/KernelUtils.h"
//
//#if DIMENSIONS == 2
//
//namespace kernels {
//namespace finitevolumes {
//namespace godunov {
//namespace c {
//
///**
// * A simple Rusanov flux considering pointwise
// * left and right values.
// */
//template <typename SolverType>
//double riemannSolver(
//    SolverType& solver,
//    double* fL, double *fR, const double* qL, const double* qR, int normalNonZero,
//    double** tempStateSizedVectors) { // TODO(Dominic): I need four of those
//  constexpr int numberOfVariables = SolverType::NumberOfVariables;
//  constexpr int numberOfParameters = SolverType::NumberOfParameters;
//
//  //double* sL = tempStateSizedVectors[0];
//  //double* sR = tempStateSizedVectors[1];
//  double sL[numberOfVariables + numberOfParameters];
//  double sR[numberOfVariables + numberOfParameters];
//
//  solver.eigenvalues(qL, normalNonZero, sL);
//  solver.eigenvalues(qR, normalNonZero, sR);
//
//  double s_max = -1.0;
//  for (int i = 0; i < numberOfVariables; i++) {
//    const double abs_sL_i = std::abs(sL[i]);
//    s_max = std::max( abs_sL_i, s_max );
//  }
//  for (int i = 0; i < numberOfVariables; i++) {
//    const double abs_sR_i = std::abs(sR[i]);
//    s_max = std::max( abs_sR_i, s_max );
//  }
//
//  double FL2a[numberOfVariables + numberOfParameters];
//  double FL2b[numberOfVariables + numberOfParameters];
//  double FR2a[numberOfVariables + numberOfParameters];
//  double FR2b[numberOfVariables + numberOfParameters];
//
//  //double* FL2[2] = {tempStateSizedVectors[0],tempStateSizedVectors[1]}; // dim a numberOfVariables
//  //double* FR2[2] = {tempStateSizedVectors[2],tempStateSizedVectors[3]}; // dim a numberOfVariables
//  double* FL2[2] = {FL2a,FL2b}; // dim a numberOfVariables
//  double* FR2[2] = {FR2a,FR2b}; // dim a numberOfVariables
//
//  solver.flux(qL, FL2);
//  solver.flux(qR, FR2);
//
//  double Qavg[numberOfVariables+numberOfParameters];
//  for(int k=0; k < numberOfVariables+numberOfParameters; k++) {
//     Qavg[k] = (qL[k] + qR[k]) / 2;
//  }
//
//  for (int i = 0; i < numberOfVariables + numberOfParameters; i++) {
//    fL[i] = 0.5 * (FL2[normalNonZero][i] + FR2[normalNonZero][i]) +
//              0.5 * s_max * (qL[i] - qR[i]);
//    fR[i] = 0.5 * (FL2[normalNonZero][i] + FR2[normalNonZero][i]) +
//              0.5 * s_max * (qL[i] - qR[i]);
//  }
//
//  if (solver.useNonConservativeProduct()) {
//    double Bn[ (numberOfVariables + numberOfParameters) * (numberOfVariables + numberOfParameters)];
//    double ncp[numberOfVariables + numberOfParameters];
//    idx2 idx_Bn(numberOfVariables + numberOfParameters, numberOfVariables + numberOfParameters);
//    solver.coefficientMatrix(Qavg, normalNonZero, Bn);
//
//    for(int l=0; l < numberOfVariables + numberOfParameters; l++) {
//      ncp[l] = 0;
//      for(int m=0; m < numberOfVariables+ numberOfParameters; m++) {
//        ncp[l] += Bn[idx_Bn(m, l)] * (qR[m] - qL[m]);
//      }
//    }
//
//    for (int i = 0; i < numberOfVariables + numberOfParameters; i++) {
//      fR[i] = fR[i] - 0.5 * ncp[i];
//      fL[i] = fL[i] + 0.5 * ncp[i];
//    }
//  }
//
//  return s_max;
//}
//
///**
// * Extract the boundary layer of the patch \p luh and
// * store it in the array \p luhbnd.
// *
// * \param[in] neighbourPosition A 2-d array which must be one of the
// * pairs (-1,0), (+1,0), (0,-1), or (0,+1).
// */
//template <typename SolverType>
//void boundaryLayerExtraction(
//    SolverType& solver,
//    double* luhbnd,const double* luh,
//    const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
//  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
//  constexpr int numberOfParameters = SolverType::NumberOfParameters;
//  constexpr int patchSize          = SolverType::PatchSize;
//  // TODO(Dominic): constexpr int ghostLayerWidth = SolverType::GhostLayerWidth;
//
//  constexpr int numberOfData = numberOfVariables+numberOfParameters;
//
//  // 1D patch values:
//  // |G|G|U0|U1|..|UN|G|G|,
//  // G: ghost value, Ui: local solution value
//  constexpr int ghostLayerWidth = 2;
//  constexpr int patchBegin      = ghostLayerWidth;
//  constexpr int patchEnd        = patchBegin+patchSize;
//  idx3 idx(patchSize+2*ghostLayerWidth, // y
//           patchSize+2*ghostLayerWidth, // x
//           numberOfData);
//
//  idx3 idx_bnd_x(patchSize,ghostLayerWidth,numberOfData); // x,x; x,x; x,x; ... x,x;
//  idx3 idx_bnd_y(ghostLayerWidth,patchSize,numberOfData); // x,x,x,x,x,...,x; x,x,x,x,x,...,x;
//
//  // TODO: Depending on the memory layout, we can remove the loops
//  // and use larger strides for one of the coordinate directions.
//
//  if (boundaryPosition[0] == -1) {
//    // assertion: boundaryPosition[1] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//      // first layer
//      std::copy_n(
//          luh+idx(i,patchBegin+k,0),
//          numberOfData,
//          luhbnd+idx_bnd_x(i-patchBegin,k,0));
//      }
//    }
//  }
//  if (boundaryPosition[0] == +1) {
//    // assertion: boundaryPosition[1] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//        // first layer
//        std::copy_n(
//            luh+idx(i,patchEnd-ghostLayerWidth+k,0),
//            numberOfData,
//            luhbnd+idx_bnd_x(i-patchBegin,k,0));
//      }
//    }
//  }
//
//  if (boundaryPosition[1] == -1) {
//    // assertion: boundaryPosition[0] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//        std::copy_n(
//            luh+idx(patchBegin+k,i,0),
//            numberOfData,
//            luhbnd+idx_bnd_y(k,i-patchBegin,0));
//      }
//    }
//  }
//  if (boundaryPosition[1] == +1) {
//    // assertion: boundaryPosition[0] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//        std::copy_n(
//            luh+idx(patchEnd-ghostLayerWidth+k,i,0),
//            numberOfData,
//            luhbnd+idx_bnd_y(k,i-patchBegin,0));
//      }
//    }
//  }
//}
//
///**
// * Fill a part of the ghost layer of a patch with
// * values from an array. This function is used
// * for the MPI and boundary treatment.
// *
// * \param[in] boundaryPosition A 2-d array which must be one of the
// * pairs (-1,0), (+1,0), (0,-1), or (0,+1).
// *
// * \see boundaryLayerExtraction
// */
//template <typename SolverType>
//void ghostLayerFillingAtBoundary(
//    SolverType& solver,
//    double* luh,const double* luhbnd,
//    const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
//  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
//  constexpr int numberOfParameters = SolverType::NumberOfParameters;
//  constexpr int patchSize          = SolverType::PatchSize;
//
//  constexpr int numberOfData = numberOfVariables+numberOfParameters;
//
//  constexpr int ghostLayerWidth = 2; // TODO(Dominic): Make this a solver constexpr and make ghost layer stuff FV solver generic
//  constexpr int patchBegin      = ghostLayerWidth;
//  constexpr int patchEnd        = patchBegin+patchSize;
//  idx3 idx(patchSize+2*ghostLayerWidth, // y
//      patchSize+2*ghostLayerWidth, // x
//      numberOfData);
//
//  idx3 idx_bnd_x(patchSize,ghostLayerWidth,numberOfData); // x,x; x,x; x,x; ... x,x;
//  idx3 idx_bnd_y(ghostLayerWidth,patchSize,numberOfData); // x,x,x,x,x,...,x; x,x,x,x,x,...,x;
//
//  // TODO: Depending on the memory layout, we can remove the loop,
//  // and use larger strides for one of the coordinate directions.
//
//  if (boundaryPosition[0] == -1) {
//    // assertion: boundaryPosition[1] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//      std::copy_n(
//          luhbnd+idx_bnd_x(i-patchBegin,k,0), // (iy,ix,ivar)
//          numberOfData,
//          luh+idx(i,k,0));
//    }
//  }
//  if (boundaryPosition[0] == +1) {
//    // assertion: boundaryPosition[1] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//        std::copy_n(
//          luhbnd+idx_bnd_x(i-patchBegin,k,0),
//          numberOfData,
//          luh+idx(i,patchEnd+k,0));
//      }
//    }
//  }
//
//  if (boundaryPosition[1] == -1) {
//    // assertion: boundaryPosition[0] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//        std::copy_n(
//            luhbnd+idx_bnd_y(k,i-patchBegin,0),
//            numberOfData,
//            luh+idx(k,i,0));
//      }
//    }
//  }
//  if (boundaryPosition[1] == +1) {
//    // assertion: boundaryPosition[0] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//        std::copy_n(
//            luhbnd+idx_bnd_y(k,i-patchBegin,0),
//            numberOfData,
//            luh+idx(patchEnd+k,i,0));
//      }
//    }
//  }
//}
//
//template <typename SolverType>
//void ghostLayerFilling(
//      SolverType& solver,
//      double* luh,const double* luhNeighbour,
//      const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) {
//  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
//  constexpr int numberOfParameters = SolverType::NumberOfParameters;
//  constexpr int patchSize          = SolverType::PatchSize;
//
//  constexpr int numberOfData = numberOfVariables+numberOfParameters;
//
//  constexpr int ghostLayerWidth = 2;
//  constexpr int patchBegin      = ghostLayerWidth;
//  constexpr int patchEnd        = patchBegin+patchSize; // exclusive
//  idx3 idx(patchSize+2*ghostLayerWidth, // y
//      patchSize+2*ghostLayerWidth, // x
//      numberOfData);
//
//  // TODO: Depending on the memory layout, we can remove the loop,
//  // and use larger strides for one of the coordinate directions.
//
//  if (neighbourPosition[0] == -1) {
//    // assertion: neighbourPosition[1] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//        std::copy_n(
//            luhNeighbour+idx(i,patchEnd-ghostLayerWidth+k,0),
//            numberOfData,
//            luh+idx(i,k,0));
//      }
//    }
//  }
//  if (neighbourPosition[0] == +1) {
//    // assertion: neighbourPosition[1] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//        std::copy_n(
//            luhNeighbour+idx(i,patchBegin+k,0),
//            numberOfData,
//            luh+idx(i,patchEnd+k,0));
//      }
//    }
//  }
//
//  if (neighbourPosition[1] == -1) {
//    // assertion: neighbourPosition[0] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//        std::copy_n(
//            luhNeighbour+idx(patchEnd-ghostLayerWidth+k,i,0),
//            numberOfData,
//            luh+idx(k,i,0));
//      }
//    }
//  }
//  if (neighbourPosition[1] == +1) {
//    // assertion: neighbourPosition[0] == 0;
//    for (int i=patchBegin; i<patchEnd; ++i) {
//      for (int k=0; k<ghostLayerWidth; ++k) {
//        std::copy_n(
//            luhNeighbour+idx(patchBegin+k,i,0),
//            numberOfData,
//            luh+idx(patchEnd+k,i,0));
//      }
//    }
//  }
//}
//
//// TODO(Dominic): Work in progress
///**
// * Solves all the Riemann problems that do only require
// * internal data and add the result directly onto the
// * new solution.
// * Finally add the source terms.
// */
//template <typename SolverType>
//double solutionUpdate(
//    SolverType& solver,
//    double* luh_new, const double* luh,
//    double** tempStateSizedVectors,double** tempUnknowns,
//    const tarch::la::Vector<DIMENSIONS, double>& dx,double dt) {
//  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
//  constexpr int numberOfParameters = SolverType::NumberOfParameters;
//  constexpr int patchSize          = SolverType::PatchSize;
//
//  constexpr int numberOfData = numberOfVariables+numberOfParameters;
//
//  constexpr int ghostLayerWidth=2 // TODO
//  constexpr int patchBegin=ghostLayerWidth;
//  constexpr int patchEnd=patchBegin+patchSize;
//
//  constexpr double cflFactor = 0.9;
//
//  const double cellSize[2] = {dx[0]/patchSize, dx[1]/patchSize};
//
//  // 1. Gather data from neighbouring cells; already done.
//
//  // 2. Compute slopes TODO(Dominic): Make sure to only consider parameters in luh
//  idx3 idx_luh(patchSize+2*ghostLayerWidth,patchSize+2*ghostLayerWidth,numberOfData);
//
//  idx3 idx_slope(patchSize+2*ghostLayerWidth,patchSize+2*ghostLayerWidth,numberOfVariables);
//  constexpr int variablesPerPatch = (patchSize+2*ghostLayerWidth)*(patchSize+2*ghostLayerWidth)*numberOfVariables;
//  double slopex[variablesPerPatch] = {0.0};
//  double slopey[variablesPerPatch] = {0.0};
//
//  // slopex
//  for (int j = patchBegin; j < patchEnd; j++) {
//    for (int k = patchBegin-1; k < patchEnd; k++) {
//      for (int l = 0; l < numberOfVariables; l++) {
//        slopex[idx_slope(j, k, l)] =
//            minmod(luh[idx(j, k + 1, l)] - luh[idx(j, k, l)],
//                   luh[idx(j, k, l)] - luh[idx(j, k - 1, l)]);
//      }
//    }
//  }
//  // slopey
//  for (int j = patchBegin-1; j < patchEnd; j++) {
//    for (int k = patchBegin; k < patchEnd; k++) {
//      for (int l = 0; l < numberOfVariables; l++) {
//        slopey[idx_slope(j, k, l)] =
//            minmod(luh[idx(j + 1, k, l)] - luh[idx(j, k, l)],
//                   luh[idx(j, k, l)] - luh[idx(j - 1, k, l)]);
//      }
//    }
//  }
//
//
//  // 3.Boundary extrapolation (left and right value per face)
//  idx3 idx_Fx(patchSize, patchSize + 1, numberOfVariables);
//  idx3 idx_Fy(patchSize + 1, patchSize, numberOfVariables);
//
//  double wLx[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};
//  double wRx[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};
//  double wLy[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};
//  double wRy[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};
//
//  // wx
//  for (int j = patchBegin; j < patchEnd; j++) {
//    for (int k = patchBegin; k < patchEnd+1; k++) {
//      for (int l = 0; l < numberOfVariables; l++) {
//        const int J=j-patchBegin;
//        const int K=k-patchBegin;
//
//        wLx[idx_Fx(J, K, l)] =
//            luh[idx_luh(j, k-1, l)] + 0.5 * slopex[idx_slope(j, k-1, l)];
//        wRx[idx_Fx(J, K, l)] =
//            luh[idx_luh(j, k, l)]   - 0.5 * slopex[idx_slope(j, k, l)];
//      }
//    }
//  }
//  // wy
//  for (int j = patchBegin; j < patchEnd+1; j++) {
//    for (int k = patchBegin; k < patchEnd; k++) {
//      for (int l = 0; l < numberOfVariables; l++) {
//        const int J=j-patchBegin;
//        const int K=k-patchBegin;
//
//        wLy[idx_Fy(J, K, l)] =
//            luh[idx_luh(j-1, k, l)] + 0.5 * slopey[idx_slope(j-1, k, l)];
//        wRy[idx_Fy(j, k, l)] =
//            luh[idx_luh(J, K, l)]   - 0.5 * slopey[idx_slope(j, k, l)];
//      }
//    }
//  }
//
//  // 4. Source evaluation, Half time step evolution of extrapolated values
//  // TODO(Dominic): Here is probably something wrong with the source term
//  double flx[numberOfVariables * DIMENSIONS] = {0.0};
//  double F[2] = {flx, flx + numberOfVariables}
//
//  double Qt[numberOfVariables];
//
//  // x-faces
//  for (int j = 0; j < patchSize; j++) {
//    for (int k = 0; k < patchSize+1; k++) {
//      double* Qt = slopety + idx(j, k, 0);
//      // sources
//      solver.algebraicSource(wLx + idx_Fx(j, k, 0), Qt);
//      wLx[idx_Fx(j, k, l)] += 0.5 * dt * Qt[l];
//      solver.algebraicSource(wRx + idx_Fx(j, k, 0), Qt);
//      wRx[idx_Fx(j, k, l)] += 0.5 * dt * Qt[l];
//
//      // fluxes
//      std::fill_n(Qt, numberOfDataPoints, 0.0);
//      solver.flux(wLx + idx_Fx(j, k, 0), F); // FLx
//      for (int l = 0; l < numberOfVariables; l++) {
//        Qt[l] += F[0][l] / cellSize[0];
//      }
//      solver.flux(wRx + idx_Fx(j, k, 0), F); // FRx
//      for (int l = 0; l < numberOfVariables; l++) {
//        Qt[l] -= F[0][l] / cellSize[0];
//      }
//
//      // evolve
//      for (int l = 0; l < numberOfVariables; l++) {
//        wLx[idx_Fx(j, k, l)] += 0.5 * dt * Qt[l];
//        wRx[idx_Fx(j, k, l)] += 0.5 * dt * Qt[l];
//      }
//    }
//  }
//
//  // y-faces
//  for (int j = 0; j < patchSize+1; j++) {
//    for (int k = 0; k < patchSize; k++) {
//      double* Qt = slopety + idx(j, k, 0);
//      // sources
//      solver.algebraicSource(wLx + idx_Fy(j, k, 0), Qt);
//      wLy[idx_Fy(j, k, l)] += 0.5 * dt * Qt[l];
//      solver.algebraicSource(wRx + idx_Fy(j, k, 0), Qt);
//      wRy[idx_Fy(j, k, l)] += 0.5 * dt * Qt[l];
//
//      // fluxes
//      std::fill_n(Qt, numberOfDataPoints, 0.0);
//      solver.flux(wLy + idx_Fy(j, k, 0), F); // FLy
//      for (int l = 0; l < numberOfVariables; l++) {
//        Qt[l] += F[1][l] / cellSize[1];
//      }
//
//      solver.flux(wRy + idx_F(j, k, 0), F); // FRy
//      for (int l = 0; l < numberOfVariables; l++) {
//        Qt[l] -= F[1][l] / cellSize[1];
//      }
//
//      // evolve
//      for (int l = 0; l < numberOfVariables; l++) {
//        wLy[idx_Fy(j, k, l)] += 0.5 * dt * Qt[l];
//        wRy[idx_Fy(j, k, l)] += 0.5 * dt * Qt[l];
//      }
//    }
//  }
//
//  // 4. Solve Riemann problems
//  double FLx[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};
//  double FRy[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};
//  double FLx[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};
//  double FRy[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};
//
//  double dt_max_allowed = std::numeric_limits<double>::max();
//
//  // x edges
//  for (int j = 0; j < patchSize; j++) {
//    for (int k = 0; k < patchSize+1; k++) {
//      double s_max_x =
//          riemannSolver<PDEEigenvalues, PDEFlux>(
//          FLx + idx_Fx(j, k, 0),
//          FRx + idx_Fx(j, k, 0),
//          wLx + idx_Fx(j, k, 0),
//          wRx + idx_Fx(j, k, 0),
//          numberOfVariables, 0);
//      // TODO(guera): Improve. I'm quite sure this is not the correct/best
//      // formula.
//      dt_max_allowed = std::min(
//          dt_max_allowed, cflFactor / DIMENSIONS * cellSize[0] / s_max_x);
//    }
//  }
//
//  // y edges
//  for (int j = 0; j < patchSize+1; j++) {
//    for (int k = 0; k < patchSize; k++) {
//      double s_max_y = riemannSolver<PDEEigenvalues, PDEFlux>(
//          FLy + idx_Fy(j, k, 0),
//          FRy + idx_Fy(j, k, 0),
//          wLy + idx_Fy(j, k, 0),
//          wRy + idx_Fy(j, k, 0),
//          numberOfVariables, 1);
//      dt_max_allowed = std::min(
//          dt_max_allowed, cflFactor / DIMENSIONS * cellSize[1] / s_max_y);
//    }
//  }
//
//  // TODO(guera): Early exit if dt > dt_max_allowed?!
//
//  // 5. Evolve, evaluate source, update cells
//  double ws[numberOfVariables]  = {0.0};
//  double src[numberOfVariables] = {0.0};
//
//  for (int j = patchBegin; j < patchEnd; j++) {
//    for (int k = patchBegin; k < patchEnd; k++) {
//      for (int l = 0; l < numberOfVariables; l++) {
//        ws[l] = luh[idx(j,k,l)] +
//            0.5 * slopet[idx(j,k,l)];
//      }
//      PDESource(ws, src);
//
//      for (int l = 0; l < numberOfVariables; l++) {
//        luh_new[idx_luh(j, k, l)] +=
//            dt / cellSize[0] * (Fx[idx_Fx(j, k, l)] - Fx[idx_Fx(j, k + 1, l)]) +
//            dt / cellSize[1] * (Fy[idx_Fy(j, k, l)] - Fy[idx_Fy(j + 1, k, l)]) +
//            dt * src[l];
//      }
//    }
//  }
//
//  return dt_max_allowed;
//}
//
//template <typename SolverType>
//double stableTimeStepSize(SolverType& solver,
//                          const double* const luh,
//                          double* tempEigenvalues,
//                          const tarch::la::Vector<DIMENSIONS, double>& dx) {
//  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
//  constexpr int numberOfParameters = SolverType::NumberOfParameters;
//  constexpr int patchSize          = SolverType::PatchSize;
//
//  double dt_max_stable = std::numeric_limits<double>::max();
//  constexpr double cflFactor = 0.9; // TODO externalize
//
//  constexpr int patchBegin=1;
//  constexpr int patchEnd=patchSize;
//  idx3 idx_luh(patchSize+2, patchSize+2, numberOfVariables+numberOfParameters);
//
//  double* lambda = tempEigenvalues;
//
//  for (int j = patchBegin; j < patchEnd+1; j++) {
//  for (int k = patchBegin; k < patchEnd+1; k++) {
//    // x
//    solver.eigenvalues(luh + idx_luh(j, k, 0), 0, lambda);
//    std::transform(lambda, lambda + numberOfVariables, lambda,
//                   std::abs<double>);
//    double s_max_x = *std::max_element(lambda, lambda + numberOfVariables);
//    dt_max_stable = std::min(
//        dt_max_stable, cflFactor / DIMENSIONS * (dx[0]/patchSize) / s_max_x);
//
//    // y
//    solver.eigenvalues(luh + idx_luh(j, k, 0), 1, lambda);
//    std::transform(lambda, lambda + numberOfVariables, lambda,
//                   std::abs<double>);
//    double s_max_y = *std::max_element(lambda, lambda + numberOfVariables);
//    dt_max_stable = std::min(
//        dt_max_stable, cflFactor / DIMENSIONS * (dx[1]/patchSize) / s_max_y);
//  }
//  }
//
//  assertion( tarch::la::greater(dt_max_stable,0.0) );
//  return dt_max_stable;
//}
//
//template <typename SolverType>
//void solutionAdjustment(
//    SolverType& solver,
//    double* luh, const tarch::la::Vector<DIMENSIONS, double>& center,
//    const tarch::la::Vector<DIMENSIONS, double>& dx, const double t,const double dt) {
//  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
//  constexpr int numberOfParameters = SolverType::NumberOfParameters;
//  constexpr int patchSize          = SolverType::PatchSize;
//
//  double x[DIMENSIONS];
//
//  constexpr int patchBegin=1;
//  constexpr int patchEnd=patchSize;
//  idx3 idx_luh(patchSize+2, patchSize+2, numberOfVariables+numberOfParameters);
//
//  for (int j = patchBegin; j < patchEnd+1; j++) {  // loop over dof
//    const double qs = (2.0*(j-patchBegin)+1.0)/(2.0*patchSize); //linspace;
//
//    for (int i = patchBegin; i < patchEnd+1; i++) {
//      const double qr = (2.0*(i-patchBegin)+1.0)/(2.0*patchSize); //linspace;
//      x[0] = center[0] + dx[0] * (qr - 0.5);
//      x[1] = center[1] + dx[1] * (qs - 0.5);
//
//      // read initial condition
//      solver.adjustSolution(x, 0, t, dt, luh+idx_luh(j,i,0));
//    }
//  }
//}
//
//// TODO(Dominic): Work in progress
//template <typename SolverType>
//void boundaryConditions(SolverType& solver,
//                        double* stateOut,
//                        const double* const stateIn,
//                        const tarch::la::Vector<DIMENSIONS, double>& cellCentre,
//                        const tarch::la::Vector<DIMENSIONS,double>& cellSize,
//                        const double t,const double dt,
//                        const int faceIndex,
//                        const int normalNonZero) {
//  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
//  constexpr int numberOfParameters = SolverType::NumberOfParameters;
//  constexpr int patchSize          = SolverType::PatchSize;
//
//  constexpr int ghostLayerWidth = 2;
//  constexpr int patchBegin      = ghostLayerWidth;
//  constexpr int patchEnd        = patchBegin+patchSize;
//  // Determine if face is "left" (=0 for faceIndex=0,2,4) or "right" face (=1 for faceIndex=1,2,3).
//  const int f = faceIndex-2*normalNonZero;
//
//  idx2 idx(patchSize,numberOfVariables + numberOfParameters);
//  // Determine the free direction from the non-zero normal entry.
//  int d1=0;
//  switch(normalNonZero) {
//    case 0:
//      d1=1;
//      break;
//    case 1:
//      d1=0;
//      break;
//    default:
//      assertionMsg(false,"normalNonZero must be either 0 or 1.");
//      break;
//  }
//
//
//  double x[DIMENSIONS];
//  x[normalNonZero] = cellCentre[normalNonZero] +
//      (-0.5 + (double) f) * cellSize[normalNonZero] * ( 1.0 + 1.0/(2.0*patchSize) ); // cell center of the outside cell (not the patch center).
//  for (int i = 0; i < patchSize; i++) {  // loop over dof
//    const double q = (2.0*i+1.0)/(2.0*patchSize); //linspace
//
//    x[d1] = cellCentre[d1] + cellSize[d1] * (q - 0.5);
//    solver.boundaryValues(x,t,dt,faceIndex,normalNonZero,
//        stateIn + idx(i,0),stateOut + idx(i,0));
//  }
//}
//
//}  // namespace c
//}  // namespace godunov
//}  // namespace finitevolumes
//}  // namespace kernels
//
//#endif  // DIMENSIONS == 2
