/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

#include <cassert>
#include <cmath>
#include <limits>
#include <utility>
#include <vector>
#include <algorithm>

#include "tarch/la/Vector.h"
#include "kernels/KernelUtils.h"

#if DIMENSIONS == 2

namespace kernels {
namespace finitevolumes {
namespace musclhancock {
namespace c {

// TODO(Dominic): Work in progress
/**
 * Solves all the Riemann problems that do only require
 * internal data and add the result directly onto the
 * new solution.
 * Finally add the source terms.
 */
template <typename SolverType>
double solutionUpdate(
    SolverType& solver,
    double* luh_new, const double* luh,
    double** tempStateSizedVectors,double** tempUnknowns,
    const tarch::la::Vector<DIMENSIONS, double>& dx,double dt) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize          = SolverType::PatchSize;

  constexpr int numberOfData = numberOfVariables+numberOfParameters;

  constexpr int ghostLayerWidth=2;
  constexpr int patchBegin=ghostLayerWidth;
  constexpr int patchEnd=patchBegin+patchSize;

  constexpr double cflFactor = 0.9;

  const double cellSize[2] = {dx[0]/patchSize, dx[1]/patchSize};

  // 1. Gather data from neighbouring cells; already done.

  // 2. Compute slopes TODO(Dominic): Make sure to only consider parameters in luh
  idx3 idx(patchSize+2*ghostLayerWidth,patchSize+2*ghostLayerWidth,numberOfData);
  constexpr int dataPerPatch = (patchSize+2*ghostLayerWidth)*(patchSize+2*ghostLayerWidth)*numberOfData;

  idx3 idx_slope(patchSize+2*ghostLayerWidth,patchSize+2*ghostLayerWidth,numberOfVariables);
  constexpr int variablesPerPatch = (patchSize+2*ghostLayerWidth)*(patchSize+2*ghostLayerWidth)*numberOfVariables;
  double slopex[variablesPerPatch] = {0.0};
  double slopey[variablesPerPatch] = {0.0};

  // slopex
  for (int j = patchBegin; j < patchEnd; j++) {
    for (int k = patchBegin-1; k < patchEnd+1; k++) {
      for (int l = 0; l < numberOfVariables; l++) {
        slopex[idx_slope(j, k, l)] =
            minmod(luh[idx(j, k + 1, l)] - luh[idx(j, k, l)],
                   luh[idx(j, k, l)] - luh[idx(j, k - 1, l)]);
      }
    }
  }
  // slopey
  for (int j = patchBegin-1; j < patchEnd+1; j++) {
    for (int k = patchBegin; k < patchEnd; k++) {
      for (int l = 0; l < numberOfVariables; l++) {
        slopey[idx_slope(j, k, l)] =
            minmod(luh[idx(j + 1, k, l)] - luh[idx(j, k, l)],
                   luh[idx(j, k, l)] - luh[idx(j - 1, k, l)]);
      }
    }
  }


  // 3.Boundary extrapolation (left and right value per face)
  double wLx[variablesPerPatch] = {0.0};
  double wRx[variablesPerPatch] = {0.0};
  double wLy[variablesPerPatch] = {0.0};
  double wRy[variablesPerPatch] = {0.0};

  // wx
  for (int j = patchBegin; j < patchEnd; j++) {
    for (int k = patchBegin-1; k < patchEnd+1; k++) {
      for (int l = 0; l < numberOfVariables; l++) {
        wLx[idx_slope(j, k, l)] = luh[idx(j, k, l)] - 0.5 * slopex[idx_slope(j, k, l)];
        wRx[idx_slope(j, k, l)] = luh[idx(j, k, l)] + 0.5 * slopex[idx_slope(j, k, l)];
      }
    }
  }
  // wy
  for (int j = patchBegin-1; j < patchEnd+1; j++) {
    for (int k = patchBegin; k < patchEnd; k++) {
      for (int l = 0; l < numberOfVariables; l++) {
        wLy[idx_slope(j, k, l)] = luh[idx(j, k, l)] - 0.5 * slopey[idx_slope(j, k, l)];
        wRy[idx_slope(j, k, l)] = luh[idx(j, K, l)] + 0.5 * slopey[idx_slope(j, k, l)];
      }
    }
  }

  // 4. Source evaluation, half time step evolution increment
  double flx[numberOfVariables * DIMENSIONS] = {0.0};
  double F[2] = {flx, flx + numberOfVariables}

  double slopet[variablesPerPatch] = {0.0};
  double Qt[numberOfVariables];

  // wx
  for (int j = patchBegin; j < patchEnd; j++) {
    for (int k = patchBegin; k < patchEnd; k++) {
      double* Qt = slopet + idx(j, k, 0);
      // source
      solver.algebraicSource(luh + idx_luh(j, k, 0), Qt);

      // fluxes
      solver.flux(wLx + idx_slope(j, k, 0), F); // FLx
      for (int l = 0; l < numberOfVariables; l++) {
        Qt[l] += F[0][l] / cellSize[0];
      }
      solver.flux(wRx + idx_slope(j, k, 0), F); // FRx
      for (int l = 0; l < numberOfVariables; l++) {
        Qt[l] -= F[0][l] / cellSize[0];
      }
      solver.flux(wRy + idx_slope(j, k, 0), F); // FLy
      for (int l = 0; l < numberOfVariables; l++) {
        Qt[l] += F[1][l] / cellSize[1];
      }
      solver.flux(wRy + idx_slope(j, k, 0), F); // FRy
      for (int l = 0; l < numberOfVariables; l++) {
        Qt[l] -= F[1][l] / cellSize[1];
      }

      // evolve boundary states
      for (int l = 0; l < numberOfVariables; l++) {
        wLx[idx_slope(j, k, l)] += 0.5 * dt * Qt[l];
        wRx[idx_slope(j, k, l)] += 0.5 * dt * Qt[l];
        wLy[idx_slope(j, k, l)] += 0.5 * dt * Qt[l];
        wRy[idx_slope(j, k, l)] += 0.5 * dt * Qt[l];
      }
    }
  }

  // 4. Solve Riemann problems
  double FLx[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};
  double FRy[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};
  double FLx[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};
  double FRy[numberOfVariables*patchSize*(patchSize + 1)] = {0.0};

  double dt_max_allowed = std::numeric_limits<double>::max();

  // x edges
  for (int j = patchBegin; j < patchEnd; j++) {
    for (int k = patchBegin; k < patchEnd+1; k++) {
      const int J = j-patchBegin;
      const int K = k-patchBegin;

      double s_max_x =
          riemannsolvers::c::rusanov<PDEEigenvalues, PDEFlux>(
          FLx + idx_Fx(J, K, 0),
          FRx + idx_Fx(J, K, 0),
          wLx + idx_slope(j, k, 0),
          wRx + idx_slope(j, k, 0),
          numberOfVariables, 0);
      // TODO(guera): Improve. I'm quite sure this is not the correct/best
      // formula.
      dt_max_allowed = std::min(
          dt_max_allowed, cflFactor / DIMENSIONS * cellSize[0] / s_max_x);
    }
  }

  // y edges
  for (int j = patchBegin; j < patchEnd+1; j++) {
    for (int k = patchBegin; k < patchEnd; k++) {
      const int J = j-patchBegin;
      const int K = k-patchBegin;

      double s_max_y = riemannsolvers::c::rusanov<PDEEigenvalues, PDEFlux>(
          FLy + idx_Fy(J, K, 0),
          FRy + idx_Fy(J, K, 0),
          wLy + idx_slope(j, k, 0),
          wRy + idx_slope(j, k, 0),
          numberOfVariables, 1);
      dt_max_allowed = std::min(
          dt_max_allowed, cflFactor / DIMENSIONS * cellSize[1] / s_max_y);
    }
  }

  // TODO(guera): Early exit if dt > dt_max_allowed?!

  // 5. Evolve, evaluate source, update cells
  double ws[numberOfVariables]  = {0.0};
  double src[numberOfVariables] = {0.0};

  for (int j = patchBegin; j < patchEnd; j++) {
    for (int k = patchBegin; k < patchEnd; k++) {
      for (int l = 0; l < numberOfVariables; l++) {
        ws[l] = luh[idx(j,k,l)] +
            0.5 * slopet[idx_slope(j,k,l)];
      }
      PDESource(ws, src);

      const int J = j-patchBegin;
      const int K = k-patchBegin;
      for (int l = 0; l < numberOfVariables; l++) {
        luh_new[idx(j, k, l)] +=
            dt / cellSize[0] * (Fx[idx_Fx(J, K, l)] - Fx[idx_Fx(J, K + 1, l)]) +
            dt / cellSize[1] * (Fy[idx_Fy(J, K, l)] - Fy[idx_Fy(J + 1, K, l)]) +
            dt * src[l];
      }
    }
  }

  return dt_max_allowed;
}

}  // namespace c
}  // namespace godunov
}  // namespace finitevolumes
}  // namespace kernels

#endif  // DIMENSIONS == 2
