/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

#include <cassert>
#include <cmath>
#include <limits>
#include <utility>
#include <vector>
#include <algorithm>

#include "tarch/la/Vector.h"
#include "kernels/KernelUtils.h"
#include "kernels/finitevolumes/riemannsolvers/c/riemannsolvers.h"

#if DIMENSIONS == 2

namespace kernels {
namespace finitevolumes {
namespace godunov {
namespace c {

/**
 * Solves all the Riemann problems that do only require
 * internal data and add the result directly onto the
 * new solution. 
 * Finally add the source terms.
 */
template <typename SolverType>
double solutionUpdate(
    SolverType& solver,
    double* luh_new, const double* luh,
    double** tempStateSizedVectors,double** tempUnknowns,
    const tarch::la::Vector<DIMENSIONS, double>& dx,double dt) {  
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize          = SolverType::PatchSize;
  
  constexpr int patchBegin=1;
  constexpr int patchEnd=patchSize;
  
  idx3 idx(patchSize+2, patchSize+2, numberOfVariables+numberOfParameters);
  
  const double cellSize[2] = {dx[0]/patchSize, dx[1]/patchSize};

  // clear array -> not sure whether this is required
//  memset(luh_new,0.0,patchSize*patchSize*numberOfVariables);

  // Solve Riemann problems
  double dt_max_allowed = std::numeric_limits<double>::max();
  constexpr double cflFactor = 0.9; // TODO(Dominic): Move this out.

  // x edges 
//  double* fL = tempStateSizedVectors[0]; @todo pleaes remove the root of all evil
  double  fL[numberOfVariables + numberOfParameters];
  double  fR[numberOfVariables + numberOfParameters];
  for (int j = patchBegin; j < patchEnd+1; j++) {
    for (int k = patchBegin-1; k < patchEnd+1; k++) {  // We have patchSize+1 faces in each coordinate direction
      const double *qL = luh + idx(j, k, 0);
      const double *qR = luh + idx(j, k+1, 0);
      double s_max_x = 
          riemannsolvers::c::rusanov<SolverType>(
              solver,
              fL, fR,
              qL, qR, 
              0 );
              
//              tempStateSizedVectors + 1);
      // TODO(guera): Improve. I'm quite sure this is not the correct/best
      // formula. TODO(Dominic): The division by DIMENSIONS might make sure that C_x+C_y < 1
      dt_max_allowed = std::min(
          dt_max_allowed, cflFactor / DIMENSIONS * cellSize[0] / s_max_x); // TODO(Dominic): Ignore this for a while
      
      for (int l=0; l<numberOfVariables; ++l) {
        luh_new[idx(j, k, l)]   -= dt / cellSize[0] * fL[l];
        luh_new[idx(j, k+1, l)] += dt / cellSize[0] * fR[l];
      }
    }
  }

  // y edges
  for (int j = patchBegin-1; j < patchEnd+1; j++) {
    for (int k = patchBegin; k < patchEnd+1; k++) {
      const double *qL = luh + idx(j, k, 0);
      const double *qR = luh + idx(j+1, k, 0);
      double s_max_y =
          riemannsolvers::c::rusanov<SolverType>(
          solver,
          fL, fR,
          qL, qR, 
          1 );
      //tempStateSizedVectors + 1);
      dt_max_allowed = std::min(
          dt_max_allowed, cflFactor / DIMENSIONS * cellSize[1] / s_max_y);
      
      for (int l=0; l<numberOfVariables; ++l) {
        luh_new[idx(j, k, l)]   -= dt / cellSize[1] * fL[l];  
        luh_new[idx(j+1, k, l)] += dt / cellSize[1] * fR[l];
      }
    }
  }

  // 5. Add the source terms 
  if (solver.useSource()) {
    //double* source = tempStateSizedVectors[0]; // temp var; state sized vector
    double  source[numberOfVariables + numberOfParameters];
  
    for (int j = patchBegin; j < patchEnd+1; j++) {
      for (int k = patchBegin; k < patchEnd+1; k++) {
        solver.source(&luh[idx(j, k, 0)], source);
      
        for (int l = 0; l < numberOfVariables; l++) {
          // in Godunov 1st order, we have piecewise constant data and thus
          // no contribution from BgradQ (solver.cnp) to the solution, cf.
          // http://dx.doi.org/10.1016/j.apnum.2016.02.001  (eq 36),
          // term \delta Q/\delta x is vanishing.
          luh_new[idx(j, k, l)] += dt * source[l];
        }
      }
    }
  }
  
  return dt_max_allowed;
}


}  // namespace c
}  // namespace godunov
}  // namespace finitevolumes
}  // namespace kernels

#endif  // DIMENSIONS == 2
