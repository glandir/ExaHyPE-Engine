/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 *
 * @authors: Dominic E. Charrier
 **/

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#if DIMENSIONS==2
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename SolverType>
void kernels::finitevolumes::ghostlayers::c::boundaryLayerExtraction(
    SolverType& solver,
    double* luhbnd,const double* luh,
    const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize          = SolverType::PatchSize;
  constexpr int ghostLayerWidth    = SolverType::GhostLayerWidth;

  constexpr int numberOfData = numberOfVariables+numberOfParameters;

  // 1D patch values:
  // |G|G|U0|U1|..|UN|G|G|,
  // G: ghost value, Ui: local solution value
  constexpr int patchBegin      = ghostLayerWidth;
  constexpr int patchEnd        = patchBegin+patchSize;
  idx3 idx(patchSize+2*ghostLayerWidth, // y
           patchSize+2*ghostLayerWidth, // x
           numberOfData);

  idx3 idx_bnd_x(patchSize,ghostLayerWidth,numberOfData); // x,x; x,x; x,x; ... x,x;
  idx3 idx_bnd_y(ghostLayerWidth,patchSize,numberOfData); // x,x,x,x,x,...,x; x,x,x,x,x,...,x;

  // TODO: Depending on the memory layout, we can remove the loops
  // and use larger strides for one of the coordinate directions.

  if (boundaryPosition[0] == -1) {
    // assertion: boundaryPosition[1] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
      // first layer
      std::copy_n(
          luh+idx(i,patchBegin+k,0),
          numberOfData,
          luhbnd+idx_bnd_x(i-patchBegin,k,0));
      }
    }
  }
  if (boundaryPosition[0] == +1) {
    // assertion: boundaryPosition[1] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        // first layer
        std::copy_n(
            luh+idx(i,patchEnd-ghostLayerWidth+k,0),
            numberOfData,
            luhbnd+idx_bnd_x(i-patchBegin,k,0));
      }
    }
  }

  if (boundaryPosition[1] == -1) {
    // assertion: boundaryPosition[0] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luh+idx(patchBegin+k,i,0),
            numberOfData,
            luhbnd+idx_bnd_y(k,i-patchBegin,0));
      }
    }
  }
  if (boundaryPosition[1] == +1) {
    // assertion: boundaryPosition[0] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luh+idx(patchEnd-ghostLayerWidth+k,i,0),
            numberOfData,
            luhbnd+idx_bnd_y(k,i-patchBegin,0));
      }
    }
  }
}

template <typename SolverType>
void kernels::finitevolumes::ghostlayers::c::ghostLayerFillingAtBoundary(
    SolverType& solver,
    double* luh,const double* luhbnd,
    const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize          = SolverType::PatchSize;
  constexpr int ghostLayerWidth    = SolverType::GhostLayerWidth;

  constexpr int numberOfData = numberOfVariables+numberOfParameters;

  constexpr int patchBegin      = ghostLayerWidth;
  constexpr int patchEnd        = patchBegin+patchSize;
  idx3 idx(patchSize+2*ghostLayerWidth, // y
      patchSize+2*ghostLayerWidth, // x
      numberOfData);

  idx3 idx_bnd_x(patchSize,ghostLayerWidth,numberOfData); // x,x; x,x; x,x; ... x,x;
  idx3 idx_bnd_y(ghostLayerWidth,patchSize,numberOfData); // x,x,x,x,x,...,x; x,x,x,x,x,...,x;

  // TODO: Depending on the memory layout, we can remove the loop,
  // and use larger strides for one of the coordinate directions.

  if (boundaryPosition[0] == -1) {
    // assertion: boundaryPosition[1] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhbnd+idx_bnd_x(i-patchBegin,k,0), // (iy,ix,ivar)
            numberOfData,
            luh+idx(i,k,0));
      }
    }
  }
  if (boundaryPosition[0] == +1) {
    // assertion: boundaryPosition[1] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
          luhbnd+idx_bnd_x(i-patchBegin,k,0),
          numberOfData,
          luh+idx(i,patchEnd+k,0));
      }
    }
  }

  if (boundaryPosition[1] == -1) {
    // assertion: boundaryPosition[0] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhbnd+idx_bnd_y(k,i-patchBegin,0),
            numberOfData,
            luh+idx(k,i,0));
      }
    }
  }
  if (boundaryPosition[1] == +1) {
    // assertion: boundaryPosition[0] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhbnd+idx_bnd_y(k,i-patchBegin,0),
            numberOfData,
            luh+idx(patchEnd+k,i,0));
      }
    }
  }
}

template <typename SolverType>
void kernels::finitevolumes::ghostlayers::c::ghostLayerFilling(
      SolverType& solver,
      double* luh,const double* luhNeighbour,
      const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize          = SolverType::PatchSize;
  constexpr int ghostLayerWidth    = SolverType::GhostLayerWidth;

  constexpr int numberOfData = numberOfVariables+numberOfParameters;

  constexpr int patchBegin      = ghostLayerWidth;
  constexpr int patchEnd        = patchBegin+patchSize; // exclusive
  idx3 idx(patchSize+2*ghostLayerWidth, // y
      patchSize+2*ghostLayerWidth, // x
      numberOfData);

  // TODO: Depending on the memory layout, we can remove the loop,
  // and use larger strides for one of the coordinate directions.

  if (neighbourPosition[0] == -1) {
    // assertion: neighbourPosition[1] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhNeighbour+idx(i,patchEnd-ghostLayerWidth+k,0),
            numberOfData,
            luh+idx(i,k,0));
      }
    }
  }
  if (neighbourPosition[0] == +1) {
    // assertion: neighbourPosition[1] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhNeighbour+idx(i,patchBegin+k,0),
            numberOfData,
            luh+idx(i,patchEnd+k,0));
      }
    }
  }

  if (neighbourPosition[1] == -1) {
    // assertion: neighbourPosition[0] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhNeighbour+idx(patchEnd-ghostLayerWidth+k,i,0),
            numberOfData,
            luh+idx(k,i,0));
      }
    }
  }
  if (neighbourPosition[1] == +1) {
    // assertion: neighbourPosition[0] == 0;
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhNeighbour+idx(patchBegin+k,i,0),
            numberOfData,
            luh+idx(patchEnd+k,i,0));
      }
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#elif DIMENSIONS==3
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <typename SolverType>
void kernels::finitevolumes::ghostlayers::c::boundaryLayerExtraction(
    SolverType& solver,
    double* luhbnd,const double* luh,
    const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize          = SolverType::PatchSize;

  constexpr int numberOfData       = numberOfVariables+numberOfParameters;

  constexpr int ghostLayerWidth=2;
  constexpr int patchBegin=ghostLayerWidth;
  constexpr int patchEnd=patchBegin+patchSize;
  idx4 idx(patchSize+2*ghostLayerWidth,patchSize+2*ghostLayerWidth,patchSize+2*ghostLayerWidth,numberOfData);
  idx4 idx_bnd_x(patchSize,patchSize,ghostLayerWidth,numberOfData);
  idx4 idx_bnd_y(patchSize,ghostLayerWidth,patchSize,numberOfData);
  idx4 idx_bnd_z(ghostLayerWidth,patchSize,patchSize,numberOfData);

  // TODO: Depending on the memory layout, we can remove the loops
  // and use larger strides for one of the coordinate directions.

  // x-axis: strides: Mz>My
  if (boundaryPosition[0] == -1) {  // |G0|G1|U0|U1|...
    // assertion: boundaryPosition[1] == 0;
    // assertion: boundaryPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; k++) {
        std::copy_n(
            luh+idx(j,i,patchBegin+k,0),
            numberOfData,
            luhbnd+idx_bnd_x(j-patchBegin,i-patchBegin,k,0));
      }
    }
    }
  }
  if (boundaryPosition[0] == +1) { // UN-1|UN||G0|G1|
    // assertion: boundaryPosition[1] == 0;
    // assertion: boundaryPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; k++) {
        std::copy_n(
            luh+idx(j,i,patchEnd-ghostLayerWidth+k,0),
            numberOfData,
            luhbnd+idx_bnd_x(j-patchBegin,i-patchBegin,k,0));
      }
    }
    }
  }

  // y-axis: strides: Mz>Mx
  if (boundaryPosition[1] == -1) {
    // assertion: boundaryPosition[0] == 0;
    // assertion: boundaryPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; k++) {
        std::copy_n(
            luh+idx(j,patchBegin,i,0),
            numberOfData,
            luhbnd+idx_bnd_y(j-patchBegin,k,i-patchBegin,0));
      }
    }
    }
  }
  if (boundaryPosition[1] == +1) {
    // assertion: boundaryPosition[0] == 0;
    // assertion: boundaryPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; k++) {
        std::copy_n(
            luh+idx(j,patchEnd-ghostLayerWidth+k,i,0),
            numberOfData,
            luhbnd+idx_bnd_y(j-patchBegin,k,i-patchBegin,0));
      }
    }
    }
  }

  // z-axis: strides: My>Mx
  if (boundaryPosition[2] == -1) {
    // assertion: boundaryPosition[0] == 0;
    // assertion: boundaryPosition[1] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; k++) {
        std::copy_n(
            luh+idx(patchBegin,j,i,0),
            numberOfData,
            luhbnd+idx_bnd_z(k,j-patchBegin,i-patchBegin,0));
      }
    }
    }
  }
  if (boundaryPosition[2] == +1) {
    // assertion: boundaryPosition[0] == 0;
    // assertion: boundaryPosition[1] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; k++) {
        std::copy_n(
            luh+idx(patchEnd-ghostLayerWidth+k,j,i,0),
            numberOfData,
            luhbnd+idx_bnd_z(k,j-patchBegin,i-patchBegin,0));
      }
    }
    }
  }
}

template <typename SolverType>
void kernels::finitevolumes::ghostlayers::c::ghostLayerFillingAtBoundary(
    SolverType& solver,
    double* luh,const double* luhbnd,
    const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize          = SolverType::PatchSize;

  constexpr int numberOfData       = numberOfVariables+numberOfParameters;

  constexpr int ghostLayerWidth=2; // TODO
  constexpr int patchBegin=ghostLayerWidth;
  constexpr int patchEnd=patchBegin+patchSize;
  idx4 idx(patchSize+2*ghostLayerWidth,patchSize+2*ghostLayerWidth,patchSize+2*ghostLayerWidth,numberOfData);
  idx4 idx_bnd_x(patchSize,patchSize,ghostLayerWidth,numberOfData);
  idx4 idx_bnd_y(patchSize,ghostLayerWidth,patchSize,numberOfData);
  idx4 idx_bnd_z(ghostLayerWidth,patchSize,patchSize,numberOfData);

  // TODO: Depending on the memory layout, we can remove the loop,
  // and use larger strides for one of the coordinate directions.

  // x-axis
  if (boundaryPosition[0] == -1) {
    // assertion: boundaryPosition[1] == 0;
    // assertion: boundaryPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhbnd+idx_bnd_x(j-patchBegin,i-patchBegin,k,0),
            numberOfData,
            luh+idx(j,i,k,0));
      }
    }
    }
  }
  if (boundaryPosition[0] == +1) {
    // assertion: boundaryPosition[1] == 0;
    // assertion: boundaryPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhbnd+idx_bnd_x(j-patchBegin,i-patchBegin,k,0),
            numberOfData,
            luh+idx(j,i,patchEnd+k,0));
      }
    }
    }
  }

  // y-axis
  if (boundaryPosition[1] == -1) {
    // assertion: boundaryPosition[0] == 0;
    // assertion: boundaryPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhbnd+idx_bnd_y(j-patchBegin,k,i-patchBegin,0),
            numberOfData,
            luh+idx(j,k,i,0));
      }
    }
    }
  }
  if (boundaryPosition[1] == +1) {
    // assertion: boundaryPosition[0] == 0;
    // assertion: boundaryPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhbnd+idx_bnd_y(j-patchBegin,k,i-patchBegin,0),
            numberOfData,
            luh+idx(j,patchEnd+k,i,0));
      }
    }
    }
  }

  // z-axis
  if (boundaryPosition[2] == -1) {
    // assertion: boundaryPosition[0] == 0;
    // assertion: boundaryPosition[1] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhbnd+idx_bnd_z(k,j-patchBegin,i-patchBegin,0),
            numberOfData,
            luh+idx(k,j,i,0));
      }
    }
    }
  }
  if (boundaryPosition[2] == +1) {
    // assertion: boundaryPosition[0] == 0;
    // assertion: boundaryPosition[1] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhbnd+idx_bnd_z(k,j-patchBegin,i-patchBegin,0),
            numberOfData,
            luh+idx(patchEnd+k,j,i,0));
      }
    }
    }
  }
}


template <typename SolverType>
void kernels::finitevolumes::ghostlayers::c::ghostLayerFilling(
      SolverType& solver,
      double* luh,const double* luhNeighbour,
      const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize          = SolverType::PatchSize;

  constexpr int numberOfData       = numberOfVariables+numberOfParameters;

  constexpr int ghostLayerWidth=2; // TODO
  constexpr int patchBegin=ghostLayerWidth;
  constexpr int patchEnd=patchBegin+patchSize;
  idx4 idx(patchSize+2*ghostLayerWidth,patchSize+2*ghostLayerWidth,patchSize+2*ghostLayerWidth,numberOfData);

  // TODO: Depending on the memory layout, we can remove the loop,
  // and use larger strides for one of the coordinate directions.

  // x-axis
  if (neighbourPosition[0] == -1) {
    // assertion: neighbourPosition[1] == 0;
    // assertion: neighbourPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhNeighbour+idx(j,i,patchEnd-ghostLayerWidth+k,0),
            numberOfData,
            luh+idx(j,i,k,0));
      }
    }
    }
  }
  if (neighbourPosition[0] == +1) {
    // assertion: neighbourPosition[1] == 0;
    // assertion: neighbourPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhNeighbour+idx(j,i,patchBegin+k,0),
            numberOfData,
            luh+idx(j,i,patchEnd+k,0));
      }
    }
    }
  }

  // y-axis
  if (neighbourPosition[1] == -1) {
    // assertion: neighbourPosition[0] == 0;
    // assertion: neighbourPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhNeighbour+idx(j,patchEnd+k,i,0),
            numberOfData,
            luh+idx(j,k,i,0));
      }
    }
    }
  }
  if (neighbourPosition[1] == +1) {
    // assertion: neighbourPosition[0] == 0;
    // assertion: neighbourPosition[2] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhNeighbour+idx(j,patchBegin+k,i,0),
            numberOfData,
            luh+idx(j,patchEnd+k,i,0));
      }
    }
    }
  }

  // z-axis
  if (neighbourPosition[2] == -1) {
    // assertion: neighbourPosition[0] == 0;
    // assertion: neighbourPosition[1] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhNeighbour+idx(patchEnd+k,j,i,0),
            numberOfData,
            luh+idx(k,j,i,0));
      }
    }
    }
  }
  if (neighbourPosition[2] == +1) {
    // assertion: neighbourPosition[0] == 0;
    // assertion: neighbourPosition[1] == 0;
    for (int j=patchBegin; j<patchEnd; ++j) {
    for (int i=patchBegin; i<patchEnd; ++i) {
      for (int k=0; k<ghostLayerWidth; ++k) {
        std::copy_n(
            luhNeighbour+idx(patchBegin+k,j,i,0),
            numberOfData,
            luh+idx(patchEnd+k,j,i,0));
      }
    }
    }
  }
}
#endif // DIMENSIONS
