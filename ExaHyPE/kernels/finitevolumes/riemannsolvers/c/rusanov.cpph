namespace kernels {
namespace finitevolumes {
namespace riemannsolvers {
namespace c {

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#if DIMENSIONS==2
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
/**
 * A simple Rusanov flux considering pointwise
 * left and right values.
 */
template <typename SolverType>
double riemannSolver(
    SolverType& solver,
    double* fL, double *fR, const double* qL, const double* qR, int normalNonZero,
    double** tempStateSizedVectors) { // TODO(Dominic): I need four of those
  constexpr int numberOfVariables = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;

  //double* sL = tempStateSizedVectors[0];
  //double* sR = tempStateSizedVectors[1];
  double sL[numberOfVariables + numberOfParameters];
  double sR[numberOfVariables + numberOfParameters];

  solver.eigenvalues(qL, normalNonZero, sL);
  solver.eigenvalues(qR, normalNonZero, sR);

  double s_max = -1.0;
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sL_i = std::abs(sL[i]);
    s_max = std::max( abs_sL_i, s_max );
  }
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sR_i = std::abs(sR[i]);
    s_max = std::max( abs_sR_i, s_max );
  }

  double FL2a[numberOfVariables + numberOfParameters];
  double FL2b[numberOfVariables + numberOfParameters];
  double FR2a[numberOfVariables + numberOfParameters];
  double FR2b[numberOfVariables + numberOfParameters];

  //double* FL2[2] = {tempStateSizedVectors[0],tempStateSizedVectors[1]}; // dim a numberOfVariables
  //double* FR2[2] = {tempStateSizedVectors[2],tempStateSizedVectors[3]}; // dim a numberOfVariables
  double* FL2[2] = {FL2a,FL2b}; // dim a numberOfVariables
  double* FR2[2] = {FR2a,FR2b}; // dim a numberOfVariables

  solver.flux(qL, FL2);
  solver.flux(qR, FR2);

  double Qavg[numberOfVariables+numberOfParameters];
  for(int k=0; k < numberOfVariables+numberOfParameters; k++) {
     Qavg[k] = (qL[k] + qR[k]) / 2;
  }

  for (int i = 0; i < numberOfVariables + numberOfParameters; i++) {
    fL[i] = 0.5 * (FL2[normalNonZero][i] + FR2[normalNonZero][i]) +
              0.5 * s_max * (qL[i] - qR[i]);
    fR[i] = 0.5 * (FL2[normalNonZero][i] + FR2[normalNonZero][i]) +
              0.5 * s_max * (qL[i] - qR[i]);
  }

  if (solver.useNonConservativeProduct()) {
    double Bn[ (numberOfVariables + numberOfParameters) * (numberOfVariables + numberOfParameters)];
    double ncp[numberOfVariables + numberOfParameters];
    idx2 idx_Bn(numberOfVariables + numberOfParameters, numberOfVariables + numberOfParameters);
    solver.coefficientMatrix(Qavg, normalNonZero, Bn);

    for(int l=0; l < numberOfVariables + numberOfParameters; l++) {
      ncp[l] = 0;
      for(int m=0; m < numberOfVariables+ numberOfParameters; m++) {
        ncp[l] += Bn[idx_Bn(m, l)] * (qR[m] - qL[m]);
      }
    }

    for (int i = 0; i < numberOfVariables + numberOfParameters; i++) {
      fR[i] = fR[i] - 0.5 * ncp[i];
      fL[i] = fL[i] + 0.5 * ncp[i];
    }
  }

  return s_max;
}

/**
 * Solves all the Riemann problems that do only require
 * internal data and add the result directly onto the
 * new solution.
 * Finally add the source terms.
 */
template <typename SolverType>
double solutionUpdate(
    SolverType& solver,
    double* luh_new, const double* luh,
    double** tempStateSizedVectors,double** tempUnknowns,
    const tarch::la::Vector<DIMENSIONS, double>& dx,double dt) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize          = SolverType::PatchSize;

  constexpr int patchBegin=1;
  constexpr int patchEnd=patchSize;

  idx3 idx(patchSize+2, patchSize+2, numberOfVariables+numberOfParameters);

  const double cellSize[2] = {dx[0]/patchSize, dx[1]/patchSize};

  // clear array -> not sure whether this is required
//  memset(luh_new,0.0,patchSize*patchSize*numberOfVariables);

  // Solve Riemann problems
  double dt_max_allowed = std::numeric_limits<double>::max();
  constexpr double cflFactor = 0.9; // TODO(Dominic): Move this out.

  // x edges
//  double* fL = tempStateSizedVectors[0]; @todo pleaes remove the root of all evil
  double  fL[numberOfVariables + numberOfParameters];
  double  fR[numberOfVariables + numberOfParameters];
  for (int j = patchBegin; j < patchEnd+1; j++) {
    for (int k = patchBegin-1; k < patchEnd+1; k++) {  // We have patchSize+1 faces in each coordinate direction
      const double *qL = luh + idx(j, k, 0);
      const double *qR = luh + idx(j, k+1, 0);
      double s_max_x =
          riemannSolver<SolverType>(
              solver,
              fL, fR,
              qL, qR,
              0, 0 );

//              tempStateSizedVectors + 1);
      // TODO(guera): Improve. I'm quite sure this is not the correct/best
      // formula. TODO(Dominic): The division by DIMENSIONS might make sure that C_x+C_y < 1
      dt_max_allowed = std::min(
          dt_max_allowed, cflFactor / DIMENSIONS * cellSize[0] / s_max_x); // TODO(Dominic): Ignore this for a while

      for (int l=0; l<numberOfVariables; ++l) {
        luh_new[idx(j, k, l)]   -= dt / cellSize[0] * fL[l];
        luh_new[idx(j, k+1, l)] += dt / cellSize[0] * fR[l];
      }
    }
  }

  // y edges
  for (int j = patchBegin-1; j < patchEnd+1; j++) {
    for (int k = patchBegin; k < patchEnd+1; k++) {
      const double *qL = luh + idx(j, k, 0);
      const double *qR = luh + idx(j+1, k, 0);
      double s_max_y =
        riemannSolver<SolverType>(
          solver,
          fL, fR,
          qL, qR,
          1, 0 );
      //tempStateSizedVectors + 1);
      dt_max_allowed = std::min(
          dt_max_allowed, cflFactor / DIMENSIONS * cellSize[1] / s_max_y);

      for (int l=0; l<numberOfVariables; ++l) {
        luh_new[idx(j, k, l)]   -= dt / cellSize[1] * fL[l];
        luh_new[idx(j+1, k, l)] += dt / cellSize[1] * fR[l];
      }
    }
  }

  // 5. Add the source terms
  if (solver.useSource()) {
    //double* source = tempStateSizedVectors[0]; // temp var; state sized vector
    double  source[numberOfVariables + numberOfParameters];

    for (int j = patchBegin; j < patchEnd+1; j++) {
      for (int k = patchBegin; k < patchEnd+1; k++) {
        solver.source(&luh[idx(j, k, 0)], source);

        for (int l = 0; l < numberOfVariables; l++) {
          // in Godunov 1st order, we have piecewise constant data and thus
          // no contribution from BgradQ (solver.cnp) to the solution, cf.
          // http://dx.doi.org/10.1016/j.apnum.2016.02.001  (eq 36),
          // term \delta Q/\delta x is vanishing.
          luh_new[idx(j, k, l)] += dt * source[l];
        }
      }
    }
  }

  return dt_max_allowed;
}

template <typename SolverType>
double stableTimeStepSize(SolverType& solver,
                          const double* const luh,
                          double* tempEigenvalues,
                          const tarch::la::Vector<DIMENSIONS, double>& dx) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize          = SolverType::PatchSize;

  double dt_max_stable = std::numeric_limits<double>::max();
  constexpr double cflFactor = 0.9; // TODO externalize

  constexpr int patchBegin=1;
  constexpr int patchEnd=patchSize;
  idx3 idx_luh(patchSize+2, patchSize+2, numberOfVariables+numberOfParameters);

  double* lambda = tempEigenvalues;

  for (int j = patchBegin; j < patchEnd+1; j++) {
  for (int k = patchBegin; k < patchEnd+1; k++) {
    // x
    solver.eigenvalues(luh + idx_luh(j, k, 0), 0, lambda);
    std::transform(lambda, lambda + numberOfVariables, lambda,
                   std::abs<double>);
    double s_max_x = *std::max_element(lambda, lambda + numberOfVariables);
    dt_max_stable = std::min(
        dt_max_stable, cflFactor / DIMENSIONS * (dx[0]/patchSize) / s_max_x);

    // y
    solver.eigenvalues(luh + idx_luh(j, k, 0), 1, lambda);
    std::transform(lambda, lambda + numberOfVariables, lambda,
                   std::abs<double>);
    double s_max_y = *std::max_element(lambda, lambda + numberOfVariables);
    dt_max_stable = std::min(
        dt_max_stable, cflFactor / DIMENSIONS * (dx[1]/patchSize) / s_max_y);
  }
  }

  assertion( tarch::la::greater(dt_max_stable,0.0) );
  return dt_max_stable;
}

template <typename SolverType>
void solutionAdjustment(
    SolverType& solver,
    double* luh, const tarch::la::Vector<DIMENSIONS, double>& center,
    const tarch::la::Vector<DIMENSIONS, double>& dx, const double t,const double dt) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize          = SolverType::PatchSize;

  double x[DIMENSIONS];

  constexpr int patchBegin=1;
  constexpr int patchEnd=patchSize;
  idx3 idx_luh(patchSize+2, patchSize+2, numberOfVariables+numberOfParameters);

  for (int j = patchBegin; j < patchEnd+1; j++) {  // loop over dof
    const double qs = (2.0*(j-patchBegin)+1.0)/(2.0*patchSize); //linspace;

    for (int i = patchBegin; i < patchEnd+1; i++) {
      const double qr = (2.0*(i-patchBegin)+1.0)/(2.0*patchSize); //linspace;
      x[0] = center[0] + dx[0] * (qr - 0.5);
      x[1] = center[1] + dx[1] * (qs - 0.5);

      // read initial condition
      solver.adjustSolution(x, 0, t, dt, luh+idx_luh(j,i,0));
    }
  }
}

template <typename SolverType>
void boundaryConditions(SolverType& solver,
                        double* stateOut,
                        const double* const stateIn,
                        const tarch::la::Vector<DIMENSIONS, double>& cellCentre,
                        const tarch::la::Vector<DIMENSIONS,double>& cellSize,
                        const double t,const double dt,
                        const int faceIndex,
                        const int normalNonZero) {
  constexpr int numberOfVariables = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int patchSize         = SolverType::PatchSize;
  // Determine if face is "left" (=0 for faceIndex=0,2,4) or "right" face (=1 for faceIndex=1,2,3).
  const int f = faceIndex-2*normalNonZero;

  idx2 idx(patchSize,numberOfVariables + numberOfParameters);
  // Determine the free direction from the non-zero normal entry.
  int d1=0;
  switch(normalNonZero) {
    case 0:
      d1=1;
      break;
    case 1:
      d1=0;
      break;
    default:
      assertionMsg(false,"normalNonZero must be either 0 or 1.");
      break;
  }


  double x[DIMENSIONS];
  x[normalNonZero] = cellCentre[normalNonZero] +
      (-0.5 + (double) f) * cellSize[normalNonZero] * ( 1.0 + 1.0/(2.0*patchSize) ); // cell center of the outside cell (not the patch center).
  for (int i = 0; i < patchSize; i++) {  // loop over dof
    const double q = (2.0*i+1.0)/(2.0*patchSize); //linspace

    x[d1] = cellCentre[d1] + cellSize[d1] * (q - 0.5);
    solver.boundaryValues(x,t,dt,faceIndex,normalNonZero,
        stateIn + idx(i,0),stateOut + idx(i,0));
  }
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#elif DIMENSIONS == 3
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
/**
 * A simple Rusanov flux considering pointwise
 * left and right values.
 */
//template <void PDEEigenvalues(const double* const Q, const int normalNonZero,
//                              double* lambda),
//          void PDEFlux(const double* const Q, double** F)>
template <typename SolverType>
double rusanov(SolverType& solver, double* fL, double *fR, const double* qL, const double* qR,
                     int normalNonZero,double** tempStateSizedVectors) { // TODO(Dominic): I need four of those
  constexpr int numberOfVariables = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;

  //double* sL = tempStateSizedVectors[0];
  //double* sR = tempStateSizedVectors[1];
  double sL[numberOfVariables + numberOfParameters];
  double sR[numberOfVariables + numberOfParameters];


  solver.eigenvalues(qL, normalNonZero, sL);
  solver.eigenvalues(qR, normalNonZero, sR);

  double s_max = -1.0;
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sL_i = std::abs(sL[i]);
    s_max = std::max( abs_sL_i, s_max );
  }
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sR_i = std::abs(sR[i]);
    s_max = std::max( abs_sR_i, s_max );
  }

  double FL3a[numberOfVariables + numberOfParameters];
  double FL3b[numberOfVariables + numberOfParameters];
  double FL3c[numberOfVariables + numberOfParameters];
  double FR3a[numberOfVariables + numberOfParameters];
  double FR3b[numberOfVariables + numberOfParameters];
  double FR3c[numberOfVariables + numberOfParameters];

  //double* FL3[3] = {tempStateSizedVectors[0],tempStateSizedVectors[1],tempStateSizedVectors[2]}; // dim a numberOfVariables
  //double* FR3[3] = {tempStateSizedVectors[3],tempStateSizedVectors[4],tempStateSizedVectors[5]}; // dim a numberOfVariables
  double* FL3[3] = {FL3a,FL3b,FL3c}; // dim a numberOfVariables
  double* FR3[3] = {FR3a,FR3b,FR3c}; // dim a numberOfVariables

  solver.flux(qL, FL3);
  solver.flux(qR, FR3);

  double Qavg[numberOfVariables+numberOfParameters];
  for(int k=0; k < numberOfVariables+numberOfParameters; k++) {
     Qavg[k] = (qL[k] + qR[k]) / 2;
  }

  for (int i = 0; i < numberOfVariables + numberOfParameters; i++) {
    fL[i] = 0.5 * (FL3[normalNonZero][i] + FR3[normalNonZero][i]) +
              0.5 * s_max * (qL[i] - qR[i]);
    fR[i] = 0.5 * (FL3[normalNonZero][i] + FR3[normalNonZero][i]) +
              0.5 * s_max * (qL[i] - qR[i]);
  }

  if (solver.useNonConservativeProduct()) {
    double Bn[ (numberOfVariables + numberOfParameters) * (numberOfVariables + numberOfParameters)];
    double ncp[numberOfVariables + numberOfParameters];
    idx2 idx_Bn(numberOfVariables + numberOfParameters, numberOfVariables + numberOfParameters);
    solver.coefficientMatrix(Qavg, normalNonZero, Bn);

    for(int l=0; l < numberOfVariables + numberOfParameters; l++) {
      ncp[l] = 0;
      for(int m=0; m < numberOfVariables+ numberOfParameters; m++) {
        ncp[l] += Bn[idx_Bn(m, l)] * (qR[m] - qL[m]);
      }
    }

    for (int i = 0; i < numberOfVariables + numberOfParameters; i++) {
      fR[i] = fR[i] - 0.5 * ncp[i];
      fL[i] = fL[i] + 0.5 * ncp[i];
    }
  }

  return s_max;  // TODO(guera): Use to check if dt was okay in surfaceIntegral
}
#endif

} // namespace c
} // namespace riemansolvers
} // namespace finitevolumes
} // namespace kernels
