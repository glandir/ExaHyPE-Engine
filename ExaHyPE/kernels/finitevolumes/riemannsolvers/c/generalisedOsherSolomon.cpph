/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/
template <bool useNCP, bool useFlux, bool useViscousFlux, int numQuadPoints, typename SolverType>
double kernels::finitevolumes::riemannsolvers::c::generalisedOsherSolomon(
    SolverType& solver,
    double* fnL, double *fnR, const double* qL, const double* qR, int direction) {
  if ( useNCP || useViscousFlux ) {
    std::cerr << "Only implemented for flux(+jacobianMatrix) only PDEs." << std::endl;
    std::terminate();
  }
  
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int numberOfData       = numberOfVariables + numberOfParameters;

  // integrate the Jacobian over the phase space (QL -> QR)
  double osherMatrix[numberOfVariables][numberOfVariables] = {0.0}; // fill with zeroes
  for(int i=0; i<numQuadPoints; i++) {
    const double si  = kernels::gaussLegendreNodes[numQuadPoints-1][i];
    double Qs[numberOfData];
    for(int k=0; k < numberOfData; k++) {
      Qs[k] = qL[k] + si * (qR[k] - qL[k]);
    }
    
    double jacobian[numberOfVariables][numberOfVariables];
    solver.jacobianMatrix(Qs/*in*/, direction, jacobian/*inout*/);    // user solver can work internally with eigen system or eigen solvers; cast rep 
    // compute Osher matrix
    const double wi = kernels::gaussLegendreWeights[numQuadPoints-1][i];
    for(int j=0; j < numberOfVariables; j++) {
      for(int k=0; k < numberOfVariables; k++) {
        osherMatrix[j][k] += wi * std::abs(jacobian[j][k]);
      }
    }
  }
  
  //std::cout << "osherMatrix=" <<std::endl;
  //for(int j=0; j < numberOfVariables; j++) {
  //  for(int k=0; k < numberOfVariables; k++) {
  //    std::cout << std::setprecision(3) << osherMatrix[j][k] << ",";
  //    if ( k == numberOfVariables -1 ) { std::cout << std::endl; }
  //  }
  //}
  
  // TODO(Dominic): Debug
  double sL[numberOfVariables];
  double sR[numberOfVariables];
  solver.eigenvalues(qL, direction, sL);
  solver.eigenvalues(qR, direction, sR);
  double s_max = -1.0;
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sL_i = std::abs(sL[i]);
    s_max = std::max( abs_sL_i, s_max );
  }
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sR_i = std::abs(sR[i]);
    s_max = std::max( abs_sR_i, s_max );
  }
  
  double FL2[DIMENSIONS][numberOfVariables] = {0.0}; // Q: Can we skip this memset?
  double FR2[DIMENSIONS][numberOfVariables] = {0.0};
  double* FL[DIMENSIONS]={FL2[0], FL2[1]};
  double* FR[DIMENSIONS]={FR2[0], FR2[1]};
  if (useFlux && !useViscousFlux) {
    solver.flux(qR, FR);
    solver.flux(qL, FL);
  }
  // fnR[j] = fnR[j] - 0.5 * ( osherMatrix[jk] ) * (qR[k] - qL[k])
  for(int j=0; j < numberOfVariables; j++) {
    fnR[j] = 0.5 * (FR2[direction][j] + FL2[direction][j]);
    for(int k=0; k < numberOfVariables; k++) {
      fnR[j] -= 0.5 * osherMatrix[j][k] * ( qR[k] - qL[k] );
    }
    // fnR[j] -= 0.5 * s_max * ( qR[j] - qL[j] );
    fnL[j] = fnR[j];
  }
  return 1e-11; // to not trigger any assertions
}