/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/
template <bool useNCP, bool useFlux, bool useViscousFlux, int numQuadPoints, typename SolverType>
double kernels::finitevolumes::riemannsolvers::c::generalisedOsherSolomon(
    SolverType& solver,
    double* fnL, double *fnR, const double* qL, 
    const double* qR, int direction) {
  if ( useNCP || useViscousFlux ) {
    std::cerr << "Only implemented for flux(+jacobianMatrix) only PDEs." << std::endl;
    std::terminate();
  }
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int numberOfData       = numberOfVariables + numberOfParameters;

  // integrate the Jacobian over the phase space (QL -> QR)
  double osherMatrix[numberOfVariables][numberOfVariables] = {0.0}; // fill with zeroes
  for(int i=0; i<numQuadPoints; i++) {
    const double si  = kernels::gaussLegendreNodes[numQuadPoints-1][i];
    double Qs[numberOfData];
    for(int j=0; j < numberOfVariables; j++) {
      Qs[j] = qL[j] + si * (qR[j] - qL[j]);
    }
  
    double Ls[numberOfVariables];
    solver.eigenvalues(Qs, direction, Ls);
    double Rs[numberOfVariables][numberOfVariables];
    double iRs[numberOfVariables][numberOfVariables];
    solver.eigenvectors(Qs/*in*/,direction,Rs/*inout*/,iRs/*inout*/);    // user solver can work internally with eigen system or eigen solvers; cast rep
    
  //  #ifdef Asserts 
    double sumOfEntries = 0;
    for(int j=0; j < numberOfVariables; j++) {
      for(int k=0; k < numberOfVariables; k++) {
        for(int a=0; a < numberOfVariables; a++) {
          sumOfEntries += iRs[j][a] * Rs[a][k];
        }
      }
    }
    if ( sumOfEntries < numberOfVariables - 1e-12 || sumOfEntries > numberOfVariables + 1e-12 ) {
      std::cerr << "Error: Left eigenvector matrix is not an inverse of the right one as sum of entries="<<sumOfEntries << "; direction="<<direction << std::endl;
      std::terminate();
    }
   // #endif
    
    // compute Osher matrix
    const double wi = kernels::gaussLegendreWeights[numQuadPoints-1][i];
    for(int j=0; j < numberOfVariables; j++) {
      for(int k=0; k < numberOfVariables; k++) {
        for(int a=0; a < numberOfVariables; a++) {
          osherMatrix[j][k] += wi * iRs[j][a]*std::abs(Ls[a])*Rs[a][k];
        }
      }
    }
  }
  
  
  
  // TODO(Dominic): Debug
  double sL[numberOfVariables];
  double sR[numberOfVariables];
  solver.eigenvalues(qL, direction, sL);
  solver.eigenvalues(qR, direction, sR);
  double s_max = -1.0;
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sL_i = std::abs(sL[i]);
    s_max = std::max( abs_sL_i, s_max );
  }
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sR_i = std::abs(sR[i]);
    s_max = std::max( abs_sR_i, s_max );
  }
  
  double FL2[DIMENSIONS][numberOfVariables] = {0.0}; // Q: Can we skip this memset?
  double FR2[DIMENSIONS][numberOfVariables] = {0.0};
  #if DIMENSIONS==3
  double* FL[DIMENSIONS]={FL2[0], FL2[1], FL2[2]};
  double* FR[DIMENSIONS]={FR2[0], FR2[1], FR2[2]};
  #else
  double* FL[DIMENSIONS]={FL2[0], FL2[1]};
  double* FR[DIMENSIONS]={FR2[0], FR2[1]};
  #endif
  if (useFlux && !useViscousFlux) {
    solver.flux(qR, FR);
    solver.flux(qL, FL);
  }
  // fnR[j] = fnR[j] - 0.5 * ( osherMatrix[jk] ) * (qR[k] - qL[k])
  for(int i=0; i < numberOfVariables; i++) {
    fnR[i] = 0.5 * (FR2[direction][i] + FL2[direction][i]);
    for(int j=0; j < numberOfVariables; j++) {
      fnR[i] -= 0.5 * osherMatrix[i][j] * ( qR[j] - qL[j] );
    }
    fnL[i] = fnR[i];
  }
  return s_max;
}