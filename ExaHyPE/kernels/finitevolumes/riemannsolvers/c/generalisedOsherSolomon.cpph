/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/
template <bool useNCP, bool useFlux, bool useViscousFlux, int numQuadPoints, typename SolverType>
double kernels::finitevolumes::riemannsolvers::c::generalisedOsherSolomon(
    SolverType& solver,
    double* fnL, double *fnR, const double* qL, const double* qR, int normalNonZero) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int numberOfData       = numberOfVariables + numberOfParameters;

  // fnR2 = fnL2 = 0.5 * (FR-FL)
  double fnL2[numberOfVariables];
  double fnR2[numberOfVariables];
  for(int k=0; k < numberOfVariables; k++) {
    fnR2[k] = 0.5 * fnR[k];
  }
  for(int k=0; k < numberOfVariables; k++) {
    fnR2[k] -= 0.5 * fnL[k];
  }
  // integrate the Jacobian over the phase space (QL -> QR)
  double Qs[numberOfData];
  double jacobian[numberOfVariables*numberOfVariables];
  double absJacobian[numberOfVariables*numberOfVariables] = {0.0}; // fill with zeroes
  for(int i=0; i<numQuadPoints; i++) {
    // Qs[k] = ql[k] + si * (qr[k] - qL[k]);
    const double si  = kernels::gaussLegendreNodes[numQuadPoints-1][i];
    const double msi = 1.0-si;
    for(int k=0; k < numberOfData; k++) {
      Qs[k] = msi * ql[k];
    }
    for(int k=0; k < numberOfData; k++) {
      Qs[k] = si  * qr[k];
    }
    solver.jacobian(Qs/*in*/, jacobian/*inout*/); // user solver can work internally with eigen system or eigen solvers

    // absJ = sum_i wi * |A(Qs)|
    const double wi  = kernels::gaussLegendreWeights[numQuadPoints-1][i];
    for (int jk=0; jk<numberOfVariables*numberOfVariables; jk++) {
      absJacobian[jk] += wi * std::abs(jacobian[jk]);
    }
  }

  //  fnR2[j] = fnR2[j] - 0.5 * ( absJ[jk] ) * (qR[k] - qL[k])
  double dQ[numberOfVariables];
  for(int k=0; k < numberOfVariables; k++) {
    dQ[k] = qR[k] - qL[k];
  }
  for(int j=0; j < numberOfVariables; j++) {
    double product = 0;
    for(int k=0; k < numberOfVariables; k++) {
      const int jk = j*numberOfVariables + k;
      product += absJacobian[jk] * dQ[k];
    }
    fnR2[j] -= 0.5 * product;
  }
  std::copy_n(fnR2,numberOfVariables,fnL2);
  return 0.0;
}
