/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/
template <bool useNCP, bool useFlux, bool useViscousFlux, int numQuadPoints, typename SolverType>
double kernels::finitevolumes::riemannsolvers::c::generalisedOsherSolomon(
    SolverType& solver,
    double* fnL, double *fnR, const double* qL, 
    const double* qR, int direction) {
  if ( useNCP || useViscousFlux ) {
    std::cerr << "Only implemented for flux(+jacobianMatrix) only PDEs." << std::endl;
    std::terminate();
  }
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int numberOfData       = numberOfVariables + numberOfParameters;

  // integrate the Jacobian over the phase space (QL -> QR)
  double s_max = -1.0;
  double osherMatrix[numberOfVariables][numberOfVariables] = {0.0}; // fill with zeroes
  for(int i=0; i<numQuadPoints; i++) {
    const double si  = kernels::gaussLegendreNodes[numQuadPoints-1][i];
    double Qs[numberOfData];
    for(int j=0; j < numberOfVariables; j++) {
      Qs[j] = qL[j] + si * (qR[j] - qL[j]);
    }

    // eigenstructure
    double Ls[numberOfVariables];                            // all eigenvalues need to be set by user
    double Rs[numberOfVariables][numberOfVariables] = {0.0}; // fill with zeros as user typically performs rotation via matrix product
    double iRs[numberOfVariables][numberOfVariables]= {0.0};
    solver.eigenvectors(Qs/*in*/,direction,Rs/*inout*/,Ls/*inout*/,iRs/*inout*/);    // user solver can work internally with eigen system or eigen solvers;
    for (int j = 0; j < numberOfVariables; j++) {
      s_max = std::max( std::abs(Ls[j]), s_max );
    }
    
    #ifdef Asserts
    double sumOfEntries = 0;
    for(int j=0; j < numberOfVariables; j++) {
      for(int k=0; k < numberOfVariables; k++) {
        for(int a=0; a < numberOfVariables; a++) {
          sumOfEntries += iRs[j][a] * Rs[a][k];
        }
      }
    }
    if ( sumOfEntries < numberOfVariables - 1e-12 || sumOfEntries > numberOfVariables + 1e-12 ) {
      std::cerr << "Error: Left eigenvector matrix is not an inverse of the right one as sum of entries="<<sumOfEntries << "; direction="<<direction << std::endl;
      std::terminate();
    }
    #endif
    
    // compute Osher matrix
    // scale column vectors: (|L1|*col1,|L2|*col2,...)
    const double wi = kernels::gaussLegendreWeights[numQuadPoints-1][i];
    for(int j=0; j < numberOfVariables; j++) {
      for(int k=0; k < numberOfVariables; k++) {
        for(int a=0; a < numberOfVariables; a++) {
          osherMatrix[j][k] += wi * Rs[j][a]*std::abs(Ls[a])*iRs[a][k];
        }
      }
    }
  }
  
  double FL2[DIMENSIONS][numberOfVariables] = {0.0}; // Q: Can we skip this memset?
  double FR2[DIMENSIONS][numberOfVariables] = {0.0};
  #if DIMENSIONS==3
  double* FL[DIMENSIONS]={FL2[0], FL2[1], FL2[2]};
  double* FR[DIMENSIONS]={FR2[0], FR2[1], FR2[2]};
  #else
  double* FL[DIMENSIONS]={FL2[0], FL2[1]};
  double* FR[DIMENSIONS]={FR2[0], FR2[1]};
  #endif
  if (useFlux && !useViscousFlux) {
    solver.flux(qR, FR);
    solver.flux(qL, FL);
  }
  // fnR[j] = fnR[j] - 0.5 * ( osherMatrix[jk] ) * (qR[k] - qL[k])
  for(int i=0; i < numberOfVariables; i++) {
    fnR[i] = 0.5 * (FR2[direction][i] + FL2[direction][i]);
    for(int j=0; j < numberOfVariables; j++) {
      fnR[i] -= 0.5 * osherMatrix[i][j] * ( qR[j] - qL[j] );
    }
    fnL[i] = fnR[i];
  }
  return s_max;
}
