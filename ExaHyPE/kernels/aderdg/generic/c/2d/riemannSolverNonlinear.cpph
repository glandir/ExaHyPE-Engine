/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

// included in ../../Kernels.h

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstring>

#include "../../../../KernelUtils.h"

namespace kernels {
namespace aderdg {
namespace generic {
namespace c {

/**
 * We need to consider material parameters
 * in QL and QR,tempStateSizedVectors,tempFaceUnknownsArray
 * We don't need to consider material parameters
 * in FL,FR,tempStateSizedSquareMatrices,
 */
template <bool useCoefficientMatrix, typename SolverType>
void riemannSolverNonlinear(SolverType& solver, double* FL, double* FR,
                            const double* const QL,
                            const double* const QR,
                            double*  tempFaceUnknownsArray,
                            double** tempStateSizedVectors,
                            double** tempStateSizedSquareMatrices,
                            const double dt,
                            const int normalNonZero) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int numberOfData       = numberOfVariables+numberOfParameters;
  constexpr int order              = SolverType::Order;
  constexpr int basisSize          = order+1;

  // Compute the average variables and parameters from the left and the right
  double QavL[numberOfData] = {0.0}; // ~(numberOfVariables+numberOfParameters)
  double QavR[numberOfData] = {0.0}; // ~(numberOfVariables+numberOfParameters)
  {
    idx2 idx_QLR(basisSize, numberOfVariables+numberOfParameters);
    for (int j = 0; j < basisSize; j++) {
      const double weight = kernels::gaussLegendreWeights[order][j];

      for (int k = 0; k < numberOfVariables+numberOfParameters; k++) {
        QavL[k] += weight * QL[idx_QLR(j, k)];
        QavR[k] += weight * QR[idx_QLR(j, k)];
      }
    }
  }

  double LL[numberOfVariables] = {0.0}; // do not need to store material parameters
  double LR[numberOfVariables] = {0.0};
  solver.eigenvalues(QavL, normalNonZero, LL);
  solver.eigenvalues(QavR, normalNonZero, LR);
  
  double Qavg[numberOfData] = {0.0}; // ~(numberOfVariables+numberOfParameters)
  for(int k=0; k < numberOfVariables+numberOfParameters; k++) {
     Qavg[k] = (QavL[k] + QavR[k]) / 2;
  }

  // Here, we implement a very simple Rusanov scheme with scalar dissipation
  // (smax*Id).
  // We can change this into a more sophisticated Osher or HLLEM Riemann solver
  // whenever needed!
  // skip parameters
  std::transform(LL, LL + numberOfVariables, LL,
                 std::abs<double>);
  std::transform(LR, LR + numberOfVariables, LR,
                 std::abs<double>);
  const double* smax_L =
      std::max_element(LL, LL + numberOfVariables);
  const double* smax_R =
      std::max_element(LR, LR + numberOfVariables);
  const double smax = std::max(*smax_L, *smax_R);
  
  // NCP: Still has to be moved to the new NCP2 interface

  double Bn[numberOfVariables][numberOfVariables] = {0.0};
  double ncp[numberOfVariables] = {0.0};
  idx2 idx_Bn(numberOfVariables, numberOfVariables);
  if(useCoefficientMatrix) {
    solver.coefficientMatrix(Qavg, normalNonZero, Bn); // Bn is nVar x nVar matrix
  }

  // We now compute the numerical flux. Note that the scheme is at the moment
  // written in CONSERVATION FORM => no fluctuations, but real fluxes. Later,
  // this will be converted into the left and right fluctuations.
  
  //printf("dt = %f\n", dt); // extract dt

  {
    idx2 idx_FLR(basisSize, numberOfVariables);
    idx2 idx_QLR(basisSize, numberOfVariables+numberOfParameters);
    for (int j = 0; j < basisSize; j++) {
      
      if(useCoefficientMatrix) {
        // matmul(Bn, lQbndR(:,j,k) - lQbndL(:,j,k))
        for(int l=0; l < numberOfVariables; l++) {
          ncp[l] = 0;
          for(int m=0; m < numberOfVariables; m++) {
           // BUG resolved: Fortran <-> C matrix access
           ncp[l] += Bn[idx_Bn(m, l)] * (QR[idx_QLR(j, m)] - QL[idx_QLR(j, m)]);
          }
          // printf("QR[%d, %d] = %.20e\n", j, l, QR[idx_QLR(j, l)]);
          // printf("QL[%d, %d] = %.20e\n", j, l, QL[idx_QLR(j, l)]);
          // printf("ncp[%d]=%.20e\n", l, ncp[l]);
        }
      }
      

      // (x,y) location in Q
      /*
      int posx = 20;
      int posy = 21;
      double xdeb = 3.703704e-02;
      double ydeb = 2.571550e-03;
      bool debug = false;
      if(debug) printf("An position %e, %e:\n", xdeb, ydeb);
      if(abs(QL[posx]-xdeb) < 1e-6 && abs(QL[posy] - ydeb) < 1e-6) {
	for(int l=0; l < numberOfVariables; l++) {
	      //for(int m=0; m < numberOfVariables; m++) {
	     int m=0;
	      //printf("Bn(m=%d, l=%d) = %.20e\n", m, l, Bn[idx_Bn(m, l)]);
	     if(debug) printf("Qavg[%d] = %.20e\n", l, Qavg[l]);
	      //}
	}
      }
      */

      // skip parameters
      for (int k = 0; k < numberOfVariables; k++) {
        FL[idx_FLR(j, k)] =
            0.5 * (FR[idx_FLR(j, k)] + FL[idx_FLR(j, k)]) -
            0.5 * smax * (QR[idx_QLR(j, k)] - QL[idx_QLR(j, k)]);
        if(useCoefficientMatrix) {
          FR[idx_FLR(j, k)] = FL[idx_FLR(j, k)] - 0.5 * ncp[k];
          FL[idx_FLR(j, k)] = FL[idx_FLR(j, k)] + 0.5 * ncp[k];
        } else {
          FR[idx_FLR(j, k)] = FL[idx_FLR(j, k)];
        }
        
        //if(0) printf("QL[..]-QR = %f - %f\n", QL[idx_QLR(j, k)], QR[idx_QLR(j, k)]);
      }
      
 /*
      int mcheck = 6; // K11
     if(debug) printf("Riemann j=%d m=%d: (x,y)=(%e,%e) ncp=%e QL=%e QR=%e FL=%e FR=%e, normal=%d\n",
	     j, mcheck,
	     QL[posx], QL[posy],
	     ncp[mcheck],
	     QL[idx_FQLR(j, mcheck)], QR[idx_FQLR(j, mcheck)],
	     FL[idx_FQLR(j, mcheck)], FR[idx_FQLR(j, mcheck)],
	     normalNonZero
      );
     */
    }
  }

}

}  // namespace c
}  // namespace generic
}  // namespace aderdg
}  // namespace kernels
