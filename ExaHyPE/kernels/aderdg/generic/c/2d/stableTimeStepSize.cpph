/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon 
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/
 
// #include "kernels/aderdg/generic/Kernels.h"

// #include "string.h"

// #include "tarch/la/Scalar.h"
// #include "tarch/la/ScalarOperations.h"

// #include "kernels/GaussLegendreQuadrature.h"
// #include "kernels/DGMatrices.h"

#ifndef EXAHYPE_CFL_FACTOR
// Sven, addressing issue #100:
// Set CFL factor with compiler option like -DEXAHYPE_CFL_FACTOR=0.3
#define EXAHYPE_CFL_FACTOR 0.9 // TODO(Dominic): Move into solver
#endif

// #include <fstream>

// using std::endl;
// using std::cout;

template <typename SolverType>
double kernels::aderdg::generic::c::stableTimeStepSize(
    SolverType& solver,
    const double* const luh,
    double* lambda,
    const tarch::la::Vector<DIMENSIONS, double>& dx) {
  constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  constexpr int numberOfParameters = SolverType::NumberOfParameters;
  constexpr int basisSize          = SolverType::Order+1;
  constexpr double PNPM[10]        = {1.0,   0.33,  0.17, 0.1,  0.069,
                                      0.045, 0.038, 0.03, 0.02, 0.015};

  idx3 idx_luh(basisSize, basisSize, numberOfVariables+numberOfParameters); // idx_luh(y,x,nVar)
  
  double dt = std::numeric_limits<double>::max();
  for (int i = 0; i < basisSize; i++) {
    for (int j = 0; j < basisSize; j++) {
      // !!
      // TODO(Dominic): For refactoring purposes. Remove old indexing method.
      const int nodeIndex = i + basisSize * j;
      const int dofStartIndex = nodeIndex * (numberOfVariables+numberOfParameters);
      assertion(dofStartIndex==idx_luh(j,i,0));
      // !!

      double denominator = 0.0;
      for (int d = 0; d < DIMENSIONS; d++) {
        solver.eigenvalues(&luh[idx_luh(i,j,0)], d, lambda);

        double maxEigenvalue = 0.0;
        for (int ivar = 0; ivar < numberOfVariables; ivar++) {
          maxEigenvalue = std::max(fabs(lambda[ivar]), maxEigenvalue);
        }
        denominator += maxEigenvalue / dx[d];
      }

      dt = std::min(dt, EXAHYPE_CFL_FACTOR * PNPM[basisSize - 1] / // TODO(Dominic): Move CFL_Factor into solver.
                            denominator);  // order N = basisSize-1
    }
  }

  // std::cout << "-----------------------------------" << std::endl;
  // std::cout << dt << std::endl;
  // std::cout << "-----------------------------------" << std::endl;
  return dt;
}
