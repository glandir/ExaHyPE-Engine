/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon 
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/
 
// #include "kernels/aderdg/generic/Kernels.h"

// #include "string.h"

// #include "tarch/la/Scalar.h"
// #include "tarch/la/ScalarOperations.h"

// #include "kernels/GaussLegendreQuadrature.h"
// #include "kernels/DGMatrices.h"

// #define EXAHYPE_CFL_FACTOR 0.9

// #include <fstream>

// using std::endl;
// using std::cout;

extern "C" {
void aderspacetimepredictorlinear_(double* lqhi, double* lFhi, double* lQbnd,
                                   double* lFbnd, double* luh, double* dt,
                                   double* dx);
}

template <typename SolverType>
void kernels::aderdg::generic::fortran::spaceTimePredictorLinear(
    SolverType& solver,
    double*  lQbnd, double* lFbnd,
    double** tempSpaceTimeUnknowns,
    double** tempSpaceTimeFluxUnknowns,
    double*  tempUnknowns,
    double*  tempFluxUnknowns,
    double*  tempStateSizedVector,
    const double* const luh,
    const tarch::la::Vector<DIMENSIONS, double>& dx,
    const double dt){

    /* TODO: Don't really understand luhTemp. Should ask !! */
    double* luhTemp =
     new double[numberOfVariables * basisSize * basisSize * basisSize];
      for (int i = 0;
        i < numberOfVariables * basisSize * basisSize * basisSize;
        i++){
      luhTemp[i] =  luh[i]; }
     
   //memcpy(luhTemp, luh, numberOfVariables * basisSize * basisSize * basisSize *
   //                         sizeof(double));

   double* lFhiFortran = new double[numberOfVariables * DIMENSIONS * basisSize *
                                    basisSize * basisSize];
   for (int i = 0;
        i < numberOfVariables * DIMENSIONS * basisSize * basisSize * basisSize;
        i++){
     lFhiFortran[i] = lFhi[i]; } //-123.45;

   double* dtTemp = new double[1];
   dtTemp[0] =  dt;

  double* dxTemp = new double[3];
  dxTemp[0] = dx[0];
  dxTemp[1] = dx[1];
  dxTemp[2] = dx[2];

   double* lFbndFortran =
       new double[numberOfVariables * 6 * basisSize * basisSize];
   for (int i = 0; i < numberOfVariables * 6 * basisSize * basisSize; i++) {
     lFbndFortran[i] =  lFbnd[i]; //-123.45;
   }

   double* lQbndFortran =
       new double[numberOfVariables * 6 * basisSize * basisSize];
   for (int i = 0; i < numberOfVariables * 6 * basisSize * basisSize; i++) {
     lQbndFortran[i] =  lQbnd[i]; //-123.45;
   }

   //aderspacetimepredictorlinear_(lQhi, lFhiFortran, lQbndFortran, lFbndFortran,
   //                             luhTemp, dtTemp, dxTemp);

  aderspacetimepredictorlinear_(lQhi, lFhi, lQbnd, lFbnd,
                                luh, dtTemp, dxTemp);			

  // // Permutation of lFhi
  // for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
    // for (int jj = 0; jj < basisSize; jj++) {
      // for (int kk = 0; kk < basisSize; kk++) {
        // for (int ivar = 0; ivar < numberOfVariables; ivar++) {
          // for (int dim = 0; dim < DIMENSIONS; dim++) {
            // lFhi[p2f5(ivar, dim, ii, jj, kk)] =
                // lFhiFortran[f2p5(ivar, dim, ii, jj, kk)];
          // }
        // }
      // }
    // }
  // }

  // // Permutation of lFbnd

  // // for(int i=0; i < numberOfVariables*6*basisSize*basisSize; i++){
  // // lFbndFortran[i] = i;
  // // }

  // for (int bb = 0; bb < basisSize; bb++) {  // loop over dof
    // for (int aa = 0; aa < basisSize; aa++) {
      // for (int ivar = 0; ivar < numberOfVariables; ivar++) {
        // for (int face = 0; face < 6; face++) {
          // lFbnd[p2f4(ivar, face, aa, bb)] =
              // lFbndFortran[f2p4(ivar, face, aa, bb)];
        // }
      // }
    // }
  // }

  // // Permutation of lQbnd

  // // for(int i=0; i < numberOfVariables*6*basisSize*basisSize; i++){
  // // lFbndFortran[i] = i;
  // // }

  // for (int bb = 0; bb < basisSize; bb++) {  // loop over dof
    // for (int aa = 0; aa < basisSize; aa++) {
      // for (int ivar = 0; ivar < numberOfVariables; ivar++) {
        // for (int face = 0; face < 6; face++) {
          // lQbnd[p2f4(ivar, face, aa, bb)] =
              // lQbndFortran[f2p4(ivar, face, aa, bb)];
        // }
      // }
    // }
  // }

   delete[] luhTemp;
   delete[] lFhiFortran;
   delete[] lFbndFortran;
   delete[] lQbndFortran;
   delete[] dxTemp;
   delete dtTemp;

  // // std::ofstream ofs;
  // // ofs.open ("aoutput_lQbnd.txt", std::ofstream::out);
  // // for (int ii=0; ii<numberOfVariables*6*basisSize*basisSize; ii++) {
  // // ofs << lQbnd[ii] << "\n";
  // // }
  // // ofs.close();

  // // ofs.open ("aoutput_lQbndFortran.txt", std::ofstream::out);
  // // for (int ii=0; ii<numberOfVariables*6*basisSize*basisSize; ii++) {
  // // ofs << lQbndFortran[ii] << "\n";
  // // }
  // // ofs.close();
}
