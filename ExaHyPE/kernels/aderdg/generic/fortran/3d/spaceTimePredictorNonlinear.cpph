/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon 
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

extern "C" {
void aderpicardloopnonlinear_(const double* const luh,
			      const double* const dt,
			      const double* const dx,
                              double *lQi, double *lFi);
// void aderpredictor_(double *lQi, double *lFi, double *lQhi, double *lFhi);
void aderpredictornonlinear_(double *lQi, double *lFi_x, double *lFhi_y,
                             double *lFhi_z, double* lShi, double *lQhi, double *lFhi);
// void aderextrapolator_(double *lQhi, double *lFhi, double *lQbnd, double
// *lFbnd);
void aderextrapolatornonlinear_(double *lQhi, double *lFhi_x, double *lFhi_y,
                                double *lFhi_z, double *lQbnd, double *lFbnd);
}

// template <void PDEFlux3d(const double *const Q, double **F),
          // void PDESource(const double* const Q, double* S)>
// void kernels::aderdg::generic::fortran::spaceTimePredictorNonlinear(
    // double *lQi, double *lFi, double *lQhi, double *lFhi, double *lQbnd,
    // double *lFbnd, const double *const luh,
    // const tarch::la::Vector<DIMENSIONS, double> &dx, const double dt,
    // const int numberOfVariables, const int numberOfParameters, const int basisSize) {
template <typename SolverType>
void kernels::aderdg::generic::fortran::spaceTimePredictorNonlinear(
    SolverType& solver,
    double*  lQbnd, double* lFbnd,
    double** tempSpaceTimeUnknowns,
    double** tempSpaceTimeFluxUnknowns,
    double*  tempUnknowns,
    double*  tempFluxUnknowns,
    double*  tempStateSizedVector,
    const double* const luh,
    const tarch::la::Vector<DIMENSIONS, double>& dx,
    const double dt,
    double* tempPointForceSources //Not used, should be nullptr
    ){
  // circumvent 'const double'
  // double *luhTemp =
      // new double[numberOfVariables * basisSize * basisSize * basisSize];
  // memcpy(luhTemp, luh, numberOfVariables * basisSize * basisSize * basisSize *
                           // sizeof(double));
  const int numberOfVariables  = solver.getNumberOfVariables();
  const int numberOfParameters = solver.getNumberOfParameters();
  const int basisSize          = solver.getNodesPerCoordinateAxis();
  const int numSpaceDof        = numberOfVariables * basisSize * basisSize * basisSize;
  
  double* lQi  = tempSpaceTimeUnknowns[0];
  double* lFi  = tempSpaceTimeFluxUnknowns[0];
  double* lQhi = tempUnknowns;
  double* lFhi = tempFluxUnknowns;

  /*
  double dtTemp[1];
  dtTemp[0] = dt;

  double dxTemp[3];
  dxTemp[0] = dx[0];
  dxTemp[1] = dx[1];
  dxTemp[2] = dx[2];
  */

  // space-time predictor:
  /*
  double *luhFortran =
        new double[numberOfVariables * basisSize * basisSize * basisSize];
  idx4 idx_luh(basisSize, basisSize, basisSize, numberOfVariables+numberOfParameters);
  idx4 idx_lduh(basisSize, basisSize, basisSize, numberOfVariables);
  for (int i = 0; i < basisSize; ++i) {
    for (int j = 0; j < basisSize; ++j) {
      for (int k = 0; k < basisSize; ++k) {
        for (int l = 0; l < numberOfVariables; ++l) {
          luhFortran[idx_lduh(i,j,k,l)] = luh[idx_luh(i,j,k,l)];
        }
      }
    }
  }*/
  
  aderpicardloopnonlinear_(luh, &dt, dx.data(), lQi, lFi);

  // std::cout << "numSpaceDof: " << numSpaceDof << std::endl;
  // lFhi = [ lFhi_x | lFhi_y | lFhi_z ]
  // aderpredictor_(lQi,lFi,lQhi,lFhi);
  aderpredictornonlinear_(lQi, lFi, lQhi, 
			  &lFhi[0 * numSpaceDof], // lFhi_x
                          &lFhi[1 * numSpaceDof], // lFhi_y
			  &lFhi[2 * numSpaceDof], // lFhi_z
			  &lFhi[3 * numSpaceDof]  // lShi
 			);
  // aderextrapolator_(lQhi,lFhi,lQbnd,lFbnd);
  aderextrapolatornonlinear_(lQhi, 
			     &lFhi[0 * numSpaceDof],
                             &lFhi[1 * numSpaceDof], 
			     &lFhi[2 * numSpaceDof],
                             lQbnd, lFbnd);

   //delete[] luhFortran;

  // std::ofstream ofs;
  // ofs.open ("aoutput_lQbnd.txt", std::ofstream::out);
  // for (int ii=0; ii<numberOfVariables*6*basisSize*basisSize; ii++) {
  // ofs << lQbnd[ii] << "\n";
  // }
  // ofs.close();

  // ofs.open ("aoutput_lQbndFortran.txt", std::ofstream::out);
  // for (int ii=0; ii<numberOfVariables*6*basisSize*basisSize; ii++) {
  // ofs << lQbndFortran[ii] << "\n";
  // }
  // ofs.close();
}
