package eu.exahype;


import java.io.IOException;

import eu.exahype.analysis.DepthFirstAdapter;
import eu.exahype.node.AAderdgSolver;
import eu.exahype.node.AProject;
import eu.exahype.node.ATwoDimensionalComputationalDomain;
import eu.exahype.node.AThreeDimensionalComputationalDomain;


public class CreateSolverClasses extends DepthFirstAdapter {

  public Boolean valid = true;

  private DirectoryAndPathChecker   _directoryAndPathChecker;
  
  private String                    _projectName;
  
  private int                       _dimensions;
  

  public CreateSolverClasses(DirectoryAndPathChecker  directoryAndPathChecker) {
	_directoryAndPathChecker = directoryAndPathChecker;
  }

  @Override
  public void inAProject(AProject node) {
	_projectName = node.getName().toString().trim();
	
    if (node.getSolver().size()==0) { 
      System.out.println( "there are no solvers in the specification file ... nothing to be done" );      
    }
  }
  

  @Override
  public void inATwoDimensionalComputationalDomain(ATwoDimensionalComputationalDomain node) {
    _dimensions = 2;
  }
  
  
  @Override
  public void inAThreeDimensionalComputationalDomain(AThreeDimensionalComputationalDomain node) {
    _dimensions = 3;
  }
  
  
  private void writeHeader(String solverName) {
	java.io.File file = new java.io.File(_directoryAndPathChecker.outputDirectory.getAbsolutePath() + "/" + solverName + ".h");
	
	if (file.exists()) {
      System.out.println( "create header of solver " + solverName + " ... header does exist already. Remove to allow toolkit to regenerate it (changes will be lost)" );      
      return;
	}
	
	try {

	  java.io.BufferedWriter headerWriter = new java.io.BufferedWriter(new java.io.FileWriter(
		file
	  ));

	  headerWriter.write("// This file is generated by the ExaHyPE toolkit.\n");
	  headerWriter.write("// Please do not modify - it will be overwritten by the next\n");
	  headerWriter.write("// ExaHyPE toolkit call.\n");
	  headerWriter.write("// \n");
	  headerWriter.write("// ========================\n");
	  headerWriter.write("//   www.exahype.eu\n");
	  headerWriter.write("// ========================\n");

	  headerWriter.write("\n\n\n");
	  headerWriter.write("#include \"exahype/solvers/Solver.h\"");
      headerWriter.write("\n\n\n");
	  
	  headerWriter.write("namespace " + _projectName + "{\n");
	  headerWriter.write("  class " + solverName + ";\n");
	  headerWriter.write("}\n\n\n");
	  
	  headerWriter.write("class " + _projectName + "::" + solverName + ": public exahype::solvers::Solver {\n");
	  headerWriter.write("  public:\n");
	  headerWriter.write("    " + solverName + "(int kernelNumber); \n");
	  headerWriter.write("    virtual int getMinimumTreeDepth() const;\n");
	  
	  if (_dimensions==2) {
        headerWriter.write("    virtual void spaceTimePredictor( double * lQi, double * lFi, const double * const luh, double * lQhi, double * lFhi, double * lQhbnd, double * lFhbnd, const tarch::la::Vector<DIMENSIONS,double>& x, const double dt ); \n");
	  }
	  else {
        headerWriter.write("ERROR\n");
	  }
	  
	  headerWriter.write("};\n\n\n");

	  
	  headerWriter.close();

      System.out.println( "create header of solver " + solverName + " ... ok" );      
    } 
	catch (Exception exc) {
      System.err.println( "ERROR: " + exc.toString() );
	  valid = false;
	}
  }

  
  
  @Override
  public void inAAderdgSolver(AAderdgSolver node) {
	String solverName = node.getName().toString().trim();
	writeHeader(solverName);

	java.io.File file = new java.io.File(_directoryAndPathChecker.outputDirectory.getAbsolutePath() + "/" + solverName + ".cpp");
	
	if (file.exists()) {
      System.out.println( "create header of solver " + solverName + " ... header does exist already. Remove to allow toolkit to regenerate it (changes will be lost)" );      
      return;
	}

	try {
	  java.io.BufferedWriter cppWriter = new java.io.BufferedWriter(new java.io.FileWriter(file));
	  
      cppWriter.write("#include \"" + solverName + ".h\"\n");

      cppWriter.write("\n\n\n");
      writeImplementationForUserFluxes(node, solverName, cppWriter);

      cppWriter.write("\n\n\n");
      cppWriter.write("// =============================================\n");
      cppWriter.write("// Please adopt the routines below to your needs\n");
      cppWriter.write("// =============================---=============\n");
      cppWriter.write(_projectName + "::" + solverName + "::" + solverName + "( int kernelNumber):\n");
      cppWriter.write("  exahype::solvers::Solver(\"" + solverName + "\",exahype::solvers::Solver::ADER_DG,kernelNumber," + node.getVariables().toString().trim() + "," + node.getOrder().toString().trim() + "+1) {\n");
      cppWriter.write("  // @todo Please implement/augment if required\n");
      cppWriter.write("}\n");
      cppWriter.write("\n\n\n");
      cppWriter.write("int " + _projectName + "::" + solverName + "::getMinimumTreeDepth() const {\n");
      cppWriter.write("  // @todo Please implement\n");
      cppWriter.write("  return 3;\n");
      cppWriter.write("}\n");

      cppWriter.close();
      System.out.println( "create implementation template of solver " + solverName + " ... please implement dummy operations in cpp file" );      
    } 
	catch (Exception exc) {
      System.err.println( "ERROR: " + exc.toString() );
	  valid = false;
	}
  }

  private void writeImplementationForUserFluxes(
	AAderdgSolver node,
	String solverName, java.io.BufferedWriter cppWriter
  ) throws IOException {
    cppWriter.write( "#include \"kernels/aderdg/generic/Kernels.h\"\n\n\n");
    cppWriter.write( "void " + _projectName + "::" + solverName + "::spaceTimePredictor( double * lQi, double * lFi, const double * const luh, double * lQhi, double * lFhi, double * lQhbnd, double * lFhbnd, const tarch::la::Vector<DIMENSIONS,double>& x, const double dt ) {\n");
    cppWriter.write("}\n");
  }
}
