package eu.exahype.solvers;

import java.io.IOException;

public class Helpers {
  public static void writeMinimalADERDGSolverHeader(
      String solverName, java.io.BufferedWriter writer, String projectName) throws IOException {
    writeHeaderCopyright(writer);
    writeHeaderIncludesAndDefines(writer, solverName, projectName);
    writeHeaderMinimalADERDGClassSignature(writer, solverName, projectName);
  }

  /**
   * Creates all the public operations that are mandatory for any solver.
   */
  private static void writeHeaderMinimalADERDGClassSignature(
      java.io.BufferedWriter writer, String solverName, String projectName) throws IOException {
    writer.write(
        "class " + projectName + "::" + solverName + ": public exahype::solvers::Solver {\n");
    writer.write("  public:\n");
    writer.write("    " + solverName + "(int kernelNumber); \n");
    writer.write("    virtual int getMinimumTreeDepth() const;\n");

    writer.write(
        "    virtual void spaceTimePredictor(double* lQi, double* lFi, double* lQhi, double* lFhi, double* lQhbnd, double* lFhbnd, const double* const luh, const tarch::la::Vector<DIMENSIONS,double>& dx, const double dt ); \n");
    writer.write(
        "    virtual void solutionUpdate(double* luh, const double* const lduh, const double dt);\n");
    writer.write(
        "    virtual void volumeIntegral(double* lduh, const double* const lFhi, const tarch::la::Vector<DIMENSIONS,double>& dx);\n");
    writer.write(
        "    virtual void surfaceIntegral(double* lduh, const double* const lFhbnd, const tarch::la::Vector<DIMENSIONS,double>& dx);\n");
    writer.write(
        "    virtual void riemannSolver(double* FL, double* FR, const double* const QL, const double* const QR, const double dt, const int normalNonZeroIndex);\n");
    writer.write(
        "    virtual double stableTimeStepSize(const double* const luh, const tarch::la::Vector<DIMENSIONS,double>& dx );\n");

    writer.write(
        "    virtual void solutionAdjustment(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt);\n");
    writer.write(
        "    virtual bool hasToAdjustSolution(const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t);\n");
  }

  /**
   * Write header with ExaHyPE copyright. Should be inserted for any solver's
   * header.
   */
  private static void writeHeaderCopyright(java.io.BufferedWriter writer) throws IOException {
    writer.write("// This file is generated by the ExaHyPE toolkit.\n");
    writer.write("// Please do not modify - it will be overwritten by the next\n");
    writer.write("// ExaHyPE toolkit call.\n");
    writer.write("// \n");
    writer.write("// ========================\n");
    writer.write("//   www.exahype.eu\n");
    writer.write("// ========================\n");
  }

  /**
   * Adds all the default includes of any solver as well as the solver define.
   * Is used by all solvers.
   */
  private static void writeHeaderIncludesAndDefines(
      java.io.BufferedWriter writer, String solverName, String projectName) throws IOException {
    writer.write("\n\n\n");
    writer.write("#include \"exahype/solvers/Solver.h\"");
    writer.write("\n\n\n");

    writer.write("namespace " + projectName + "{\n");
    writer.write("  class " + solverName + ";\n");
    writer.write("}\n\n\n");
  }

  public static void writeMinimalADERDGSolverUserImplementation(String solverName,
      java.io.BufferedWriter writer, String projectName, int numberOfUnknowns, int numberOfParameters, int order)
      throws IOException {
    writer.write("#include \"" + solverName + ".h\"\n");
    writer.write("\n\n\n");
    writer.write(projectName + "::" + solverName + "::" + solverName + "( int kernelNumber):\n");
    writer.write("  exahype::solvers::Solver(\"" + solverName
        + "\",exahype::solvers::Solver::ADER_DG,kernelNumber," + numberOfUnknowns + "," + numberOfParameters + "," + order
        + "+1,exahype::solvers::Solver::GlobalTimeStepping) {\n");
    writer.write("  // @todo Please implement/augment if required\n");
    writer.write("}\n");
    writer.write("\n\n\n");
    writer.write("int " + projectName + "::" + solverName + "::getMinimumTreeDepth() const {\n");
    writer.write("  // @todo Please implement\n");
    writer.write("  return 3;\n");
    writer.write("}\n");
    writer.write("\n\n\n");
    writer.write("bool " + projectName + "::" + solverName
        + "::hasToAdjustSolution(const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t) {\n");
    writer.write("  // @todo Please implement/augment if required\n");
    writer.write("  return false;\n");
    writer.write("}\n");
    writer.write("\n\n\n");
  }

  static public void invokeCodeGenerator(String solverName, int numberOfUnknowns, int numberOfParameters, int order,
      boolean isLinear, int dimensions, String microarchitecture, String pathToLibxsmm)
      throws IOException {
    String currentDirectory = System.getProperty("user.dir");
    java.nio.file.Path pathToCodeGenerator =
        java.nio.file.Paths.get(currentDirectory + "/Miscellaneous/CodeGenerator/Driver.py");
    if (java.nio.file.Files.notExists(pathToCodeGenerator)) {
      System.err.println("ERROR: Code generator not found. Can't generated optimised kernels.");
      return;
    }

    String numericsParameter = isLinear ? "linear" : "nonlinear";

    // set up the command to execute the code generator
    String args = " " + solverName + " " + numberOfUnknowns + " " + order + " "
        + Integer.toString(dimensions) + " " + numericsParameter + " " + microarchitecture + " "
        + pathToLibxsmm + " "
        + "--precision=DP"; // double precision

    String bashCommand = "python " + pathToCodeGenerator + args;

    Runtime runtime = Runtime.getRuntime();

    // execute the command line program
    Process codeGenerator = runtime.exec(bashCommand);

    // capture any output that is produced by the code generator and print it line-by-line
    java.io.InputStream stdout = codeGenerator.getInputStream();
    java.io.BufferedReader stdoutReader =
        new java.io.BufferedReader(new java.io.InputStreamReader(stdout));
    String line = "";
    while ((line = stdoutReader.readLine()) != null) {
      System.out.println("CodeGenerator: " + line);
    }
    java.io.InputStream stderr = codeGenerator.getErrorStream();
    java.io.BufferedReader stderrReader =
        new java.io.BufferedReader(new java.io.InputStreamReader(stderr));
    while ((line = stderrReader.readLine()) != null) {
      System.out.println("CodeGenerator: " + line);
    }
  }
}
