// Solve the volume integral 

#include "kernels/aderdg/optimised/Kernels.h"
#include "kernels/aderdg/optimised/DGMatrices.h"
#include "kernels/aderdg/optimised/GaussLegendreQuadrature.h"
#include <cstring>
#include "asm_volumeIntegral.c"

void kernels::aderdg::optimised::volumeIntegral( 
  double* restrict lduh, 
  const double* restrict const lFhi, 
  const tarch::la::Vector<DIMENSIONS,double> &dx
) {
  memset(lduh, 0, sizeof(lduh)*{{nVar*(nDoF**nDim)}});

  // Assume equispaced mesh, dx[0] == dx[1] == dx[2]
{%- for j in j_seq%} {# if nDim == 2 then j_seq == [0] #}
{%- for i in i_seq%}

#pragma simd
  for(int it=0;it<{{nDoF*nDoFPad}};it++) 
    s_m[it] = weights2[{{i+j*nDoF}}]/dx[0] * Kxi_T[it];

  {{gemm_x}}(&lFhi[{{(j*nDoF+i) * nVarPad * nDoF}}],&s_m[0],&lduh[{{(j*nDoF+i) * nVar * nDoF}}]);
  {{gemm_y}}(&lFhi[{{(j*nDoF+i) * nVarPad * nDoF + lFhi_padY}}],&s_m[0],&lduh[{{(j*nDoF*nDoF+i) * nVar}}]);
{%- if nDim == 3 %} 
  {{gemm_z}}(&lFhi[{{(j*nDoF+i) * nVarPad * nDoF + lFhi_padZ}}],&s_m[0],&lduh[{{(j*nDoF+i) * nVar}}]);
{%- endif %}  

{%- endfor%}
{%- endfor%}

}