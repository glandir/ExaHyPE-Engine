\documentclass{scrreprt}

\usepackage{amsmath,amssymb}
\usepackage{accsupp}
\usepackage[only,llbracket,rrbracket]{stmaryrd}
\usepackage[ntheorem]{empheq}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{./shortcuts}

\usepackage{tikz}
\usetikzlibrary{backgrounds}

% sudo apt-get install pgf
\usepackage{pgfplots}
\pgfplotsset{compat=newest}

\begin{document}
\title{Using Peano's space-tree traversal for explicit
discontinuous Galerkin methods}
\author{Dominic Etienne Charrier}
\date{\today}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
We show how to use Peano's core functionality, the space-tree traversal, 
and Peano's patch toolbox to solve partial differential 
equations of the evolution type (parabolic, hyperbolic) using   
explicit discontinuous Galerkin (DG) methods.

To this end, we discuss a linear advection problem.
The governing equations are discretized according
the method of lines. For the discretization in time, we employ an explicit
Euler time marching scheme.
We discretize the governing equations in space using an upwind DG formulation.
While this is a rather simple setup, it already covers most of the
steps that have to be performed for a wide range of linear
hyperbolic problems and their corresponding explicit DG discretizations.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The (classical) divergence $\boldsymbol{\nabla}\cdot\vec{T}$ (a vector-valued
function) of a sufficiently regular second-order tensor-valued function
$\vec{T}$ is defined according to:
\begin{align}
(\boldsymbol{\nabla}\cdot\vec{T})_{i} &= \sum_{j=1}^d
\frac{\partial}{\partial x_j} T_{ij},\qquad
i=1,\ldots,N_{\textup{var}}
\end{align}
where $N_\textup{var}$ denotes the number of variables
and $d$ the space dimension.

% Furthermore, the (classical) tensor-valued gradient
% $\boldsymbol{\nabla}\vec{v}$ of a vector-valued function $\vec{v}$
% is defined by:}
% (\boldsymbol{\nabla}\vec{v})_{ij}
% &=
% \frac{\partial}{\partial x_j} v_i,\qquad
% i=1,\ldots,N_{\textup{var}},\;
% j=1,\ldots,d,
% Lastly, the scalar-valued double-dot product of two
% $\boldsymbol{\nabla}\vec{v}$ of a vector-valued function $\vec{v}$
% is defined by: }
% 
% \end{align}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Governing equation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let $\domain \subset \mathbb{R}^d$, $d=2,3$, denote a rectangular domain
with boundary $\boundary$. 
We want to model the time evolution of a material concentration
$u$ inside of a flow field $\vec{b}$ by means of the following
conservation law:
\begin{subequations}
\begin{align}
\label{eq:governing_equations:advection}
\frac{\partial u}{\partial t} + \boldsymbol{\nabla} \cdot\vec{F}(u) &= 0&&
\textup{in } \domain \times (0,T],
\\
u(\xvec,0) &= u^0(\xvec)&& \textup{in }
\domain \times \{0\},
\end{align}
with $u^0$ denoting a sufficiently regular initial condition,
$T$ denoting the simulation time, and 
\begin{align}
\vec{F}(u) = \vec{b}\,u \in \mathbb{R}^{N_\textup{var}\times d}
\end{align}
denoting the second-order tensor-valued physical flux ($N_\textup{var}=1$).
Please note that $\vec{F}(u)$ and $\vec{b}$ are here defined as row vectors.
Here and below, $\vec{b}$ is assumed to be sufficiently regular.
To complete the problem formulation, the material concentration is
further subject to sufficiently regular inflow boundary conditions, i.e.,
\begin{align}
\label{eq:governing_equations:advection_inflow}
u(\xvec,t) &= \inflow (\xvec,t),&& (\xvec,t) \in \boundaryIn
\times (0,T]. 
\end{align}
\end{subequations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{An explicit one-step discontinuous Galerkin method 
for linear advection}
\section{Computational mesh and trace operators}
\label{sec:mesh}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let $\tria$ be a structured Cartesian mesh on $\domain$.
We refer to the disjoint open sets $\cell \in \tria$ as elements. We denote by $\hcell$
the diameter of $\cell$.
We store the local quantities $\hcell$ in the vector
$\laVec{h} = \{ \hcell \}_{\cell \in \tria}$, and
set
$h_\textup{max} = \text{max}_{\cell \in \tria }\,\hcell$.
Finally, $\normal$ denotes the outward normal unit vector to the element boundary
$\cellBnd$. We will denote the number of elements by $\Ncell$.

An interior face of $\tria$ is the $d-1$ dimensional intersection
$\cellBnd^{+} \cap \cellBnd^{-}$, where $\cellPlus$ and $\cellMinus$
are two adjacent elements of $\tria$. Similarly, a boundary face of $\tria$ is
the $d-1$ dimensional intersection $\cellBnd \cap \boundary$ which consists
of entire faces of $\cellBnd$.
We denote by $\internalFaces$ the union of all interior faces of $\tria$.

Here and in the following, we refer generically to a ``face" even in the
case $d=2$.
Now, let $\face \in \internalFaces$ be an interior face shared by
the elements $\cellPlus$ and $\cellMinus$.
We denote by $\varphi$ a scalar-valued function (in
$\sobolev{1}{\tria}$).
We observe that the traces of $\varphi$
are defined twice on $\face$.
Let $\varphi^{\pm}$ denote the trace of $\varphi$ on $\face$ from the
interior of $\cell^{\pm}$;
we define a jump operator $\jmp{\varphi\normal}$ by
\begin{align}
\jmp{\varphi\normal} &= \varphi^{+}\normal^{+} + \varphi^{-}\normal^{-}.
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discretization of the linear advection problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We discretize \eqref{eq:governing_equations:advection} -- \eqref{eq:governing_equations:advection_inflow}
following the method of lines procedure. Thus, we make the ansatz
\begin{align}
u_h (\xvec,t) = \sum_m u_m (t)\,\phi_i(\vec{x}),
\end{align}
with time-dependent coefficients $u_i$, and basis
functions $\vec{\phi}_i$ that depend solely on $\vec{x}$ and belong
to the discrete space
\begin{align}
\mathcal{V}_h &= \left \{
v_h \in \lebesgueTwo{\Omega}: v_h|_\cell \in
{Q}_N(\cell),\, \forall \cell \in \tria
\right \}
\end{align}
with $N$ denoting the order of approximation, and
${Q}_N(\cell)$ denoting the space of polynomials of
degree at most $N$.
Note that the above ansatz uses indices in terms of a global basis.
It is however often more useful to introduce a local
basis function index. This index together with the index of the element the basis function
``lives in'' can then be mapped to a global index if necessary.
Thus, we make the following ansatz instead:
\begin{align}
u_h (\xvec,t) =
\sum_{c=1}^{\Ncell}\,\sum_{i=1}^{N_{\textup{basis}}} u_{c,m}
(t)\,\phi_{c,m}(\vec{x}),
\end{align}

Furthermore, for any boundary face $\face\in\boundaryOut$
of the mesh, we introduce inflow (``$\downarrow$'') and outflow
(``$\uparrow$'') parts
\begin{align}
\face^{\downarrow} &= \{ \vec{x} \in \face :(\vec{b} \cdot
\normal)(\vec{x}) < 0\},\qquad
\face^{\uparrow} = \{ \vec{x} \in \face : (\vec{b} \cdot\normal)(\vec{x})
\geq 0\}.
\end{align}
With respect to the previous definitions, the semidiscrete upwind DG
formulation of problem \eqref{eq:governing_equations:advection} -- \eqref{eq:governing_equations:advection_inflow}
consists of
finding a sufficient regular $u_h\in\mathcal{V}_h$ such that
\begin{align}
\sumCells \intCell \frac{\partial}{\partial t}u_h\,v_h\,\dV
&=
\sumCells \intCell \vec{F}(u_h) \cdot \nabla v_h\,\dV
- \sum_{\face \in \internalFaces} \int_\face
\vec{G}(u_h^{+},u_h^{-})\cdot\jmp{v_h \normal}\,\ds
\\
&- \sum_{\face \in \boundary} \int_{\face^{\uparrow}}
\vec{F}(u_h) \cdot \normal \,v_h\,\ds
+ \sum_{\face \in \boundary} \int_{\face^{\downarrow}}
\inflow\,v_h\,\ds,
\qquad\forall v_h \in\mathcal{V}_h.
\notag
\end{align}
The above equations are the result of elementwise partial integration
and a consequent summation over all elements.
To complete the DG formulation, we have to define unique values
on the interior faces, the so-called numerical fluxes here denoted by
$\vec{G}^{*}(u_h^{+},u_h^{-})$.
Above, we have decided to use so-called upwind fluxes, i.e.,
we choose,
\begin{align}
\vec{G}(u_h^{+},u_h^{-}) = u_h^{\uparrow}\,\vec{b}.
\end{align}
where we have defined the upstream/upwind value (``$\uparrow$'')
of $u_h$ according to
\begin{align}
u_h^{\uparrow}(\xvec) &=
\begin{cases}
u_h^{+}&(\vec{b} \cdot \normal^{+})(\vec{x}) \geq 0,
\\
u_h^{-}&(\vec{b} \cdot \normal^{-})(\vec{x}) > 0,
\end{cases}
\end{align}
with $\vec{x} \in \face$ and $u_h^{\pm}=u_h|_{\cell^{\pm}}$.

Note that the choice of the fluxes has effects on both,
the stability and the order of convergence of a DG method
Note further that for the linear advection equation,
many numerical fluxes, e.g., Lax-Friedrichs, HLLE, etc., reduce to the above
upwind flux. One particluar exception is the central flux which leads to an
unstable method; cf.~\cite{hartmann_2008} for a source of all of the statements
above.

After the choice of the fluxes, we need to choose a basis
of the space $\mathcal{V}_h$ to complete the spatial discretization.
We give examples for such a basis in the next sections.

If we choose a basis, the above discrete variational problem is equivalent
to the following system of ordinary differential equations:
\begin{align}
\label{eq:advection:ode_system}
\laMat{M}\,\frac{\text{d}}{\text{d}t}\laVec{u}(t)
&= (\laMat{F}\,
+ \laMat{G}
+ \laMat{O})\,\laVec{u}(t)
+ \laVec{I}(t)
,&&\textup{almost everywhere in } (0,T),
\intertext{s.t. the initial conditions}
\laVec{u}(0) &= \laVec{u}^0,
\end{align}
with the vector $\laVec{u}(t)$ containing the time-dependent coefficients
to the time-independent basis functions.
Note that only the operation $\laMat{G}\,\laVec{u}$ is non-local 
and requires communication between processes. 
Note further that the mass operator $\laMat{M}$ is in general
block-diagonal or even diagonal if an $L^2(\domain)$-orthogonal basis is used.
We will further refer to $\laMat{F}$ as the volume flux operator, to 
$\laMat{O}$ as the outflow operator, 
to $\laMat{G}$ as the normal flux operator,
and to $\laMat{I}$ as the inflow vector.
We will clarify in the next sections which bilinear forms appearing 
in the above variational problem are mapped to which operator. 
Note that we use the term operator since our implementation is 
matrix-free, i.e., we will not assemble any global matrices.

We discretize \ref{eq:advection:ode_system} in time using an explicit (one-step)
forward Euler method. This results in the update scheme below:
\begin{align}
\laVec{u}^{i+1}
&=
\laVec{u}^{i}
+
\Delta t\,\laMat{M}^{-1}\left((\laMat{F}\,
+ \laMat{O})\,\laVec{u}^i
+ \laVec{I}(t^i)
+ \laMat{G}\,\laVec{u}^{i}
\right),
\end{align}
with $i=0,\ldots,i_{max}$ denoting the time step, $t^i$ denoting a discrete
point in time, and $\Delta t$ denoting the time step size. The maximum time step depends
on the simulation time according to $n_{max}=T/\Delta t$.

To ensure stability of the scheme, we have to limit the size of time step. 
For global time stepping schemes as ours, the upper bound for admissible time
steps is usually estimated according to:
\begin{align}
\label{eq:cfl_time_step}
\Delta
t \leq
\textup{CFL}\,\max_{\cell\in\tria}\,\left\{
\frac{\varrho_\cell}{\max_{\xvec\in\cell}|\vec{b}|}
\right\},
\end{align}
with $\textup{CFL}=(2\,N+1)^{-1}$ (cf. \cite{cockburn_discontinuous_2003}), where $N$ denotes
the polynomial order of the spatial discretization.
Here, $\rho_K$ denotes the smallest circle that can be inscribed inside 
the grid cell $\cell$.

\begin{remark}
{\rm
Note that the CFL criterion imposes a severe restriction on the
time step size if we want to use higher order spatial approximations
($N>0$). This is one of the reasons why we want to use ADER-DG methods 
instead of the classical ones discussed in this chapter.} 
\end{remark}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The local discrete operators}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\subsection{Preliminaries}
We store all cells of the mesh in an ordered list $\{
\cell_c \}_{1 \leq c \leq \Ncell}$.

Recall that we construct a global basis
for $\mathcal{V}_h$ using local basis
functions with compact support on each cell $\cell_c$, i.e., the basis functions
attain non-zero values only in one particular cell $\cell_c$ and are identical
to zero elsewhere.

We denote by $\{ \phiCell{c}{m} \}_{1 \leq m \leq
\NphiCell}$ the local basis in $\cell_c$,
with $\NphiCell$ denoting the size of the local basis. 
Note that for an approximation of order N, the size of the local basis is 
computed according to:
\begin{align}
\NphiCell = 1\times(N+1)^d.
\end{align}
There are many different ways to choose the basis functions.
Usual choices are nodal basis functions (Lagrange polynomials) or
modal basis functions (Legendre polynomials).
The latter and certain nodal basis functions where the nodes are located at
Gauss-Legendre quadrature points have a useful property:
They are orthogonal in the $L^2(\Omega)$ sense.
Choosing such a basis often results in very sparse operators, e.g.,
the mass operator is completely diagonal in this case.

We will further define $u_h^c=u_h|_{\cell_c}$. 
To derive the elements of the operators introduced
in the previous section, we can apply the following replacement rule:
\begin{align}
u_h^{c} &\rightarrow \phiCell{c}{n} & \textup{specifies a column}, \\
v_h^{c} &\rightarrow \phiCell{c}{m} & \textup{specifies a row},
\end{align}
where $u_h\in\mathcal{V}_h$ refers to the ansatz function and  
$v_h\in\mathcal{V}_h$ to a test function.
Lastly, if two cells share a face, we will always indicate the 
neighbor cell by the index $b$, and the ``current''cell
by the index $c$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mass operator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Thanks to the compact support of the local basis functions,
we only have to compute the local block matrix
$\laMat{M}^{c,c} \in \mathbb{R}^{\NphiCell \times \NphiCell}$ for each
cell $\cell_c$, where
\begin{align}
\mathrm{M}^{c,c}_{m,n} =
\int_{\cell_c}
\phiCell{c}{m}\,\phiCell{c}{n} \, \dV,
 && m,n = 1,\ldots,\NphiCell.
\end{align}
The mass operator is thus in general block-diagonal.
\subsection{Volume flux operator}
Thanks to the compact support of the local basis functions,
we only have to compute the local block matrix
$\laMat{F}^{c,c} \in \mathbb{R}^{\NphiCell \times \NphiCell}$ for each
cell $\cell_c$, where
\begin{align}
\label{eq:volume_flux_op}
\mathrm{F}^{c,c}_{m,n} &= \sumCells \intCell \vec{F}(\phiCell{c}{n}) \cdot
\nabla \phiCell{c}{m}\,\dV
&& m,n = 1,\ldots,\NphiCell.
\end{align}
The volume flux operator is thus in general block-diagonal.
\subsection{Outflow operator}
Let us denote the outflow part of a face from the perspective of cell $\cell_c$
by
\begin{align}
\face^{c,\uparrow} \isdef \{ \vec{x} \in \face : (\vec{b} \cdot
\cellNormal{c})(\vec{x})> 0\}.
\end{align}
Let $\face \subset \boundary \cap \cellBnd_c$, where $\cellBnd_c$
denotes the boundary of cell $\cell_c$.
Thanks to the compact support of the local basis functions, we only
have to compute the local matrix $\laMat{O}^{c,c} \in \mathbb{R}^{\NphiCell
\times \NphiCell}$ for each cell $\cell_c$, where
\begin{align}
O^{c,c}_{m,n} =
\int_{\face^{c,\uparrow}}
-
(\vec{F}(\phiCell{c}{n})\cdot\normal)\,\phiCell{c}{m} \, \dV,
 && m,n = 1,\ldots,\NphiCell.
\end{align}
The outflow operator is thus in general block-diagonal.
\subsection{Inflow vector}
Let us denote the inflow part of a face from the perspective of cell $\cell_c$
by
\begin{align}
\face^{c,\downarrow} \isdef \{ \vec{x} \in \face : (\vec{b} \cdot
\cellNormal{c})(\vec{x}) < 0\}
\end{align}
Thanks to the compact support of the local basis functions, we only
have to compute the local vector $\laMat{I}^{c} \in \mathbb{R}^{\NphiCell
\times \NphiCell}$ for each cell $\cell_c$, where
\begin{align}
I^{c}_{m} =
\int_{\face^{c,\downarrow}}
j(t^n)\,\phiCell{c}{m} \, \dV,
 && m,n = 1,\ldots,\NphiCell.
\end{align}
\begin{remark}
Compact support
\rm {should sound familiar at this point.}
\end{remark}
\section{The non-local discrete normal flux operator}
Let the face $\face \in \internalFaces$ be part of the boundary of both
cells $\cell_c$ and $\cell_b$, we have to compute the block matrices
$\laMat{G}^{c,c} \in \mathbb{R}^{\NphiCell \times \NphiCell}$,
$\laMat{G}^{c,b} \in \mathbb{R}^{\NphiCell \times \NphiCell}$,
$\laMat{G}^{b,c} \in \mathbb{R}^{\NphiCell \times \NphiCell}$,
and
$\laMat{G}^{b,b} \in \mathbb{R}^{\NphiCell \times \NphiCell}$
according to:
\begin{align}
{G}^{c,c}_{m,n} &=
\int_{\face}
-
G^{\uparrow}(\phiCell{c}{n},\cellNormal{c})\,
\phiCell{c}{m} \, \dV,
&& m,n = 1,\ldots,\NphiCell,
\\
{G}^{c,b}_{m,n} &=
\int_{\face}
G^{\uparrow}(\phiCell{b}{n},\cellNormal{b})\,
\phiCell{c}{m} \, \dV,
&& m,n = 1,\ldots,\NphiCell,
\\
\intertext{and}
\\
{G}^{b,b}_{m,n} &=
\int_{\face}
-
G^{\uparrow}(\phiCell{b}{n},\cellNormal{b})\,
\phiCell{b}{m} \, \dV,
&& m,n = 1,\ldots,\NphiCell,
\\
{G}^{b,c}_{m,n} &=
\int_{\face}
G^{\uparrow}(\phiCell{c}{n},\cellNormal{c})\,\phiCell{b}{m} \, \dV,
&& m,n = 1,\ldots,\NphiCell. 
\end{align}
Above, we have introduced the numerical normal fluxes
\begin{align} 
G^{\uparrow}(\phiCell{+}{n},\normal^{+})
&=
\begin{cases}
(\vec{b} \cdot \normal^{+})\,\phiCell{+}{n}
& \textup{for }
(\vec{b} \cdot \normal^{+})(\vec{x}) \geq 0, 
\\
0                & \textup{otherwise},
\end{cases}
\end{align}
Note that we write once per face, i.e., $2\,d$ times, to the block
$\laMat{G}^{c,c}$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cellwise constant basis functions (in space)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In the case of cellwise constant basis functions, we can make the following
simplifications. Let $\cell_c\in\tria$; the mass operator
is diagonal and has one element per cell:
\begin{align}
\mathrm{M}^{c,c} =
\int_{\cell_c} 1\,\dV = | \cell_c |
&\Leftrightarrow (\mathrm{M}^{-1})^{c,c} =
1/| \cell_c |,
\intertext{The volume fluxes are identical to zero, i.e.,}
\laMat{F} &= 0,
\intertext{since the gradient of the cellwise constant basis functions is 
identical to zero.
The outflow operator is diagonal and has one element per cell:}
O^{c,c} =
\int_{\face^{c,+}}
\vec{F}(1)\cdot\normal\,\, \dV
&=
\int_{\face^{c,+}}
\vec{b}\cdot\normal\,\, \dV,
\intertext{and the inflow vector has one element in each cell:}
I^{c} &=
\int_{\face^{c,\downarrow}}
j(t^n) \, \dV,
\intertext{We have the following contributions to the normal flux
operator per face:} {G}^{c,c} &=
\int_{\face}
-
G^{\uparrow}(\cellNormal{c})\,\dV,
\\
{G}^{c,b} &=
\int_{\face}
G^{\uparrow}(\cellNormal{b})\, \dV,
\\
\intertext{and}
\\
{G}^{b,b} &=
\int_{\face}
-
G^{\uparrow}(\cellNormal{b})\, \dV,
\\
{G}^{b,c} &=
\int_{\face}
G^{\uparrow}(\cellNormal{c})\,\dV,
\intertext{with}
G^{\uparrow}(\normal^{+})
&=
\begin{cases}
(\vec{b} \cdot \normal^{+})
& \textup{for }
(\vec{b} \cdot \normal^{+})(\vec{x}) \geq 0, 
\\
0                & \textup{otherwise},
\end{cases}
\end{align}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mappings}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this section, we introduce mappings between the mesh elements
$\cell\in\tria$ and a reference element. These mappings allow 
us to treat integrals over arbitrarily shaped mesh elements in an uniform manner.
To ease the presentation, we only consider the two-dimensional case.
\\[5pt]
Let us define the \textit{reference element} ${\refCell=[-1,1]^2}$
and let us denote by $\refVec{x}=(\hat{x},\hat{y})\transp$ a point belonging to $\refCell$.
Let $\cell\in\tria$ denote a quadrilateral element
and let its corners $\vec{P}_m$, $m=1,2,3,4$, be ordered as shown in figure \ref{fig:stokes_ipdg_impl:node_ordering}.
\begin{figure}[h]
\centering
\tikzset{dot/.style={circle,fill=#1,inner sep=0,minimum size=4pt}}
\begin{tikzpicture}
%
\path[draw] (-1,-1) -- (1,-1) -- (1,1) -- (-1,1) -- (-1,-1);
%
\node [circle=green,fill=white,scale=0.8] at (-1,-1) {\textbf{1}};
\node [circle=green,fill=white,scale=0.8] at ( 1,-1) {\textbf{2}};
\node [circle=green,fill=white,scale=0.8] at (-1, 1) {\textbf{3}};
\node [circle=green,fill=white,scale=0.8] at ( 1, 1) {\textbf{4}};
\end{tikzpicture}
\caption[Node ordering]{Node ordering}
\label{fig:stokes_ipdg_impl:node_ordering}
\end{figure}
\\
For simplicity, we assume that the quadrilateral $\cell$ has straight edges.
Then, we can express $\cell$ according to 
\begin{align}
\cell &= \mapping (\refCell),
\notag
\intertext{where we define the mapping $\mapping : \refCell \to \cell$ by}
\label{eq:stokes_ipdg_impl:mapping}
\vec{x} = \mapping(\refVec{x}) 
&= 
\begin{pmatrix}
\mappingT{x}(\refVec{x})\\
\mappingT{y}(\refVec{x})
\end{pmatrix}
= \sum_{m=1}^4 \vec{P}_{m}\,s_m(\refVec{x}),
\qquad \refVec{x}\in\refCell,\vec{x}\in\cell. 
\end{align} 
The \textit{shape functions} $s_m(\refVec{x})$, $m=1,2,3,4$, are defined according to
\begin{align}
\label{eq:stokes_ipdg_impl:shape_fun_1}
s_1(\refVec{x})
&=
\frac{1}{4}(1-\hat{x})\,(1-\hat{y}),
\qquad
s_3(\refVec{x})
=
\frac{1}{4}(1-\hat{x})\,(1+\hat{y}),
\\
\label{eq:stokes_ipdg_impl:shape_fun_4}
s_2(\refVec{x})
&=
\frac{1}{4}(1+\hat{x})\,(1-\hat{y}),
\qquad
s_4(\refVec{x})
=
\frac{1}{4}(1+\hat{x})\,(1+\hat{y}),
\intertext{and have the property}
s_m(\refVec{P}_n) &= 
\begin{cases}
1,&m=n,\\
0,&m\neq n,
\end{cases}
\end{align}
where $\refVec{P}_1=(-1,-1)\transp$, $\refVec{P}_2=(1,-1)\transp$, $\refVec{P}_3=(-1,1)\transp$, and $\refVec{P}_4=(1,1)\transp$ denote the
corner points of the reference element. Note that the indexing of these corner points is in compliance with the node ordering depicted in
figure \ref{fig:stokes_ipdg_impl:node_ordering}.

Note that in case of Cartesian elements, we can simplify the above
mapping according to:
\begin{align}
\vec{x} = \mapping(\refVec{x}) 
&= 
\vec{P}_{1} + 
\frac{1}{2}
\begin{pmatrix}
\Delta x & 0 \\
0 & \Delta y
\end{pmatrix}
\begin{pmatrix}
\hat{x} \\
\hat{y}
\end{pmatrix},
\end{align}
where $\Delta x$ and $\Delta y$ denote the dimensions of the element in the
respective coordinate direction.
Note that $\vec{P}_1$ must always represent the lower left corner node in this
case.

Assuming it exists, we denote the inverse mapping by $\imapping : \cell \to \refCell$, which
in general cannot be constructed by polynomial shape functions.
Next, let us define the Jacobian matrix
\begin{align}
\jacobian (\refVec{x})&= 
\begin{pmatrix}
\jacobianT{x}{\hat{x}} & \jacobianT{x}{\hat{y}} \\
\jacobianT{y}{\hat{x}} & \jacobianT{y}{\hat{y}} 
\end{pmatrix}(\refVec{x}),
\notag
\intertext{and its determinant}
\detJ(\refVec{x}) = \textup{det}\left(\jacobian\right)(\refVec{x})&= 
\begin{vmatrix}
\jacobianT{x}{\hat{x}} & \jacobianT{x}{\hat{y}} \\
\jacobianT{y}{\hat{x}} & \jacobianT{y}{\hat{y}} 
\end{vmatrix}(\refVec{x}).
\notag
\end{align}
Assume that $\mapping$ is invertible, we accordingly define 
$\ijacobian (\vec{x})$ and it follows from the inverse function theorem that
\begin{align}
\ijacobian (\vec{x}) &= \left(\jacobian\right)^{-1}(\refVec{x}),
\notag
\end{align}
for $\refVec{x}\in\refCell$ such that $\vec{x}=\mapping(\refVec{x})\in\cell$.
We note that if the element $\cell$ is affine,
it holds that 
\begin{align}
\jacobian (\refVec{x}) = \jacobian = \textup{const.}\qquad
&\Leftrightarrow
\qquad\detJ (\refVec{x}) = \detJ = \textup{const.},
\notag
\intertext{and the mapping has the form}
\mapping(\refVec{x}) 
&=
\jacobian\cdot\refVec{x} + \vec{P}_1.
\notag
\end{align} 
In this case, there exists an inverse mapping if
$\jacobian$ is regular, i.e. $\detJ\neq 0$. 
\\[5pt]
According to an invertible mapping $\mapping$, we can further derive the following identity.
Let $\hat{f}$ be a sufficiently regular function on the reference element $\refCell$, and
let $f$ be sufficiently regular on $\cell$ and such that
\begin{align}
\label{eq:stokes_ipdg_impl:imapping_scalar_function}
f(\vec{x}) &= (\hat{f} \circ \imapping)(\vec{x}) = \hat{f}(\refVec{x}),
\qquad
\refVec{x}\in\refCell,\,\vec{x}=\mapping(\refVec{x})\in\cell.
\end{align} 
Then, it holds that 
\begin{align}
\nabla\,f(\vec{x}) &= \left(\jacobian^{-\textup{T}}\,\cdot\hat{\nabla}\,\hat{f}\right)(\refVec{x}),
\notag
\intertext{where}
\hat{\nabla} &= \left(\frac{\partialup}{\partialup \hat{x}},\,\frac{\partialup}{\partialup \hat{y}}\right)\transp   
\notag
\end{align}
denotes the gradient with respect to the reference coordinates. This follows
from \eqref{eq:stokes_ipdg_impl:imapping_scalar_function} and using the chain rule.
A similar identity can be derived for vector-valued functions.
We can further express volume integrals over the element $\cell$ 
with respect to the reference coordinates and the invertible mapping $\mapping$.
Let $\hat{f}$ and $f$ be defined as in \eqref{eq:stokes_ipdg_impl:imapping_scalar_function},
we have
\begin{align}
\intCell f(\vec{x})\,\dV &= \intRefCell \hat{f}(\refVec{x})\,|\detJ(\refVec{x})|\,\refdV
=
\int_{-1}^1\int_{-1}^1 \hat{f}(\hat{x},\hat{y})\,|\detJ(\hat{x},\hat{y})|\,\refdV\,\refdy.
\notag
\end{align}
Further, if we define the faces of the reference element according to
\begin{align}
\refFace_{1} &= \{ \refVec{x} \in \refCell : \hat{x} = -1\},\qquad
\refFace_{3} = \{ \refVec{x} \in \refCell : \hat{y} = -1\},
\notag\\
\refFace_{2} &= \{ \refVec{x} \in \refCell : \hat{x} = +1\},\qquad
\refFace_{4} = \{ \refVec{x} \in \refCell : \hat{y} = +1\},
\notag
\end{align}
we can define the four faces belonging to the boundary of $\cell$ by
\begin{align}
\face_{1} &= \mapping(\refFace_1),\qquad
\face_{2} = \mapping(\refFace_2),\qquad
\face_{3} = \mapping(\refFace_3),\qquad
\face_{4} = \mapping(\refFace_4).
\notag
\end{align}
Now we can express integrals over faces belonging to the boundary of $\cell$ with respect to 
the reference coordinates and the mapping $\mapping$.
Let $\hat{f}$ and $f$ be defined as in \eqref{eq:stokes_ipdg_impl:imapping_scalar_function},
we have
\begin{align}
\int_{\face_1} f(\vec{x})\,\ds &=
\int_{-1}^1\hat{f}(-1,\hat{x})\,|\detJ(-1,\hat{x})|\,\refdx, 
\notag\\
\int_{\face_2} f(\vec{x})\,\ds &=
\int_{-1}^1\hat{f}(+1,\hat{x})\,|\detJ(+1,\hat{x})|\,\refdx,
\notag\\
\int_{\face_3} f(\vec{x})\,\ds &=
\int_{-1}^1\hat{f}(\hat{y},-1)\,|\detJ(\hat{y},-1)|\,\refdy,
\notag\\
\int_{\face_4} f(\vec{x})\,\ds &=
\int_{-1}^1\hat{f}(\hat{y},+1)\,|\detJ(\hat{y},+1)|\,\refdy.
\notag
\end{align}
Please note that all these concepts extend to the 3-d case and it is also
possible to use higher order shape functions instead of the linear 
Lagrange polynomials that we used in \eqref{eq:stokes_ipdg_impl:shape_fun_1} and 
\eqref{eq:stokes_ipdg_impl:shape_fun_4}; by linear we mean 
linear in each reference coordinate direction.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation of the cell-wise constant discretization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The four phases of DG methods}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We have decided to use a DG method for the spatial
discretization and an explicit scheme for the temporal 
discretization. For this kind of methods, 
the update process that is performed in each time step 
can be divided into the following four phases:
\begin{enumerate}
  \item Compute cell volume data (cell-local)
  \item Extrapolate face data from cell volume data (cell-local)
  \item Exchange face data (non-local)
  \item Apply cell updates (cell-local)
\end{enumerate}
Phase one includes the computation of volume fluxes, right-hand side vectors
(and of the space-time predictors in case of the ADER-DG method with local
time stepping).
In the second phase, we compute the contribution of each cell to 
the (numerical) normal fluxes that will be exchanged in phase three of the
scheme.
Only phase three requires communication between processors if the
code is executed in a parallel environment and should thus be
considered separately from the other phases.
In this phase, the normal fluxes are computed according to the local
contributions of neighboring cells.

Finally, note that phase one and two can be performed in the same grid
traversal.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A more cache-aware ordering of the four phases}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The ordering of the update phases introduced in the previous
section has one disadvantage:
We have to traverse the whole space-tree three times, i.e.,
we have to load the data of each cell at least three times
into the cache of the processor ``owning'' that part
of the grid the cell belongs to.
If we initialize the cell updates to be zero initially,
we can however use the following slightly modified ordering of the four phases:
\begin{enumerate}
  \item Apply cell updates (cell-local)
  \item Compute cell volume data (cell-local)
  \item Extrapolate face data from cell volume data (cell-local)
  \item Exchange face data (non-local)
\end{enumerate}
The above ordering requires only two grid traversals since
we can combine the first three phases and process them in one single traversal.

\chapter{Examples}
\section{Step-12}
We consider a problem setting like in
\href{http://www.dealii.org/developer/doxygen/deal.II/step_12.html}{The
step-12 tutorial program}:
Given is a domain $\Omega=(0,1)^2$; inside the domain and on its boundary acts
a circular counterclockwise flow field
\begin{align}
\vec{b} &= \frac{1}{\sqrt{x^2+y^2}}(-x,y)
\end{align}
We have the following inflow boundary conditions: 
\begin{align}
\inflow(t) &= 
\begin{cases}
1 & \textup{for } \vec{x}\in [0,0.5]\times\{0\} \\
0 & \textup{otherwise}
\end{cases}
\end{align}
Note that according to the definition of the flow field, we only have one inflow
boundary, the boundary at $y=0$.
% bibliography
\bibliographystyle{siam}
\bibliography{bibliography}{}

\end{document}