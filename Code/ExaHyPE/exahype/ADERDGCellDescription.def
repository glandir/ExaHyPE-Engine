/////////////////////////////////////////////////
/// ExaHyPE 
/// ... text ...
/// Version: 13/11/15 
/////////////////////////////////////////////////
#include "peano/utils/Globals.h"

Packed-Type: int;

Constant: DIMENSIONS;
Constant: DIMENSIONS_TIMES_TWO;

class exahype::records::ADERDGCellDescription {
  parallelise persistent int    solverNumber;      
  
  /** 
   * Indicates if this a parent cell (true) or a leaf cell that holds data.
   */
  parallelise persistent bool isParent;
  
  /** 
   * Indicates if this a real cell (false) that holds space-time, volume, and face data
   * or a virtual cell that holds only face data.
   */
  parallelise persistent bool isGhost; 
  
  /** 
   * We hold a bool for each face belonging to this ADER-DG cell stating
   * if a Riemann solve has already performed on it.
   */
  parallelise persistent bool riemannSolvePerformed[DIMENSIONS_TIMES_TWO];
  
  /**
   * Time integration.
   */
   ///@{
  /** 
   * The time step size the predictor is working with.
   */
  parallelise persistent double predictorTimeStepSize;
 
  /** 
   * The time stamp the predictor is working with.
   */
  parallelise persistent double predictorTimeStamp;
  
  /** 
   * The predictor time step size for the next sweep.
   */
  parallelise persistent double nextPredictorTimeStepSize;
   ///@}
  
  
  /** Space-time data on each patch. Size: #var*(N+1)^(d+1)
   * 
   * \note Only for local time stepping we really need to keep the entire space-time degrees of freedom of the ADER approach.
   * */
  ///@{ 
  parallelise persistent int spaceTimePredictor; //!< The indices of the space-time predictor DoF belonging to this cell. Variable: q.
  ///@}	
  
  /** Space-time flux data on each patch. Size: (d*#var)*(N+1)^(d+1)
   * 
   * \note Only for local time stepping we really need to keep the entire space-time degrees of freedom of the ADER approach.
   * */ 
  ///@{ 
  parallelise persistent int spaceTimeVolumeFlux; //!< The indices of the space-time volume fluxes DoF belonging to this cell. Variable: F. 
  ///@}	

  /** Volume data on each patch. Size: #var*(N+1)^d * size */
  ///@{
  parallelise persistent int solution;  //!< The indices of the DoF belonging to this cell. Resembles also the state of the previous time step during update calculations. Variable: u.
  parallelise persistent int update;    //!< The indices of the update DoF belonging to this cell. All volume updates and face fluctuations contribute to this variable. Variable: du.
  parallelise persistent int predictor; //!< The indices of the predictor DoF belonging to this cell, i.e., the time integrated space-time DoF. Variable: qA.  
  ///@}	

  /** Volume flux data on each patch. Size: (d*#var)*(N+1)^d */
  ///@{
  parallelise persistent int volumeFlux; //!< The indices of the volume flux DoF belonging to this cell, i.e., the time integrated space-time DoF. Variable: FA. 
  ///@}	

  /** Face data on each patch. Size: [d*2] * #var*(N+1)^(d-1) */
  ///@{
  parallelise persistent int extrapolatedPredictor; //!< The indices of the predictor DoF extrapolated to the bounding faces of the cell. Variables: uN,uS,uW,uE,..
  parallelise persistent int fluctuation;           //!< The indices of the normal fluxes computed at the bounding faces of the cell. Variables: FN,FS,FW,FE,.. 
  // ! Removed the normalFlux field since we can use the fluctuation field to store both quantities.
  // ! Removed: parallelise persistent int normalFlux; //!< The indices of the fluctuations DoF computed at the bounding faces of the cell. Variables: DLN,DLS,DLW,DLE,.. 
  ///@}	
  
  /** Grid information */
  ///@{
  parallelise persistent int    level;              // !< Space-tree level of the cell owning this cell description.
  parallelise persistent double offset[DIMENSIONS]; // !< Offest of the "lower left" node of the lower left ghost cell from the lower left node of the cell.
  parallelise persistent double size  [DIMENSIONS]; // !< Dimension of the cell owning this cell description in x,y, and z direction.
  ///@}s
};
