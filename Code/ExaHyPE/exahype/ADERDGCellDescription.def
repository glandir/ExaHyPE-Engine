/////////////////////////////////////////////////
/// ExaHyPE
/// ... text ...
/// Version: 13/11/15
/////////////////////////////////////////////////
#include "peano/utils/Globals.h"

Packed-Type: int;

Constant: DIMENSIONS;
Constant: DIMENSIONS_TIMES_TWO;

class exahype::records::ADERDGCellDescription {
  /**
   * @defgroup SolverInfo Meta information on and for the solver
   */
  ///@{
  /**
   * Points to a solver in the solver registry.
   */
  parallelise persistent int solverNumber;

  /**
   * These flags indicate on which face a Riemann solve has already been
   * performed.
   */
  parallelise persistent bool riemannSolvePerformed[DIMENSIONS_TIMES_TWO];
  ///@}
  
  #ifdef Parallel
  
  /**
   * If a neighbouring cell belonging to another rank
   * functions as a compute cell for the same solver (Type::Cell)
   * that this cell description is linked to and this
   * cell description is further a helper cell (Type::Ancestor/EmptyAncestor/
   * Descendant/EmptyDescendany), this helper cell needs to store face data.
   * This flag is used indicate these scenarios.
   *
   * \note This flag should be only set in MarkingForAugmentation::mergeWithNeighbour(...).
   * It should be read and be reseted afterwards in MarkingForAugmentation::mergeWithNeighbour(...).
   */
  parallelise persistent bool helperCellNeedsToStoreFaceData;
  /**
   * Face data exchange in ExaHyPE is realised in vertices: each vertex checks
   * whether one of its adjacent faces should go to another rank. As a result, 
   * a face might be exchanged up to 2^{d-1} times. We use this flag to avoid 
   * this. See prepareSendToNeighbour() in SpaceTimePredictor.
   */
  parallelise persistent bool faceDataSentToNeighbouringRank[DIMENSIONS_TIMES_TWO];
  #endif

  /**
   * @defgroup TimeInfo Time Stamps and Step Sizes
   *
   * Time stamps and step sizes that are used for different
   * phases of the algorithm.
   */
  ///@{
  /**
  * The time step size correction phase is working with.
  */
  parallelise persistent double correctorTimeStepSize;

  /**
   * The time stamp the correction phase is working with.
   */
  parallelise persistent double correctorTimeStamp;

  /**
   * The time step size the prediction phase is working with.
   */
  parallelise persistent double predictorTimeStepSize;

  /**
   * The time stamp the prediction phase is working with.
   */
  parallelise persistent double predictorTimeStamp;

  /**
   * The prediction phase time step size for the next sweep.
   */
  parallelise persistent double nextPredictorTimeStepSize;
  ///@}

  /**
   * @defgroup SpaceTimeDataIndices Space Time Data Indices
   *
   * Index pointing to an array of size \f$ N_\mathrm{var}\,(N+1)^{d+1} \f$.
   *
   * \note Only for local time stepping we really need to keep the entire
   *       space-time degrees of freedom of the ADER approach.
   */
  ///@{
  /**
   * Index pointing to the space-time predictor DoF belonging to this cell.
   * Symbol: \f$ q \f$.
   */
  parallelise persistent int spaceTimePredictor;
  ///@}

  /**
   * @defgroup SpaceTimeDataIndices Space Time Data Indices
   *
   * Index pointing to an array of size \f$ d\,N_\mathrm{var}\,(N+1)^{d+1} \f$
   *
   * \note Only for local time stepping we really need to keep the entire
   * space-time degrees of freedom of the ADER approach.
   * */
  ///@{
  /**
   * Index pointing to the space-time volume fluxes DoF belonging to this cell.
   * Symbol: \f$ \textbf{F} \f$.
   */
  parallelise persistent int spaceTimeVolumeFlux;
  ///@}

  /**
   * @defgroup VolumeDataIndices Volume Data Indices
   *
   * Index pointing to an array of size \f$ N_\mathrm{var}\,(N+1)^{d} \f$.
   */
  ///@{
  /**
   *  Index pointing to the solution DoF belonging to this cell.
   *  Resembles also the state of the previous time step during update
   * calculations.
   *  Symbol: \f$ u_h \f$.
   */
  parallelise persistent int solution;

  /**
   * Index pointing to the update DoF belonging to this cell. All volume updates
   * and face fluctuations contribute to this Symbol. Symbol:
   * \f$ \Delta u_h \f$.
   */
  parallelise persistent int update;

  /**
   * Index pointing to the predictor DoF belonging to this cell, i.e., the time
   * integrated space-time DoF. Symbol: \f$q_h\f$.
  */
  parallelise persistent int predictor;
  ///@}

  /**
   * @defgroup VolumeFluxDataIndices Volume Flux Data Indices
   *
   * Index pointing to an array of size \f$ d\,N_\mathrm{var}\,(N+1)^{d} \f$.
   */
  ///@{
  /**
   * Index pointing to the volume flux DoF belonging to this cell, i.e., the
   * time
   * integrated space-time DoF. Symbol: \f$ \textbf{F}_h \f$.
   */
  parallelise persistent int volumeFlux;
  ///@}

  /**
   * @name FaceDataIndices Face Data Indices
   *
   * Index pointing to an array of size \f$ 2\,d\,N_\mathrm{var}\,(N+1)^{d-1}
   * \f$.
   */
  ///@{
  /**
   * Index pointing to the predictor DoF extrapolated to the bounding faces of
   * the
   * cell.
   */
  parallelise persistent int extrapolatedPredictor;

  /**
   * Index pointing to the normal fluxes computed at the bounding faces of the
   * cell.
   */
  parallelise persistent int fluctuation;
  ///@}

  /**
   * @name CellInfo Cell Info
   *
   * Information on the grid cell this ADERDGCellDescription is associated
   * with.
   */
  ///@{
  /**
   * Space-tree level of the cell this ADERDGCellDescription is associated
   * with.
   */
  parallelise persistent int level;
  /**
   * Offset of the "lower left" node of the lower left ghost cell from the
   * lower left node of the cell.
   */
  parallelise persistent double offset[DIMENSIONS];
  /**
   * Dimension of the cell associated with this ADERDGCellDescription in the
   * respective dimension.
   */
  parallelise persistent double size[DIMENSIONS];
  ///@}

  /**
   * Type of a cell description.
   * Cell descriptions of type \p Cell hold cell and face data,
   * while the ones of type \p Shell hold only face data.
   * Both belong to the original spacetree that
   * is constructed according to solver-based refinement criteria.
   * Virtual shells hold also only face data but belong to
   * the virtual part of the augmented spacetree that
   * is created to store prolongated face data.
   */

  enum Type {
    Erased,
    Ancestor,
    EmptyAncestor,
    Cell,
    Descendant,
    EmptyDescendant
  };

  /**
   * @defgroup AMRInfo AMR information
   *
   * Additional information that is necessary to realise adaptive mesh
   * refinement (AMR).
   */
  ///@{
  /**
   * The type of this ADERDGCellDescription. See the documentation of Cell for
   * more details.
   */
  parallelise persistent Type type;

  /**
   * The index of the ADERDGCellDescription that is the parent of
   * this ADERDGCellDescription or "-1" if no parent is specified.
   */
  parallelise persistent int parentIndex;

  enum RefinementEvent {
    None,
    ErasingRequested,            // post
    Erasing,                     // pre
    ChangeToDescendantRequested, // post
    RefiningRequested,           // pre
    Refining,                    // pre
    DeaugmentingRequested,       // post
    AugmentingRequested,         // pre
    Augmenting                   // pre
  };

  /**
   * Returns the refinement event.
   */
  parallelise persistent RefinementEvent refinementEvent;
  ///@}

  parallelise persistent double solutionMin[DIMENSIONS_TIMES_TWO];
  parallelise persistent double solutionMax[DIMENSIONS_TIMES_TWO];
};
