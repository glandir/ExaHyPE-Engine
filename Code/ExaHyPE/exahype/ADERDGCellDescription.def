/////////////////////////////////////////////////
/// ExaHyPE 
/// ... text ...
/// Version: 13/11/15 
/////////////////////////////////////////////////
#include "peano/utils/Globals.h"

Packed-Type: int;

Constant: DIMENSIONS;
Constant: DIMENSIONS_TIMES_TWO;

class exahype::records::ADERDGCellDescription {
  /** Solver */
  ///@{
  /**
   * Points to a solver in the solver registry.
   */
  parallelise persistent int  solverNumber;
  
  /** 
   * These flags indicate on which face a Riemann solve has already been performed.
   */
  parallelise persistent bool riemannSolvePerformed[DIMENSIONS_TIMES_TWO];
  ///@}
  
  /**
   * @defgroup TimeInfo Time Stamps and Step Sizes
   * 
   * Time stamps and step sizes that are used for different
   * phases of the algorithm.
   */
   ///@{
   /**  
   * The time step size correction phase is working with.
   */
  parallelise persistent double correctorTimeStepSize;
 
  /**  
   * The time stamp the correction phase is working with.
   */
  parallelise persistent double correctorTimeStamp;
  
  /** 
   * The time step size the prediction phase is working with.
   */
  parallelise persistent double predictorTimeStepSize;
 
  /** 
   * The time stamp the prediction phase is working with.
   */
  parallelise persistent double predictorTimeStamp;
  
  /** 
   * The prediction phase time step size for the next sweep.
   */
  parallelise persistent double nextPredictorTimeStepSize;
   ///@}
  
  
  /** 
   * @defgroup SpaceTimeDataIndices Space Time Data Indices
   * 
   * Index pointing to an array of size \f$ N_\mathrm{var}\,(N+1)^{d+1} \f$.  
   * 
   * \note Only for local time stepping we really need to keep the entire
   *       space-time degrees of freedom of the ADER approach.
   */
  ///@{ 
  /**
   * Index pointing to the space-time predictor DoF belonging to this cell.
   * Symbol: \f$ q \f$.
   */
  parallelise persistent int spaceTimePredictor;
  ///@}
  
  /** 
   * @defgroup SpaceTimeDataIndices Space Time Data Indices
   *
   * Index pointing to an array of size \f$ d\,N_\mathrm{var}\,(N+1)^{d+1} \f$
   *  
   * \note Only for local time stepping we really need to keep the entire space-time degrees of freedom of the ADER approach.
   * */ 
  ///@{ 
  /**
   * Index pointing to the space-time volume fluxes DoF belonging to this cell.
   * Symbol: \f$ \textbf{F} \f$.
   */
  parallelise persistent int spaceTimeVolumeFlux; 
  ///@}

  /** 
   * @defgroup VolumeDataIndices Volume Data Indices
   * 
   * Index pointing to an array of size \f$ N_\mathrm{var}\,(N+1)^{d} \f$.  
   */
  ///@{
  /**
   *  Index pointing to the solution DoF belonging to this cell. 
   *  Resembles also the state of the previous time step during update calculations.
   *  Symbol: \f$ u_h \f$.
   */
  parallelise persistent int solution; 
  
  /**
   * Index pointing to the update DoF belonging to this cell. All volume updates
   * and face fluctuations contribute to this Symbol. Symbol: 
   * \f$ \Delta u_h \f$.
   */
  parallelise persistent int update;   
  
  /**
   * Index pointing to the predictor DoF belonging to this cell, i.e., the time 
   * integrated space-time DoF. Symbol: \f$q_h\f$.
  /* 
  parallelise persistent int predictor;  
  ///@}

  /**
   * @defgroup VolumeFluxDataIndices Volume Flux Data Indices
   *
   * Index pointing to an array of size \f$ d\,N_\mathrm{var}\,(N+1)^{d} \f$. 
   */
  ///@{
  /**
   * Index pointing to the volume flux DoF belonging to this cell, i.e., the time
   * integrated space-time DoF. Symbol: \f$ \textbf{F}_h \f$.
   */
  parallelise persistent int volumeFlux; 
  ///@}

  /** 
   * @name FaceDataIndices Face Data Indices
   *
   * Index pointing to an array of size \f$ 2\,d\,N_\mathrm{var}\,(N+1)^{d-1} \f$.
   */ 
  ///@{
  /**
   * Index pointing to the predictor DoF extrapolated to the bounding faces of the
   * cell. 
   */
  parallelise persistent int extrapolatedPredictor; 
  
  /**
   * Index pointing to the normal fluxes computed at the bounding faces of the
   * cell.
   */
  parallelise persistent int fluctuation;            
  ///@}
  
  /** 
   * @name CellInfo Cell Info 
   * 
   * Information on the grid cell this ADERDGCellDescription is associated
   * with.
   */
  ///@{
  /**
   * Space-tree level of the cell this ADERDGCellDescription is associated
   * with.
   */
  parallelise persistent int    level;                            
  /**
   * Offset of the "lower left" node of the lower left ghost cell from the
   * lower left node of the cell.
   */
  parallelise persistent double offset                [DIMENSIONS]; 
  /**
   * Dimension of the cell associated with this ADERDGCellDescription in the
   * respective dimension.
   */
  parallelise persistent double size                  [DIMENSIONS];
  
  /**
   * Position of the cell associated with this ADERDGCellDescription with
   * respect to the parent cell in the respective dimension.
   * 
   * For a level difference \f$l>0\f$, the indices in 
   * \p fineGridPositionOfCell are in the range \f$\{0,1,\ldots,3^l-1\}\f$.
   *
   * The difference in levels of the cell associated with this 
   * ADERDGCellDescription and the cell associated with this 
   * ADERDGCellDescription's parent depends on the AMR strategy.
   * It is not necessary identical to one.  
   */
  parallelise persistent double fineGridPositionOfCell[DIMENSIONS];
 
  ///@}
  /** 
   * @defgroup AMRInfo AMR information
   *
   * Additional information that is necessary to realise adaptive mesh 
   * refinement (AMR).
   */
  ///@{
  /** 
   * The type of this ADERDGCellDescription. See the documentation of Cell for more details.
   */
  parallelise persistent int type;

  /** 
   * Indicates if other ADERDGCellDescriptions consider this ADERDGCellDescription
   * as their parent.
   */
  parallelise persistent bool isParent;	
   
  /**
   * The index of the ADERDGCellDescription that is the parent of
   * this ADERDGCellDescription or "-1" if no parent is specified.
   */
  parallelise persistent int parentIndex;
  
  /**
   * Indicates if this ADERDGCellDescription should be accessed by
   * the AMR and Solver routines.
   */ 
  parallelise persistent bool isActive;
  ///@}
};
