/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

#include <cassert>
#include <cmath>
#include <limits>
#include <utility>
#include <vector>

#include "../../../../../../Peano/tarch/la/Vector.h"
#include "../../../../KernelUtils.h"

#if DIMENSIONS == 2

namespace {

double minmod(double a, double b) {
  assert(std::isfinite(a));
  assert(std::isfinite(b));

  if (a * b < 0.0) {  // sign is different (alternative: std::signbit and xor)
    return 0.0;
  } else {
    if (std::abs(a) < std::abs(b)) {
      return a;
    } else {
      return b;
    }
  }
}

}  // namespace

namespace kernels {
namespace finitevolumes {
namespace godunov {
namespace c {

// A simple Rusanov flux
template <void PDEEigenvalues(const double* const Q, const int normalNonZero,
                              double* lambda),
          void PDEFlux(const double* const Q, double** F)>
double riemannSolver(double* F, const double* qL, const double* qR,
                     int numberOfVariables, int normalNonZero,
                     double** tempStateSizedArrays) { // TODO(Dominic): I need four of those
  double* sL = tempStateSizedArrays[0]; 
  double* sR = tempStateSizedArrays[1];

  PDEEigenvalues(qL, normalNonZero, sL);
  PDEEigenvalues(qR, normalNonZero, sR);

  double s_max = -1.0;
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sL_i = std::abs(sL[i]);
    if (abs_sL_i > s_max) {
      s_max = abs_sL_i;
    }
  }
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sR_i = std::abs(sR[i]);
    if (abs_sR_i > s_max) {
      s_max = abs_sR_i;
    }
  }

  double* FL[2] = {tempStateSizedArrays[0],tempStateSizedArrays[1]}; // TODO(Dominic): MAKE FL and FR input arguments
  double* FR[2] = {tempStateSizedArrays[2],tempStateSizedArrays[3]};
  PDEFlux(qL, FL);
  PDEFlux(qR, FR);

  for (int i = 0; i < numberOfVariables; i++) {
    F[i] = 0.5 * (FL[normalNonZero][i] + FR[normalNonZero][i]) +
           0.5 * s_max * (qL[i] - qR[i]);
  }

  return s_max;  // TODO(guera): Use to check if dt in solutionUpdate was OK
}

template <void PDEEigenvalues(const double* const Q, const int normalNonZero,
                              double* lambda),
          void PDEFlux(const double* const Q, double** F)>
double riemannSolver(double* fL, double* fR, const double* qL, const double* qR,
                     int basisSize, int numberOfVariables, int normalNonZero,
                     double** tempStateSizedArrays) { // TODO(Dominic): I need four of those
  double* sL = tempStateSizedArrays[0]; 
  double* sR = tempStateSizedArrays[1];

  PDEEigenvalues(qL, normalNonZero, sL);
  PDEEigenvalues(qR, normalNonZero, sR);

  double s_max = -1.0;
  
  for (int i<basisSize)

  return s_max;  // TODO(guera): Use to check if dt in solutionUpdate was OK
}

/**
 * Solves all the Riemann problems that do only require
 * internal data and add the result directly onto the
 * new solution. 
 */
template <void PDEFlux(const double* const Q, double** F),
          void PDESource(const double* const Q, double* S),
          void PDEEigenvalues(const double* const Q, const int normalNonZero,
                              double* lambda)>
double solutionUpdate(double* luh_new,
                      double* luh,
                      const tarch::la::Vector<DIMENSIONS, double>& dx,
                      double dt, int numberOfVariables, int basisSize) { // everything is done in the interior
  const int basisSize2 = basisSize * basisSize;
  idx3 idx(basisSize, basisSize, numberOfVariables);
  
  const double cellSize[2] = {dx[0]/basisSize, dx[1]/basisSize};

  // 4. Solve interior Riemann problems
  double dt_max_allowed = std::numeric_limits<double>::max();
  static const double EXAHYPE_CFL_FACTOR = 0.9; // TODO(Dominic): Move this out.
  
  // todo
  double** tempStateSizedArrays;
  
  // x edges 
  double* Fn = tempStateSizedArrays[0];
  for (int j = 0; j < basisSize; j++) {
    for (int k = 0; k < basisSize-1; k++) {
      double s_max_x = 
          riemannSolver<PDEEigenvalues, PDEFlux>(
              Fn, 
              luh + idx(j, k, 0),
              luh + idx(j, k+1, 0), 
              numberOfVariables, 0, &tempStateSizedArrays[1]);
      // TODO(guera): Improve. I'm quite sure this is not the correct/best
      // formula. TODO(Dominic): The division by DIMENSIONS might make sure that C_x+C_y < 1
      dt_max_allowed = std::min(
          dt_max_allowed, EXAHYPE_CFL_FACTOR / DIMENSIONS * cellSize[0] / s_max_x); // TODO(Dominic): Ignore this for a while
      
      for (int l=0; l<numberOfVariables; ++l) {
        luh_new[idx(j, k, l)]   += dt / cellSize[0] * Fn[l];  
        luh_new[idx(j, k+1, l)] -= dt / cellSize[0] * Fn[l];
      }
    }
  }

  // y edges
  double* Fn = tempStateSizedArrays[0];
  for (int j = 0; j < basisSize-1; j++) {
    for (int k = 0; k < basisSize; k++) {
      double s_max_y = riemannSolver<PDEEigenvalues, PDEFlux>(
          Fn, 
          luh + idx(j, k, 0),
          luh + idx(j+1, k, 0), 
          numberOfVariables, 1, &tempStateSizedArrays[1]); // TODO(Dominic): Merging of data happens here; read wRy wLy
      dt_max_allowed = std::min(
          dt_max_allowed, EXAHYPE_CFL_FACTOR / DIMENSIONS * cellSize[1] / s_max_y);
      
      for (int l=0; l<numberOfVariables; ++l) {
        luh_new[idx(j, k, l)]   += dt / cellSize[0] * Fn[l];  
        luh_new[idx(j+1, k, l)] -= dt / cellSize[0] * Fn[l];
    }
  }

  // TODO(guera): Early exit if dt > dt_max_allowed?!

  // 5. Add the source terms
  double* source = tempStateSizedArrays[0]; // temp var; state sized vector
  
  for (int j = 0; j < basisSize; j++) {
    for (int k = 0; k < basisSize; k++) {
      PDESource(&luh[idx(j, k, 0)], src);      
      for (int l = 0; l < numberOfVariables; l++) {
        luh_new[idx(j, k, l)] +=
            dt * src;
      }
    }
  }

  return dt_max_allowed;
}

}  // namespace c
}  // namespace godunov
}  // namespace finitevolumes
}  // namespace kernels

#endif  // DIMENSIONS == 2
