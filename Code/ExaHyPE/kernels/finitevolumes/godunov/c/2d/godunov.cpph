/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

#include <cassert>
#include <cmath>
#include <limits>
#include <utility>
#include <vector>

#include "../../../../../../Peano/tarch/la/Vector.h"
#include "../../../../KernelUtils.h"

#if DIMENSIONS == 2

namespace {

double minmod(double a, double b) {
  assert(std::isfinite(a));
  assert(std::isfinite(b));

  if (a * b < 0.0) {  // sign is different (alternative: std::signbit and xor)
    return 0.0;
  } else {
    if (std::abs(a) < std::abs(b)) {
      return a;
    } else {
      return b;
    }
  }
}

}  // namespace

namespace kernels {
namespace finitevolumes {
namespace godunov {
namespace c {

/**
 * A simple Rusanov flux considering pointwise
 * left and right values.
 */ 
template <void PDEEigenvalues(const double* const Q, const int normalNonZero,
                              double* lambda),
          void PDEFlux(const double* const Q, double** F)>
double riemannSolver(double* F, const double* qL, const double* qR,
                     int numberOfVariables, int normalNonZero,
                     double** tempStateSizedArrays) { // TODO(Dominic): I need four of those
  double* sL = tempStateSizedArrays[0]; 
  double* sR = tempStateSizedArrays[1];

  PDEEigenvalues(qL, normalNonZero, sL);
  PDEEigenvalues(qR, normalNonZero, sR);

  double s_max = -1.0;
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sL_i = std::abs(sL[i]);
    if (abs_sL_i > s_max) { // TODO(Dominic): Change to 
      s_max = abs_sL_i;
    }
  }
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sR_i = std::abs(sR[i]);
    if (abs_sR_i > s_max) { // TODO(Dominic): Change to 
      s_max = abs_sR_i;
    }
  }

  double* FL[2] = {tempStateSizedArrays[0],tempStateSizedArrays[1]}; // TODO(Dominic): MAKE FL and FR input arguments
  double* FR[2] = {tempStateSizedArrays[2],tempStateSizedArrays[3]};
  PDEFlux(qL, FL);
  PDEFlux(qR, FR);

  for (int i = 0; i < numberOfVariables; i++) {
    F[i] = 0.5 * (FL[normalNonZero][i] + FR[normalNonZero][i]) +
           0.5 * s_max * (qL[i] - qR[i]);
  }

  return s_max;  // TODO(guera): Use to check if dt was okay in surfaceIntegral
}

template <void PDEEigenvalues(const double* const Q, const int normalNonZero,
                              double* lambda),
          void PDEFlux(const double* const Q, double** F)>
double riemannSolver(double* FL, double* FR, const double* QL, const double* QR,
                     int basisSize, int numberOfVariables, int normalNonZero,
                     double** tempStateSizedArrays) { // TODO(Dominic): I need four of those
  double s_max = -1.0;
    
  idx2 idx_Fn(basisSize,numberOfVariables);
  
  for (int i=0; i<basisSize; ++i) {
    double s_max_n = 
        riemannSolver<PDEEigenvalues, PDEFlux>(
            FL+idx_Fn(i,0),
            QL[i],
            QR[i], 
            numberOfVariables, normalNonZero,
            &tempStateSizedArrays[1]);
    s_max = std::max( s_max_n, s_max );
  }
  
  std::copy(FL,FL + basisSize*numberOfVariables, FR);
  return s_max;  // TODO(guera): Use to check if dt in solutionUpdate was OK
}

void solutionUpdatePatchBoundary(
    double* luh_new,const double* lFhbnd,
    const tarch::la::Vector<DIMENSIONS, double>& dx,
    double dt, 
    int normalNonZero,
    int leftOrRight,
    int numberOfVariables,
    int basisSize) {
  // layout: x_i-1/2, x_i+1/2, y_j-1/2, y_j+1/2
  idx3 idx(basisSize,basisSize,numberOfVariables);
  idx2 idx_Fn(basisSize,numberOfVariables);
  const double cellSize[2] = {dx[0]/basisSize, dx[1]/basisSize};
  int faceIndex = 2*normalNonZero + leftOrRight;
  
  if (faceIndex==0) {
    for (int i=0; i<basisSize; ++i) {
      for (int l=0; l<basisSize; ++l) {
        luh_new[idx(i,0,l)]         += sign* dt / cellSize[0] * lFhbnd[0][idx_Fn(i,l)];
      }
    }
  } else if (faceIndex==1) {
    for (int i=0; i<basisSize; ++i) {
      for (int l=0; l<basisSize; ++l) {
        luh_new[idx(i,basisSize,l)] += sign* dt / cellSize[0] * lFhbnd[1][idx_Fn(i,l)];
      }
    }
  } else if (faceIndex==2) {
    for (int i=0; i<basisSize; ++i) {
      for (int l=0; l<basisSize; ++l) {
        luh_new[idx(0,i,l)]         += sign* dt / cellSize[1] * lFhbnd[2][idx_Fn(i,l)];
      }
    }
  } else if (faceIndex==3) {
    for (int i=0; i<basisSize; ++i) {
      for (int l=0; l<basisSize; ++l) {
        luh_new[idx(basisSize,i,l)] += sign* dt / cellSize[1] * lFhbnd[3][idx_Fn(i,l)];
      }
    }
  }
}

/** 
 * Extrapolate the interior degrees of freedom onto the boundary.
 * 
 * Memory layout: [x_i-1/2], [x_i+1/2], [y_j-1/2], [y_j+1/2] *basisSize,numberOfVariables 
 */
void extrapolation(double* luhbnd,const double* luh, int numberOfVariables,
                  int basisSize) {
  idx3 idx(basisSize,basisSize,numberOfVariables);
  idx2 idx_Fn(basisSize,numberOfVariables);
  
  for (int i=0; i<basisSize; ++i) {
    std::copy(luh+idx(i,0,0),        luh+idx(i,0,0)        +numberOfVariables,luhbnd[0]+idx_Fn(i,0));
    std::copy(luh+idx(i,basisSize,0),luh+idx(i,basisSize,0)+numberOfVariables,luhbnd[1]+idx_Fn(i,0));
    std::copy(luh+idx(0,i,0),        luh+idx(0,i,0)        +numberOfVariables,luhbnd[2]+idx_Fn(i,0));
    std::copy(luh+idx(basisSize,i,0),luh+idx(basisSize,i,0)+numberOfVariables,luhbnd[3]+idx_Fn(i,0));
  }
}

/**
 * Solves all the Riemann problems that do only require
 * internal data and add the result directly onto the
 * new solution. 
 * Finally add the source terms.
 */
template <void PDEFlux(const double* const Q, double** F),
          void PDESource(const double* const Q, double* S),
          void PDEEigenvalues(const double* const Q, const int normalNonZero,
                              double* lambda)>
double solutionUpdatePatchInterior(double* luh_new,
                      double* luh,
                      const tarch::la::Vector<DIMENSIONS, double>& dx,
                      double dt, int numberOfVariables, int basisSize) { // everything is done in the interior
  const int basisSize2 = basisSize * basisSize;
  idx3 idx(basisSize, basisSize, numberOfVariables);
  
  const double cellSize[2] = {dx[0]/basisSize, dx[1]/basisSize};

  // 4. Solve interior Riemann problems
  double dt_max_allowed = std::numeric_limits<double>::max();
  static const double EXAHYPE_CFL_FACTOR = 0.9; // TODO(Dominic): Move this out.
  
  // todo I need five of those
  double** tempStateSizedArrays;
  
  // x edges 
  double* Fn = tempStateSizedArrays[0];
  for (int j = 0; j < basisSize; j++) {
    for (int k = 0; k < basisSize-1; k++) {
      double s_max_x = 
          riemannSolver<PDEEigenvalues, PDEFlux>(
              Fn, 
              luh + idx(j, k, 0),
              luh + idx(j, k+1, 0), 
              numberOfVariables, 0, &tempStateSizedArrays[1]);
      // TODO(guera): Improve. I'm quite sure this is not the correct/best
      // formula. TODO(Dominic): The division by DIMENSIONS might make sure that C_x+C_y < 1
      dt_max_allowed = std::min(
          dt_max_allowed, EXAHYPE_CFL_FACTOR / DIMENSIONS * cellSize[0] / s_max_x); // TODO(Dominic): Ignore this for a while
      
      for (int l=0; l<numberOfVariables; ++l) {
        luh_new[idx(j, k, l)]   += dt / cellSize[0] * Fn[l];  
        luh_new[idx(j, k+1, l)] -= dt / cellSize[0] * Fn[l];
      }
    }
  }

  // y edges
  double* Fn = tempStateSizedArrays[0];
  for (int j = 0; j < basisSize-1; j++) {
    for (int k = 0; k < basisSize; k++) {
      double s_max_y = riemannSolver<PDEEigenvalues, PDEFlux>(
          Fn, 
          luh + idx(j, k, 0),
          luh + idx(j+1, k, 0), 
          numberOfVariables, 1, &tempStateSizedArrays[1]); // TODO(Dominic): Merging of data happens here; read wRy wLy
      dt_max_allowed = std::min(
          dt_max_allowed, EXAHYPE_CFL_FACTOR / DIMENSIONS * cellSize[1] / s_max_y);
      
      for (int l=0; l<numberOfVariables; ++l) {
        luh_new[idx(j, k, l)]   += dt / cellSize[0] * Fn[l];  
        luh_new[idx(j+1, k, l)] -= dt / cellSize[0] * Fn[l];
    }
  }

  // TODO(guera): Early exit if dt > dt_max_allowed?!

  // 5. Add the source terms
  double* source = tempStateSizedArrays[0]; // temp var; state sized vector
  
  for (int j = 0; j < basisSize; j++) {
    for (int k = 0; k < basisSize; k++) {
      PDESource(&luh[idx(j, k, 0)], src);      
      for (int l = 0; l < numberOfVariables; l++) {
        luh_new[idx(j, k, l)] +=
            dt * src;
      }
    }
  }

  return dt_max_allowed;
}

}  // namespace c
}  // namespace godunov
}  // namespace finitevolumes
}  // namespace kernels

#endif  // DIMENSIONS == 2
