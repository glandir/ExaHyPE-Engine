/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

#include <cassert>
#include <cmath>
#include <limits>
#include <utility>
#include <vector>

#include "../../../../../../Peano/tarch/la/Vector.h"
#include "../../../../KernelUtils.h"

#if DIMENSIONS == 2

namespace {

double minmod(double a, double b) {
  assert(std::isfinite(a));
  assert(std::isfinite(b));

  if (a * b < 0.0) {  // sign is different (alternative: std::signbit and xor)
    return 0.0;
  } else {
    if (std::abs(a) < std::abs(b)) {
      return a;
    } else {
      return b;
    }
  }
}

}  // namespace

namespace kernels {
namespace finitevolumes {
namespace muscl {
namespace c {

template <void PDEEigenvalues(const double* const Q, const int normalNonZero,
                              double* lambda),
          void PDEFlux(const double* const Q, double** F)>
double riemannSolver(double* F, const double* qL, const double* qR,
                     int numberOfVariables, int normalNonZero,
                     double** tempStateSizedArrays) { // TODO(Dominic): I need four of those
  double* sL = tempStateSizedArrays[0]; 
  double* sR = tempStateSizedArrays[1];

  PDEEigenvalues(qL, normalNonZero, sL);
  PDEEigenvalues(qR, normalNonZero, sR);

  double s_max = -1.0;
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sL_i = std::abs(sL[i]);
    if (abs_sL_i > s_max) {
      s_max = abs_sL_i;
    }
  }
  for (int i = 0; i < numberOfVariables; i++) {
    const double abs_sR_i = std::abs(sR[i]);
    if (abs_sR_i > s_max) {
      s_max = abs_sR_i;
    }
  }

  double* FL[2] = {tempStateSizedArrays[0],tempStateSizedArrays[1]};
  double* FR[2] = {tempStateSizedArrays[2],tempStateSizedArrays[3]};
  PDEFlux(qL, FL);
  PDEFlux(qR, FR);

  for (int i = 0; i < numberOfVariables; i++) {
    F[i] = 0.5 * (FL[normalNonZero][i] + FR[normalNonZero][i]) +
           0.5 * s_max * (qL[i] - qR[i]);
  }

  return s_max;  // TODO(guera): Use to check if dt in solutionUpdate was OK
}

template <void PDEFlux(const double* const Q, double** F),
          void PDESource(const double* const Q, double* S),
          void PDEEigenvalues(const double* const Q, const int normalNonZero,
                              double* lambda)>
double solutionUpdate(double* luh_new,
                      const tarch::la::Vector<DIMENSIONS, double>& dx,
                      double dt, int numberOfVariables, int basisSize) { // everything is done in the interior
//  const int size_extended =
//      (basisSize + 2) * (basisSize + 2) * numberOfVariables;
//  idx3 idx_extended(basisSize + 2, basisSize + 2, numberOfVariables);
  const int basisSize2 = basisSize * basisSize;
  idx3 idx(basisSize, basisSize, numberOfVariables);
  
  const double cellSize[2] = {dx[0]/basisSize, dx[1]/basisSize};

  // 2. Compute slopes
  const int slopesPerCoordinateAxis = (basisSize-2)*basisSize*numberOfVariables
  double* slopex = new double[slopesPerCoordinateAxis]; // temp: basisSize2*numberOfVariables
  double* slopey = new double[slopesPerCoordinateAxis]; // temp: basisSize2*numberOfVariables

  std::fill(slopex, slopesPerCoordinateAxis, 0.0);
  std::fill(slopey, slopesPerCoordinateAxis, 0.0);

  // x-slopes
  for (int j = 0; j < basisSize; j++) {
    for (int k = 1; k < basisSize-1; k++) {
      for (int l = 0; l < numberOfVariables; l++) {
        slopex[idx(j, k, l)] =
            minmod(luh[idx(j, k + 1, l)] - luh[idx(j, k, l)],
                   luh[idx(j, k, l)] - luh[idx(j, k - 1, l)]);
      }
    }
  }
  // y-slopes
  for (int j = 1; j < basisSize-1; j++) {
    for (int k = 0; k < basisSize; k++) {
      for (int l = 0; l < numberOfVariables; l++) {
        slopey[idx(j, k, l)] =
            minmod(luh[idx(j + 1, k, l)] - luh[idx(j, k, l)],
                luh[idx(j, k, l)] - luh[idx(j - 1, k, l)]);
      }
    }
  }

  // 3. Source evaluation, boundary extrapolation and time evolution
  double* flx = new double[numberOfVariables * DIMENSIONS]; // temp var; DIMENSIONS*numberOfVariables
  double* F[DIMENSIONS] = {flx, flx + numberOfVariables};
  double* src = new double[numberOfVariables];

  double* slopet = new double[slopesPerCoordinateAxis];
  
  double* wLx = new double[slopesPerCoordinateAxis]; // temp var; ~slopesPerCoordinateAxis
  double* wRx = new double[slopesPerCoordinateAxis]; // temp var; 
  double* wLy = new double[slopesPerCoordinateAxis]; // temp var; 
  double* wRy = new double[slopesPerCoordinateAxis]; // temp var; 

  std::fill(wLx, wLx + slopesPerCoordinateAxis, 0.0);
  std::fill(wRx, wRx + slopesPerCoordinateAxis, 0.0);
  std::fill(wLy, wLy + slopesPerCoordinateAxis, 0.0);
  std::fill(wRy, wRy + slopesPerCoordinateAxis, 0.0);
  
  // x-extrapolated values TODO(Dominic): Can this be combined with the slopex loop?
  for (int j = 0; j < basisSize; j++) {
    for (int k = 1; k < basisSize-1; k++) {
      double* Qt = slopet + idx(j, k, 0);
      // source
      PDESource(luh + idx(j, k, 0), Qt);

      // x
      for (int l = 0; l < numberOfVariables; l++) {
        wLx[idx(j, k, l)] =
            luh[idx(j, k, l)] - 0.5 * slopex[idx(j, k, l)]; // write;
        wRx[idx(j, k, l)] =
            luh[idx(j, k, l)] + 0.5 * slopex[idx(j, k, l)]; // write;
      }

      PDEFlux(wLx + idx(j, k, 0), F);
      for (int l = 0; l < numberOfVariables; l++) {
        Qt[l] += F[0][l] / cellSize[0];
      }

      PDEFlux(wRx + idx(j, k, 0), F);
      for (int l = 0; l < numberOfVariables; l++) {
        Qt[l] -= F[0][l] / cellSize[0];
      }

      // y
      for (int l = 0; l < numberOfVariables; l++) {
        wLy[idx(j, k, l)] =
            luh[idx(j, k, l)] - 0.5 * slopey[idx(j, k, l)]; // write 
        wRy[idx(j, k, l)] =
            luh[idx(j, k, l)] + 0.5 * slopey[idx(j, k, l)]; // write
      }

      PDEFlux(wLy + idx(j, k, 0), F); // read
      for (int l = 0; l < numberOfVariables; l++) { 
        Qt[l] += F[1][l] / cellSize[1];
      }
 
      PDEFlux(wRy + idx(j, k, 0), F); // read
      for (int l = 0; l < numberOfVariables; l++) { 
        Qt[l] -= F[1][l] / cellSize[1];
      }

      // Evolve
      for (int l = 0; l < numberOfVariables; l++) {
        wLx[idx(j, k, l)] += 0.5 * dt * Qt[l]; // read,write
        wRx[idx(j, k, l)] += 0.5 * dt * Qt[l]; // read,write
        wLy[idx(j, k, l)] += 0.5 * dt * Qt[l]; // read,write
        wRy[idx(j, k, l)] += 0.5 * dt * Qt[l]; // read,write
      }
    }
  }

  // 4. Solve Riemann problems
  double* Fx = new double[numberOfVariables * basisSize * (basisSize + 1)];
  double* Fy = new double[numberOfVariables * basisSize * (basisSize + 1)];

  idx3 idx_Fx(basisSize, basisSize + 1, numberOfVariables);
  idx3 idx_Fy(basisSize + 1, basisSize, numberOfVariables);

  double dt_max_allowed = std::numeric_limits<double>::max();
  static const double EXAHYPE_CFL_FACTOR = 0.9;

  // x edges
  for (int j = 0; j < basisSize; j++) {
    for (int k = 0; k < basisSize + 1; k++) {
      double s_max_x = riemannSolver<PDEEigenvalues, PDEFlux>(
          Fx + idx_Fx(j, k, 0), wRx + idx_extended(j + 1, k, 0),
          wLx + idx_extended(j + 1, k + 1, 0), numberOfVariables, 0); // TODO(Dominic): Merging of data happens here; read wRx wLx
      // TODO(guera): Improve. I'm quite sure this is not the correct/best
      // formula.
      dt_max_allowed = std::min(
          dt_max_allowed, EXAHYPE_CFL_FACTOR / DIMENSIONS * cellSize[0] / s_max_x);
    }
  }

  // y edges
  for (int j = 0; j < basisSize + 1; j++) {
    for (int k = 0; k < basisSize; k++) {
      double s_max_y = riemannSolver<PDEEigenvalues, PDEFlux>(
          Fy + idx_Fy(j, k, 0), wRy + idx_extended(j, k + 1, 0),
          wLy + idx_extended(j + 1, k + 1, 0), numberOfVariables, 1); // TODO(Dominic): Merging of data happens here; read wRy wLy
      dt_max_allowed = std::min(
          dt_max_allowed, EXAHYPE_CFL_FACTOR / DIMENSIONS * cellSize[1] / s_max_y);
    }
  }

  // TODO(guera): Early exit if dt > dt_max_allowed?!

  // 5. Evolve, evaluate source, update cells
  double* ws = new double[numberOfVariables];

  for (int j = 0; j < basisSize; j++) {
    for (int k = 0; k < basisSize; k++) {
      for (int l = 0; l < numberOfVariables; l++) {
        ws[l] = luh[idx_extended(j + 1, k + 1, l)] +
                0.5 * slopet[idx_extended(j + 1, k + 1, l)];
      }
      PDESource(ws, src);

      for (int l = 0; l < numberOfVariables; l++) {
        luh_new[idx(j, k, l)] +=
            dt / cellSize[0] * (Fx[idx_Fx(j, k, l)] - Fx[idx_Fx(j, k + 1, l)]) +
            dt / cellSize[1] * (Fy[idx_Fy(j, k, l)] - Fy[idx_Fy(j + 1, k, l)]) +
            dt * src[l];
      }
    }
  }

  delete[] luh;
  delete[] slopex;
  delete[] slopey;
  delete[] flx;
  delete[] src;
  delete[] slopet;
  delete[] wLx;
  delete[] wRx;
  delete[] wLy;
  delete[] wRy;
  delete[] Fx;
  delete[] Fy;
  delete[] ws;

  return dt_max_allowed;
}

}  // namespace c
}  // namespace muscl
}  // namespace finitevolumes
}  // namespace kernels

#endif  // DIMENSIONS == 2
