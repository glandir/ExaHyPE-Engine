#include "../Kernels.h"

#include "string.h"

#include "tarch/la/Scalar.h"
#include "tarch/la/ScalarOperations.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/DGMatrices.h"

#define EXAHYPE_CFL_FACTOR 0.9

#include <fstream> 

using std::endl;
using std::cout;

extern "C" 
{
  void aderriemannsolver_(double *lQbndL, double *lFbndL, double *lQbndR, double *lFbndR, double *nv);
}

// todo Dominic Etienne Charrier
// Possibly redundant definition of face indices
// see exahype/solvers/Solver.h
// On the other hand, the kernels should be
// more or less independent of ExaHyPE/exahype.
#define EXAHYPE_FACE_LEFT   0
#define EXAHYPE_FACE_RIGHT  1
#define EXAHYPE_FACE_FRONT  2
#define EXAHYPE_FACE_BACK   3
#define EXAHYPE_FACE_BOTTOM 4
#define EXAHYPE_FACE_TOP    5


// todo change template parameter in header and generator
// template <void PDEFlux2d(const double * const Q, double * f, double * g)>
template <void PDEEigenvalues(const double * const Q,const int normalNonZero,double * lambda)>
void kernels::aderdg::generic::riemannSolver(
    double * FL,
    double * FR,
    const double * const QL,
    const double * const QR,
    const double dt,
    const int normalNonZero,
    const int numberOfVariables,
    const int basisSize
){

  double* QlFortran = new double[numberOfVariables*basisSize*basisSize];
  for(int i=0; i < numberOfVariables*basisSize*basisSize; i++){
    QlFortran[i] = QL[i];
  }

  double* QrFortran = new double[numberOfVariables*basisSize*basisSize];
  for(int i=0; i < numberOfVariables*basisSize*basisSize; i++){
    QrFortran[i] = QR[i];
  }

  double* FlFortran = new double[numberOfVariables*basisSize*basisSize];
  for(int i=0; i < numberOfVariables*basisSize*basisSize; i++){
    FlFortran[i] = FL[i];
  }

  double* FrFortran = new double[numberOfVariables*basisSize*basisSize];
  for(int i=0; i < numberOfVariables*basisSize*basisSize; i++){
    FrFortran[i] = FR[i];
  }

  double* nv = new double[3];
  nv[0] = 0.0;
  nv[1] = 0.0;
  nv[2] = 0.0;
  nv[normalNonZero] = 1.0;
  
  aderriemannsolver_(QlFortran, FlFortran, QrFortran, FrFortran, nv);
  
  // // Permutation of lQbnd

  // // for(int i=0; i < numberOfVariables*6*basisSize*basisSize; i++){
    // // lFbndFortran[i] = i;
  // // }
  
  // for (int bb=0; bb<basisSize; bb++) {  // loop over dof
    // for (int aa=0; aa<basisSize; aa++) {
      // for(int ivar=0; ivar < numberOfVariables; ivar++) {
        // for(int face=0; face < 6; face++) {
          // lQbnd[p2f4(ivar, face, aa, bb)] = lQbndFortran[f2p4(ivar, face, aa, bb)];
        // }
      // }
    // }
  // }    

  
  
  
  // std::ofstream ofs;
  // ofs.open ("aoutput_lQbnd.txt", std::ofstream::out);
  // for (int ii=0; ii<numberOfVariables*6*basisSize*basisSize; ii++) {
    // ofs << lQbnd[ii] << "\n";
  // }
  // ofs.close();

  // ofs.open ("aoutput_lQbndFortran.txt", std::ofstream::out);
  // for (int ii=0; ii<numberOfVariables*6*basisSize*basisSize; ii++) {
    // ofs << lQbndFortran[ii] << "\n";
  // }
  // ofs.close();

  delete[] QlFortran;
  delete[] QrFortran;
  delete[] FlFortran;
  delete[] FrFortran;
  delete[] nv;  
}

