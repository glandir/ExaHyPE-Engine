#include "Kernels.h"

#include "string.h"

#include "tarch/la/Scalar.h"
#include "tarch/la/ScalarOperations.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/DGMatrices.h"

#define EXAHYPE_CFL_FACTOR 0.9

#include <fstream> 

using std::endl;
using std::cout;

extern "C" 
{
  void aderriemannsolver_(double *lQbndL, double *lFbndL, double *lQbndR, double *lFbndR, double *nv);
}

// todo Dominic Etienne Charrier
// Possibly redundant definition of face indices
// see exahype/solvers/Solver.h
// On the other hand, the kernels should be
// more or less independent of ExaHyPE/exahype.
#define EXAHYPE_FACE_LEFT   0
#define EXAHYPE_FACE_RIGHT  1
#define EXAHYPE_FACE_FRONT  2
#define EXAHYPE_FACE_BACK   3
#define EXAHYPE_FACE_BOTTOM 4
#define EXAHYPE_FACE_TOP    5


// todo change template parameter in header and generator
// template <void PDEFlux2d(const double * const Q, double * f, double * g)>
template <void PDEEigenvalues(const double * const Q,const int normalNonZero,double * lambda)>
void kernels::aderdg::generic::riemannSolver(
    double * FL,
    double * FR,
    const double * const QL,
    const double * const QR,
    const double dt,
    const int normalNonZero,
    const int numberOfVariables,
    const int basisSize
){

#if DIMENSIONS == 2
  double* QavL    = new double[numberOfVariables];
  double* QavR    = new double[numberOfVariables];
  double* lambdaL = new double[numberOfVariables];
  double* lambdaR = new double[numberOfVariables];

  // Compute the average states from the left and the right, which we need to compute the numerical dissipation
  memset((double *) QavL,0,numberOfVariables * sizeof(double));
  memset((double *) QavR,0,numberOfVariables * sizeof(double));

  for (int ii=0; ii<basisSize; ii++) { // loop over dof
    const int nodeIndex     = ii;
    const int dofStartIndex = nodeIndex * numberOfVariables;

    double weight =  kernels::gaussLegendreWeights[basisSize-1][ii];

    for(int ivar=0; ivar < numberOfVariables; ivar++) {
      QavL[ivar] +=  weight * QL[dofStartIndex+ivar];
      QavR[ivar] +=  weight * QR[dofStartIndex+ivar];
    }
  }
  //
  // Here, we implement a very simple Rusanov scheme with scalar dissipation (smax*Id).
  // We can change this into a more sophisticated Osher or HLLEM Riemann solver whenever needed.
  //
  PDEEigenvalues(QavL,normalNonZero,lambdaL);
  PDEEigenvalues(QavR,normalNonZero,lambdaR);

  double sMax = 0;
  for(int ivar=0; ivar < numberOfVariables; ivar++) {
    sMax = std::max(sMax,std::max(fabs(lambdaL[ivar]),fabs(lambdaR[ivar])));
  }
  //
  // We now compute the numerical flux. Note that the scheme is at the moment written in
  // CONSERVATION FORM => no fluctuations, but real fluxes.
  // Later, this will be converted into the left and right fluctuations.
  //
  for (int ii=0; ii<basisSize; ii++) { // loop over dof
    const int nodeIndex     = ii;
    const int dofStartIndex = nodeIndex * numberOfVariables;

    // sum can only be done if all contributions are up
    for(int ivar=0; ivar < numberOfVariables; ivar++) {
      FL[dofStartIndex+ivar] = 0.5 * (FL[dofStartIndex+ivar] + FR[dofStartIndex+ivar])
                                                -0.5 * sMax *  (QR[dofStartIndex+ivar] - QL[dofStartIndex+ivar]);

      FR[dofStartIndex+ivar] = FL[dofStartIndex+ivar];
    }
  }
  //  // @todo 04/02/16:Dominic Etienne Charrier
  //  // for debugging purposes
  //  int _errors = 0;
  //  bool _error = false;
  //  std::cout << "sMax" << sMax << std::endl;
  //  validateNumericalEqualsWithEps(sMax, 1.18321595661992, 1e-10);

  delete[] QavL;
  delete[] QavR;
  delete[] lambdaL;
  delete[] lambdaR;
  
#elif DIMENSIONS == 3  




    double* QlFortran = new double[numberOfVariables*basisSize*basisSize];
    for(int i=0; i < numberOfVariables*basisSize*basisSize; i++){
      QlFortran[i] = QL[i];
    }

    double* QrFortran = new double[numberOfVariables*basisSize*basisSize];
    for(int i=0; i < numberOfVariables*basisSize*basisSize; i++){
      QrFortran[i] = QR[i];
    }

    double* FlFortran = new double[numberOfVariables*basisSize*basisSize];
    for(int i=0; i < numberOfVariables*basisSize*basisSize; i++){
      FlFortran[i] = FL[i];
    }

    double* FrFortran = new double[numberOfVariables*basisSize*basisSize];
    for(int i=0; i < numberOfVariables*basisSize*basisSize; i++){
      FrFortran[i] = FR[i];
    }

    double nv[3] = {0.0, 0.0, 0.0};
    nv[normalNonZero] = 1.0;
    
    aderriemannsolver_(QlFortran, FlFortran, QrFortran, FrFortran, &nv[0]);
    
    // // Permutation of lQbnd

    // // for(int i=0; i < numberOfVariables*6*basisSize*basisSize; i++){
      // // lFbndFortran[i] = i;
    // // }
    
    // for (int bb=0; bb<basisSize; bb++) {  // loop over dof
      // for (int aa=0; aa<basisSize; aa++) {
        // for(int ivar=0; ivar < numberOfVariables; ivar++) {
          // for(int face=0; face < 6; face++) {
            // lQbnd[p2f4(ivar, face, aa, bb)] = lQbndFortran[f2p4(ivar, face, aa, bb)];
          // }
        // }
      // }
    // }    

    
    
    
    // std::ofstream ofs;
    // ofs.open ("aoutput_lQbnd.txt", std::ofstream::out);
    // for (int ii=0; ii<numberOfVariables*6*basisSize*basisSize; ii++) {
      // ofs << lQbnd[ii] << "\n";
    // }
    // ofs.close();

    // ofs.open ("aoutput_lQbndFortran.txt", std::ofstream::out);
    // for (int ii=0; ii<numberOfVariables*6*basisSize*basisSize; ii++) {
      // ofs << lQbndFortran[ii] << "\n";
    // }
    // ofs.close();

    delete[] QlFortran;
    delete[] QrFortran;
    delete[] FlFortran;
    delete[] FrFortran;
    

#endif
  
}

