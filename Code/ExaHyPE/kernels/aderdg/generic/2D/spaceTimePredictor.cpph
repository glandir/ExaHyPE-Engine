#include "../Kernels.h"

#include "string.h"

#include "tarch/la/Scalar.h"
#include "tarch/la/ScalarOperations.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/DGMatrices.h"

#define EXAHYPE_CFL_FACTOR 0.9

#include <fstream>

using std::endl;
using std::cout;

template <void PDEFlux2d(const double* const Q, double* f, double* g)>
void kernels::aderdg::generic::c::spaceTimePredictor(
    double* lQi, double* lFi, double* lQhi, double* lFhi, double* lQhbnd,
    double* lFhbnd, const double* const luh,
    const tarch::la::Vector<DIMENSIONS, double>& dx, const double dt,
    const int numberOfVariables, const int basisSize) {
  // todo Angelika
  // Please remove the typedefs in generic kernels again since numberOf(...)Dof
  // is not
  // a compile time variable anymore
  // helper variables
  // const int order = basisSize-1;

  // UNCOMMENT FOR DEBUGGING PURPOSES
  //  lQi[0] = 1;
  //  lFi[0] = 2;
  //  lQhi[0] = 3;
  //  lFhi[0] = 4;
  //
  //  constexpr int numberOfFaceDof = 5 * (3+1);
  //
  //  lQhbnd[EXAHYPE_FACE_LEFT*numberOfFaceDof] = 11;
  //  lFhbnd[EXAHYPE_FACE_LEFT*numberOfFaceDof] = 21;
  //
  //  lQhbnd[EXAHYPE_FACE_RIGHT*numberOfFaceDof] = 12;
  //  lFhbnd[EXAHYPE_FACE_RIGHT*numberOfFaceDof] = 22;
  //
  //  lQhbnd[EXAHYPE_FACE_FRONT*numberOfFaceDof] = 13;
  //  lFhbnd[EXAHYPE_FACE_FRONT*numberOfFaceDof] = 23;
  //
  //  lQhbnd[EXAHYPE_FACE_BACK*numberOfFaceDof] = 14;
  //  lFhbnd[EXAHYPE_FACE_BACK*numberOfFaceDof] = 24;
  constexpr int dim = DIMENSIONS;                // 2
  constexpr int dimTimesTwo = (2 * DIMENSIONS);  // 4
  constexpr int BASISSIZE = (3 + 1);             // basisSize=order+1
  constexpr int NVAR = 5;                        // numberOfVariables

  // helper variables
  constexpr int numberOfSpaceTimeDof =
      NVAR * BASISSIZE * BASISSIZE *
      BASISSIZE; /*tarch::la::aPowI(dim+1,BASISSIZE); */
  constexpr int numberOfDof =
      NVAR * BASISSIZE * BASISSIZE; /*tarch::la::aPowI(dim,BASISSIZE);*/

  double* rhs0 = new double[numberOfSpaceTimeDof];
  double* rhs = new double[numberOfSpaceTimeDof];
  double* tmp = new double[numberOfVariables * basisSize];

  for (int ii = 0; ii < BASISSIZE; ii++) {  // loop over dof
    for (int jj = 0; jj < BASISSIZE; jj++) {
      for (int ll = 0; ll < BASISSIZE; ll++) {  // loop over dof
        // location and index of nodal degrees of freedom
        const int nodeIndex = ii + BASISSIZE * jj;
        const int spaceTimeNodeIndex =
            ii + BASISSIZE * jj + BASISSIZE * BASISSIZE * ll;

        const int dofStartIndex = nodeIndex * NVAR;
        const int spaceTimeDofStartIndex = spaceTimeNodeIndex * NVAR;

        for (int ivar = 0; ivar < NVAR; ivar++) {
          // Trivial initial guess (can be significantly improved)
          lQi[spaceTimeDofStartIndex + ivar] = luh[dofStartIndex + ivar];

          // Compute the contribution of the initial condition uh to the time
          // update. I prefer to compute it once
          // and store it in rhs0, but if you think it is faster, you can also
          // recompute this contribution
          // inside the Picard loop (DO iter = 1, N+1)
          rhs0[spaceTimeDofStartIndex + ivar] =
              kernels::gaussLegendreWeights[BASISSIZE - 1][ii] *
              kernels::gaussLegendreWeights[BASISSIZE - 1][jj] *
              kernels::F0[BASISSIZE - 1][ll] * luh[dofStartIndex + ivar];
        }
      }
    }
  }
  // Above seems to work!

  double* Q;
  double* f;
  double* g;

  // double* dqdt = (double*) std::malloc(NVAR * BASISSIZE * sizeof(double)); //
  // todo this is just for debugging; in general, do not use mallocs

  // Discrete Picard iterations. This set of nested loops should (theoretically)
  // be a dream for vectorization, since they are rather independent...
  for (int iter = 1; iter < BASISSIZE + 1; iter++) {
    // Compute the fluxes (once these fluxes are available, the subsequent
    // operations are independent from each other)
    for (int ll = 0; ll < BASISSIZE; ll++) {    // loop over dof (time)
      for (int ii = 0; ii < BASISSIZE; ii++) {  // loop over dof
        for (int jj = 0; jj < BASISSIZE; jj++) {
          const int nodeIndex = ii + BASISSIZE * jj;
          const int spaceTimeNodeIndex = nodeIndex + BASISSIZE * BASISSIZE * ll;

          const int spaceTimeDofStartIndex = spaceTimeNodeIndex * NVAR;
          const int spaceTimeFluxDofStartIndex = spaceTimeDofStartIndex * dim;

          Q = &lQi[spaceTimeDofStartIndex];
          f = &lFi[spaceTimeFluxDofStartIndex];
          g = &lFi[spaceTimeFluxDofStartIndex + NVAR];

          // @todo Angelika's old code
          // exahype::problem::PDEFlux(Q,f,g);
          PDEFlux2d(Q, f, g);
        }
      }
      // Above seems okay!

      // x direction (independent from the y and z derivatives)
      // Kxi : BASISSIZE * BASISSIZE
      // lFh : NVAR * BASISSIZE

      // Compute the "derivatives" (contributions of the stiffness matrix)
      // x direction (independent from the y and z derivatives)
      for (int ii = 0; ii < BASISSIZE; ii++) {  // loop over dof
        for (int jj = 0; jj < BASISSIZE; jj++) {
          const int nodeIndex = ii + BASISSIZE * jj;
          const int spaceTimeNodeIndex = nodeIndex + BASISSIZE * BASISSIZE * ll;
          const int spaceTimeDofStartIndex = spaceTimeNodeIndex * NVAR;

          double weight = kernels::gaussLegendreWeights[BASISSIZE - 1][ll] *
                          kernels::gaussLegendreWeights[BASISSIZE - 1][jj];

          // COMPUTE SPATIAL DERIVATIVES FOR TESTING PURPOSES
          // for (int ll=0; ll < BASISSIZE; ll++) { // set tmp = 0
          //  for(int ivar=0; ivar < NVAR; ivar++) {
          //    tmp[ivar + NVAR*ll] = 0.;
          //  }
          //}
          //
          // for(int mm=0; mm < BASISSIZE; mm++) {
          //  const int mmNodeIndex        = mm + BASISSIZE * jj;
          //  const int mmSpaceTimeNodeIndex         = mmNodeIndex  + BASISSIZE
          //  * BASISSIZE * ll;
          //  const int mmSpaceTimeDofStartIndex     = mmSpaceTimeNodeIndex *
          //  NVAR;
          //  const int mmSpaceTimeFluxDofStartIndex = mmSpaceTimeDofStartIndex
          //  * dim;
          //
          //  Q = &(lQi [mmSpaceTimeDofStartIndex]);
          //  for(int ivar=0; ivar < NVAR; ivar++) {
          //    tmp[ivar] += 1./dxPatch * dg::dudx[ii][mm] * Q[ivar];
          //  }
          //}
          for (int ivar = 0; ivar < NVAR; ivar++) {
            rhs[spaceTimeDofStartIndex + ivar] =
                rhs0[spaceTimeDofStartIndex + ivar];
          }

          for (int mm = 0; mm < BASISSIZE; mm++) {
            const int mmNodeIndex = mm + BASISSIZE * jj;
            const int mmSpaceTimeNodeIndex =
                mmNodeIndex + BASISSIZE * BASISSIZE * ll;
            const int mmSpaceTimeDofStartIndex = mmSpaceTimeNodeIndex * NVAR;
            const int mmSpaceTimeFluxDofStartIndex =
                mmSpaceTimeDofStartIndex * dim;

            f = &lFi[mmSpaceTimeFluxDofStartIndex];

            for (int ivar = 0; ivar < NVAR; ivar++) {
              rhs[spaceTimeDofStartIndex + ivar] -=
                  weight * dt / dx[0] * kernels::Kxi[BASISSIZE - 1][mm][ii] *
                  f[ivar];
            }
          }
        }
      }
      // Above seems okay!

      // Compute the "derivatives" (contributions of the stiffness matrix)
      // y direction (independent from the x and z derivatives)
      for (int ii = 0; ii < BASISSIZE; ii++) {  // loop over dof
        for (int jj = 0; jj < BASISSIZE; jj++) {
          const int nodeIndex = ii + BASISSIZE * jj;
          const int spaceTimeNodeIndex = nodeIndex + BASISSIZE * BASISSIZE * ll;
          const int spaceTimeDofStartIndex = spaceTimeNodeIndex * NVAR;

          double weight = kernels::gaussLegendreWeights[BASISSIZE - 1][ll] *
                          kernels::gaussLegendreWeights[BASISSIZE - 1][ii];

          for (int mm = 0; mm < BASISSIZE; mm++) {
            const int mmNodeIndex = ii + BASISSIZE * mm;
            const int mmSpaceTimeNodeIndex =
                mmNodeIndex + BASISSIZE * BASISSIZE * ll;
            const int mmSpaceTimeDofStartIndex = mmSpaceTimeNodeIndex * NVAR;
            const int mmSpaceTimeFluxDofStartIndex =
                mmSpaceTimeDofStartIndex * dim;

            g = &lFi[mmSpaceTimeFluxDofStartIndex + NVAR];

            for (int ivar = 0; ivar < NVAR; ivar++) {
              rhs[spaceTimeDofStartIndex + ivar] -=
                  weight * dt / dx[1] * kernels::Kxi[BASISSIZE - 1][mm][jj] *
                  g[ivar];
            }
          }
        }
      }
    }  // end of time dof loop

    // Above seems okay!

    for (int ii = 0; ii < BASISSIZE; ii++) {  // loop over dof
      for (int jj = 0; jj < BASISSIZE; jj++) {
        const int nodeIndex = ii + BASISSIZE * jj;

        double iWeight =
            1. / (kernels::gaussLegendreWeights[BASISSIZE - 1][ii] *
                  kernels::gaussLegendreWeights[BASISSIZE - 1][jj]);

        for (int ll = 0; ll < BASISSIZE; ll++) {  // set tmp = 0
          for (int ivar = 0; ivar < NVAR; ivar++) {
            tmp[ivar + NVAR * ll] = 0.;
          }
        }

        for (int ll = 0; ll < BASISSIZE; ll++) {  // loop over dof

          for (int nn = 0; nn < BASISSIZE; nn++) {
            const int nnSpaceTimeNodeIndex =
                nodeIndex + BASISSIZE * BASISSIZE * nn;
            const int nnSpaceTimeDofStartIndex = nnSpaceTimeNodeIndex * NVAR;

            for (int ivar = 0; ivar < NVAR; ivar++) {
              tmp[ivar + NVAR * ll] += iWeight *
                                       kernels::iK1[BASISSIZE - 1][ll][nn] *
                                       rhs[nnSpaceTimeDofStartIndex + ivar];
            }
          }
        }

        for (int ll = 0; ll < BASISSIZE; ll++) {  // loop over dof
          const int spaceTimeNodeIndex = nodeIndex + BASISSIZE * BASISSIZE * ll;
          const int spaceTimeDofStartIndex = spaceTimeNodeIndex * NVAR;

          for (int ivar = 0; ivar < NVAR; ivar++) {
            lQi[spaceTimeDofStartIndex + ivar] = tmp[ivar + NVAR * ll];
          }
        }

        // UNCOMMENT FOR DEBUGGING PURPOSES
        //        // dqdt
        //        for (int ll=0; ll < BASISSIZE; ll++) { // set tmp = 0
        //          for(int ivar=0; ivar < NVAR; ivar++) {
        //            dqdt[ivar + NVAR*ll] = 0.;
        //          }
        //        }
        //
        //        for (int ll=0; ll<BASISSIZE; ll++) { // loop over dof
        //
        //          for(int ivar=0; ivar < NVAR; ivar++) {
        //
        //            for(int nn=0; nn < BASISSIZE; nn++) {
        //              const int nnSpaceTimeNodeIndex         = nodeIndex  +
        //              BASISSIZE * BASISSIZE * nn;
        //              const int nnSpaceTimeDofStartIndex     =
        //              nnSpaceTimeNodeIndex * NVAR;
        //
        //              dqdt[ivar + NVAR*ll] += 1./dt * dg::dudx[ll][nn] *
        //                  lQi[nnSpaceTimeDofStartIndex+ivar];
        //            }
        //          }
        //        }
      }
    }
  }  // end of Picard iteration

  /////////////////////////////////////////////////
  // Post processing of the predictor:
  // Immediately compute the time-averaged space-time polynomials
  /////////////////////////////////////////////////
  constexpr int numberOfFluxDof = numberOfDof * dim;

  memset((double*)lQhi, 0, sizeof(double) * numberOfDof);
  memset((double*)lFhi, 0, sizeof(double) * numberOfFluxDof);

  // memory layout of lFhi:
  // lFhi = [ lFhi_x | lFhi_y ] ordered as
  // (a) lFhi_x[nDOF_y][nDOF_x][nVar]
  // (b) lFhi_y[nDOF_x][nDOF_y][nVar]
  // Note the order of lFhi_y. Rationale is that matrix multiplications
  // then no longer have strided access pattern
  //
  // For 3D the variables should be as follows.
  // lFhi = [ lFhi_x | lFhi_y | lFhi_z ] where
  // (a) lFhi_x[nDOF_z][nDOF_y][nDOF_x][nVar]
  // (b) lFhi_y[nDOF_z][nDOF_x][nDOF_y][nVar]
  // (c) lFhi_z[nDOF_x][nDOF_y][nDOF_z][nVar]
  //
  double* lFhi_x = &lFhi[0];
  double* lFhi_y = &lFhi[numberOfDof];

  for (int jj = 0; jj < BASISSIZE; jj++) {  // loop over dof
    for (int ii = 0; ii < BASISSIZE; ii++) {
      const int nodeIndex = ii + BASISSIZE * jj;
      const int dofStartIndex = nodeIndex * NVAR;
      // const int fluxDofStartIndex = dim * dofStartIndex;

      for (int ll = 0; ll < BASISSIZE; ll++) {  // loop over dof
        const int spaceTimeNodeIndex = nodeIndex + BASISSIZE * BASISSIZE * ll;
        const int spaceTimeDofStartIndex = spaceTimeNodeIndex * NVAR;
        const int spaceTimeFluxDofStartIndex = spaceTimeDofStartIndex * dim;

        Q = &lQi[spaceTimeDofStartIndex];

        f = &lFi[spaceTimeFluxDofStartIndex];
        g = &lFi[spaceTimeFluxDofStartIndex + NVAR];

        double weight = kernels::gaussLegendreWeights[BASISSIZE - 1][ll];

        // double * temp = &(lQhi[dofStartIndex]);
        for (int ivar = 0; ivar < NVAR; ivar++) {
          lQhi[dofStartIndex + ivar] += weight * Q[ivar];
          lFhi_x[dofStartIndex + ivar] +=
              weight * f[ivar];  // lFhi_x(DOFy,DOFx,nVar)
          lFhi_y[(jj + BASISSIZE * ii) * NVAR + ivar] +=
              weight * g[ivar];  // lFhi_y(DOFx,DOFy,nVar)
        }
      }
    }
  }

  /////////////////////////////////////////////////
  // Compute the bounday-extrapolated values for Q and F*n
  /////////////////////////////////////////////////
  constexpr int numberOfFaceDof =
      NVAR * BASISSIZE;  // tarch::la::aPowI(dim-1,BASISSIZE);

  memset((double*)&lQhbnd[0], 0,
         sizeof(double) * numberOfFaceDof * dimTimesTwo);
  memset((double*)&lFhbnd[0], 0,
         sizeof(double) * numberOfFaceDof * dimTimesTwo);

  //
  // x-direction: face 0 (left) and face 1 (right)
  //
  for (int jj = 0; jj < BASISSIZE; jj++) {
    const int nodeIndex = jj;
    const int dofStartIndexL =
        EXAHYPE_FACE_LEFT * numberOfFaceDof + nodeIndex * NVAR;
    const int dofStartIndexR =
        EXAHYPE_FACE_RIGHT * numberOfFaceDof + nodeIndex * NVAR;

    for (int mm = 0; mm < BASISSIZE; mm++) {  // loop over dof
      const int mmNodeIndex = mm + BASISSIZE * jj;
      const int mmDofStartIndex = mmNodeIndex * NVAR;

      Q = &lQhi[mmDofStartIndex];

      for (int ivar = 0; ivar < NVAR; ivar++) {
        lQhbnd[dofStartIndexL + ivar] += kernels::FLCoeff[BASISSIZE - 1][mm] *
                                         Q[ivar];  // lQhbnd(Facei,nDOF,nVar)
        lQhbnd[dofStartIndexR + ivar] += kernels::FRCoeff[BASISSIZE - 1][mm] *
                                         Q[ivar];  // lQhbnd(Facei,nDOF,nVar)

        lFhbnd[dofStartIndexL + ivar] +=
            kernels::FLCoeff[BASISSIZE - 1][mm] *
            lFhi_x[mmDofStartIndex + ivar];  // lFhi_x * FLCoeff
        lFhbnd[dofStartIndexR + ivar] +=
            kernels::FRCoeff[BASISSIZE - 1][mm] *
            lFhi_x[mmDofStartIndex + ivar];  // lFhi_x * FRCoeff
      }
    }
    continue;
  }

  //
  // y-direction: face 2 (left) and face 3 (right)
  //
  for (int ii = 0; ii < BASISSIZE; ii++) {
    const int nodeIndex = ii;
    const int dofStartIndexL =
        EXAHYPE_FACE_FRONT * numberOfFaceDof + nodeIndex * NVAR;
    const int dofStartIndexR =
        EXAHYPE_FACE_BACK * numberOfFaceDof + nodeIndex * NVAR;

    for (int mm = 0; mm < BASISSIZE; mm++) {
      const int mmNodeIndex = ii + BASISSIZE * mm;
      const int mmDofStartIndex = mmNodeIndex * NVAR;

      Q = &lQhi[mmDofStartIndex];

      for (int ivar = 0; ivar < NVAR; ivar++) {
        lQhbnd[dofStartIndexL + ivar] +=
            kernels::FLCoeff[BASISSIZE - 1][mm] * Q[ivar];
        lQhbnd[dofStartIndexR + ivar] +=
            kernels::FRCoeff[BASISSIZE - 1][mm] * Q[ivar];

        // without reordering of lFhi_y
        // lFhbnd[dofStartIndexL+ivar] += kernels::FLCoeff[BASISSIZE-1][mm] *
        // lFhi_y[mmDofStartIndex+ivar]; // lFhi_y * FLCoeff
        // lFhbnd[dofStartIndexR+ivar] += kernels::FRCoeff[BASISSIZE-1][mm] *
        // lFhi_y[mmDofStartIndex+ivar]; // lFhi_y * FRCoeff
        lFhbnd[dofStartIndexL + ivar] +=
            kernels::FLCoeff[BASISSIZE - 1][mm] *
            lFhi_y[(mm + BASISSIZE * ii) * NVAR + ivar];  // lFhi_y * FLCoeff
        lFhbnd[dofStartIndexR + ivar] +=
            kernels::FRCoeff[BASISSIZE - 1][mm] *
            lFhi_y[(mm + BASISSIZE * ii) * NVAR + ivar];  // lFhi_y * FRCoeff
      }  // mmDOfStartIndex = (mm  + BASISSIZE * ii) * NVAR
    }
    continue;
  }

  // clean up
  //  std::free(dqdt);
  delete[] rhs0;
  delete[] rhs;
  delete[] tmp;
}

/******************************************************************************************************
*******************************************************************************************************
******************************************************************************************************/

template <void PDEFlux2d(const double* const Q, double* f, double* g)>
void kernels::aderdg::generic::c::spaceTimePredictor(
    double* lQi, double* lFi, const double* const luh,
    const tarch::la::Vector<DIMENSIONS, double>& dx, const double dt,
    int numberOfVariables, int basisSize) {
  std::cout << "spaceTimePredictor Picard only" << std::endl;
  // todo Angelika
  // Please remove the typedefs in generic kernels again since numberOf(...)Dof
  // is not
  // a compile time variable anymore
  // helper variables
  // const int order = basisSize-1;

  // UNCOMMENT FOR DEBUGGING PURPOSES
  //  lQi[0] = 1;
  //  lFi[0] = 2;
  //  lQhi[0] = 3;
  //  lFhi[0] = 4;
  //
  //  constexpr int numberOfFaceDof = 5 * (3+1);
  //
  //  lQhbnd[EXAHYPE_FACE_LEFT*numberOfFaceDof] = 11;
  //  lFhbnd[EXAHYPE_FACE_LEFT*numberOfFaceDof] = 21;
  //
  //  lQhbnd[EXAHYPE_FACE_RIGHT*numberOfFaceDof] = 12;
  //  lFhbnd[EXAHYPE_FACE_RIGHT*numberOfFaceDof] = 22;
  //
  //  lQhbnd[EXAHYPE_FACE_FRONT*numberOfFaceDof] = 13;
  //  lFhbnd[EXAHYPE_FACE_FRONT*numberOfFaceDof] = 23;
  //
  //  lQhbnd[EXAHYPE_FACE_BACK*numberOfFaceDof] = 14;
  //  lFhbnd[EXAHYPE_FACE_BACK*numberOfFaceDof] = 24;
  constexpr int dim = 2;  // 2
  // constexpr int dimTimesTwo = (2*2);     // 4
  constexpr int BASISSIZE = (3 + 1);  // basisSize=order+1
  constexpr int NVAR = 5;             // numberOfVariables

  // helper variables
  constexpr int numberOfSpaceTimeDof =
      NVAR * BASISSIZE * BASISSIZE *
      BASISSIZE; /*tarch::la::aPowI(dim+1,BASISSIZE); */
//  constexpr int numberOfDof =
//      NVAR * BASISSIZE * BASISSIZE; /*tarch::la::aPowI(dim,BASISSIZE);*/

  double* rhs0 = new double[numberOfSpaceTimeDof];
  double* rhs = new double[numberOfSpaceTimeDof];
  double* tmp = new double[numberOfVariables * basisSize];

  for (int ii = 0; ii < BASISSIZE; ii++) {  // loop over dof
    for (int jj = 0; jj < BASISSIZE; jj++) {
      for (int ll = 0; ll < BASISSIZE; ll++) {  // loop over dof
        // location and index of nodal degrees of freedom
        const int nodeIndex = ii + BASISSIZE * jj;
        const int spaceTimeNodeIndex =
            ii + BASISSIZE * jj + BASISSIZE * BASISSIZE * ll;

        const int dofStartIndex = nodeIndex * NVAR;
        const int spaceTimeDofStartIndex = spaceTimeNodeIndex * NVAR;

        for (int ivar = 0; ivar < NVAR; ivar++) {
          // Trivial initial guess (can be significantly improved)
          lQi[spaceTimeDofStartIndex + ivar] = luh[dofStartIndex + ivar];

          // Compute the contribution of the initial condition uh to the time
          // update. I prefer to compute it once
          // and store it in rhs0, but if you think it is faster, you can also
          // recompute this contribution
          // inside the Picard loop (DO iter = 1, N+1)
          rhs0[spaceTimeDofStartIndex + ivar] =
              kernels::gaussLegendreWeights[BASISSIZE - 1][ii] *
              kernels::gaussLegendreWeights[BASISSIZE - 1][jj] *
              kernels::F0[BASISSIZE - 1][ll] * luh[dofStartIndex + ivar];
        }
      }
    }
  }
  // Above seems to work!

  double* Q;
  double* f;
  double* g;

  // double* dqdt = (double*) std::malloc(NVAR * BASISSIZE * sizeof(double)); //
  // todo this is just for debugging; in general, do not use mallocs

  // Discrete Picard iterations. This set of nested loops should (theoretically)
  // be a dream for vectorization, since they are rather independent...
  for (int iter = 1; iter < BASISSIZE + 1; iter++) {
    // Compute the fluxes (once these fluxes are available, the subsequent
    // operations are independent from each other)
    for (int ll = 0; ll < BASISSIZE; ll++) {    // loop over dof (time)
      for (int ii = 0; ii < BASISSIZE; ii++) {  // loop over dof
        for (int jj = 0; jj < BASISSIZE; jj++) {
          const int nodeIndex = ii + BASISSIZE * jj;
          const int spaceTimeNodeIndex = nodeIndex + BASISSIZE * BASISSIZE * ll;

          const int spaceTimeDofStartIndex = spaceTimeNodeIndex * NVAR;
          const int spaceTimeFluxDofStartIndex = spaceTimeDofStartIndex * dim;

          Q = &lQi[spaceTimeDofStartIndex];
          f = &lFi[spaceTimeFluxDofStartIndex];
          g = &lFi[spaceTimeFluxDofStartIndex + NVAR];

          // @todo Angelika's old code
          // exahype::problem::PDEFlux(Q,f,g);
          PDEFlux2d(Q, f, g);
        }
      }
      // Above seems okay!

      // x direction (independent from the y and z derivatives)
      // Kxi : BASISSIZE * BASISSIZE
      // lFh : NVAR * BASISSIZE

      // Compute the "derivatives" (contributions of the stiffness matrix)
      // x direction (independent from the y and z derivatives)
      for (int ii = 0; ii < BASISSIZE; ii++) {  // loop over dof
        for (int jj = 0; jj < BASISSIZE; jj++) {
          const int nodeIndex = ii + BASISSIZE * jj;
          const int spaceTimeNodeIndex = nodeIndex + BASISSIZE * BASISSIZE * ll;
          const int spaceTimeDofStartIndex = spaceTimeNodeIndex * NVAR;

          double weight = kernels::gaussLegendreWeights[BASISSIZE - 1][ll] *
                          kernels::gaussLegendreWeights[BASISSIZE - 1][jj];

          // COMPUTE SPATIAL DERIVATIVES FOR TESTING PURPOSES
          // for (int ll=0; ll < BASISSIZE; ll++) { // set tmp = 0
          //  for(int ivar=0; ivar < NVAR; ivar++) {
          //    tmp[ivar + NVAR*ll] = 0.;
          //  }
          //}
          //
          // for(int mm=0; mm < BASISSIZE; mm++) {
          //  const int mmNodeIndex        = mm + BASISSIZE * jj;
          //  const int mmSpaceTimeNodeIndex         = mmNodeIndex  + BASISSIZE
          //  * BASISSIZE * ll;
          //  const int mmSpaceTimeDofStartIndex     = mmSpaceTimeNodeIndex *
          //  NVAR;
          //  const int mmSpaceTimeFluxDofStartIndex = mmSpaceTimeDofStartIndex
          //  * dim;
          //
          //  Q = &(lQi [mmSpaceTimeDofStartIndex]);
          //  for(int ivar=0; ivar < NVAR; ivar++) {
          //    tmp[ivar] += 1./dxPatch * dg::dudx[ii][mm] * Q[ivar];
          //  }
          //}
          for (int ivar = 0; ivar < NVAR; ivar++) {
            rhs[spaceTimeDofStartIndex + ivar] =
                rhs0[spaceTimeDofStartIndex + ivar];
          }

          for (int mm = 0; mm < BASISSIZE; mm++) {
            const int mmNodeIndex = mm + BASISSIZE * jj;
            const int mmSpaceTimeNodeIndex =
                mmNodeIndex + BASISSIZE * BASISSIZE * ll;
            const int mmSpaceTimeDofStartIndex = mmSpaceTimeNodeIndex * NVAR;
            const int mmSpaceTimeFluxDofStartIndex =
                mmSpaceTimeDofStartIndex * dim;

            f = &lFi[mmSpaceTimeFluxDofStartIndex];

            for (int ivar = 0; ivar < NVAR; ivar++) {
              rhs[spaceTimeDofStartIndex + ivar] -=
                  weight * dt / dx[0] * kernels::Kxi[BASISSIZE - 1][mm][ii] *
                  f[ivar];
            }
          }
        }
      }
      // Above seems okay!

      // Compute the "derivatives" (contributions of the stiffness matrix)
      // y direction (independent from the x and z derivatives)
      for (int ii = 0; ii < BASISSIZE; ii++) {  // loop over dof
        for (int jj = 0; jj < BASISSIZE; jj++) {
          const int nodeIndex = ii + BASISSIZE * jj;
          const int spaceTimeNodeIndex = nodeIndex + BASISSIZE * BASISSIZE * ll;
          const int spaceTimeDofStartIndex = spaceTimeNodeIndex * NVAR;

          double weight = kernels::gaussLegendreWeights[BASISSIZE - 1][ll] *
                          kernels::gaussLegendreWeights[BASISSIZE - 1][ii];

          for (int mm = 0; mm < BASISSIZE; mm++) {
            const int mmNodeIndex = ii + BASISSIZE * mm;
            const int mmSpaceTimeNodeIndex =
                mmNodeIndex + BASISSIZE * BASISSIZE * ll;
            const int mmSpaceTimeDofStartIndex = mmSpaceTimeNodeIndex * NVAR;
            const int mmSpaceTimeFluxDofStartIndex =
                mmSpaceTimeDofStartIndex * dim;

            g = &lFi[mmSpaceTimeFluxDofStartIndex + NVAR];

            for (int ivar = 0; ivar < NVAR; ivar++) {
              rhs[spaceTimeDofStartIndex + ivar] -=
                  weight * dt / dx[1] * kernels::Kxi[BASISSIZE - 1][mm][jj] *
                  g[ivar];
            }
          }
        }
      }
    }  // end of time dof loop

    // Above seems okay!

    for (int ii = 0; ii < BASISSIZE; ii++) {  // loop over dof
      for (int jj = 0; jj < BASISSIZE; jj++) {
        const int nodeIndex = ii + BASISSIZE * jj;

        double iWeight =
            1. / (kernels::gaussLegendreWeights[BASISSIZE - 1][ii] *
                  kernels::gaussLegendreWeights[BASISSIZE - 1][jj]);

        for (int ll = 0; ll < BASISSIZE; ll++) {  // set tmp = 0
          for (int ivar = 0; ivar < NVAR; ivar++) {
            tmp[ivar + NVAR * ll] = 0.;
          }
        }

        for (int ll = 0; ll < BASISSIZE; ll++) {  // loop over dof

          for (int nn = 0; nn < BASISSIZE; nn++) {
            const int nnSpaceTimeNodeIndex =
                nodeIndex + BASISSIZE * BASISSIZE * nn;
            const int nnSpaceTimeDofStartIndex = nnSpaceTimeNodeIndex * NVAR;

            for (int ivar = 0; ivar < NVAR; ivar++) {
              tmp[ivar + NVAR * ll] += iWeight *
                                       kernels::iK1[BASISSIZE - 1][ll][nn] *
                                       rhs[nnSpaceTimeDofStartIndex + ivar];
            }
          }
        }

        for (int ll = 0; ll < BASISSIZE; ll++) {  // loop over dof
          const int spaceTimeNodeIndex = nodeIndex + BASISSIZE * BASISSIZE * ll;
          const int spaceTimeDofStartIndex = spaceTimeNodeIndex * NVAR;

          for (int ivar = 0; ivar < NVAR; ivar++) {
            lQi[spaceTimeDofStartIndex + ivar] = tmp[ivar + NVAR * ll];
          }
        }
      }
    }
  }  // end of Picard iteration
}

/******************************************************************************************************
*******************************************************************************************************
******************************************************************************************************/
