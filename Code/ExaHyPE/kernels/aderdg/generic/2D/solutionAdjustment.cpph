#include "../Kernels.h"

#include "string.h"

#include "tarch/la/Scalar.h"
#include "tarch/la/ScalarOperations.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/DGMatrices.h"

#define EXAHYPE_CFL_FACTOR 0.9

#include <fstream> 

using std::endl;
using std::cout;

template <void PDESolutionAdjustment(const double* const x,const double J_w,const double t,const double dt,double* Q)>
void kernels::aderdg::generic::solutionAdjustment(
    double* luh,
    const tarch::la::Vector<DIMENSIONS,double>& center,
    const tarch::la::Vector<DIMENSIONS,double>& dx,
    const double t,
    const double dt,
    const int numberOfVariables,
    const int basisSize
) {
  double  x [2];

  for (int ii=0; ii<basisSize; ii++) { // loop over dof
    const double qr = kernels::gaussLegendreNodes[basisSize-1][ii];

    for (int jj=0; jj<basisSize; jj++) {
      // location and index of nodal degrees of freedom
      const int nodeIndex = ii + basisSize * jj;
      
      const double qs = kernels::gaussLegendreNodes[basisSize-1][jj];
      x[0]=center[0] + dx[0]*(qr-0.5);
      x[1]=center[1] + dx[1]*(qs-0.5);
      
      const double J_w = // Jacobi determinant times Gauss weight  
          dx[0] * dx[1] *
          kernels::gaussLegendreWeights[basisSize-1][ii] * kernels::gaussLegendreWeights[basisSize-1][jj];
      
      // read initial condition
      const int dofStartIndex  = nodeIndex * numberOfVariables;
      PDESolutionAdjustment(x,J_w,t,dt,&luh[dofStartIndex]);
    }
  }
}

