/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

#include <cstring>

namespace kernels {
namespace aderdg {
namespace generic {
namespace c {

#if DIMENSIONS == 2

template <void PDENCP(const double* const Q, const double* const gradQ,
                      double* BgradQ)>
void spaceTimePredictorLinear(double* lQi, double* lFi, double* lQhi,
                              double* lFhi, double* lQbnd, double* lFbnd,
                              const double* const luh,
                              const tarch::la::Vector<DIMENSIONS, double>& dx,
                              const double dt, const int numberOfVariables,
                              const int basisSize) {
  const int basisSize2 = basisSize * basisSize;
  const int basisSize3 = basisSize2 * basisSize;
  const int basisSize4 = basisSize2 * basisSize2;
  const int order = basisSize - 1;

  double* lQh = new double[basisSize4 *
                           numberOfVariables];  // space-time degrees of freedom
  std::memset(lQh, 0, basisSize4 * numberOfVariables * sizeof(double));

  // The zeroth time derivative (time dof number 1) is the initial condition
  // lqh(k,1,j,i) += luh(k,j,i)
  for (int i = 0; i < basisSize; i++) {
    for (int j = 0; j < basisSize; j++) {
      for (int k = 0; k < numberOfVariables; k++) {
        lQh[i * basisSize2 * numberOfVariables +
            j * basisSize * numberOfVariables + 0 * numberOfVariables + k] +=
            luh[i * basisSize * numberOfVariables + j * numberOfVariables + k];
      }
    }
  }

  // spatial gradient of q
  double* gradQ = new double[basisSize3 * 2 * numberOfVariables];
  std::memset(gradQ, 0, basisSize3 * 2 * numberOfVariables * sizeof(double));

  double* lFh = new double[basisSize3 * 2 * numberOfVariables];

  // For linear PDE, the fastest space-time predictor is the good old
  // Cauchy-Kovalewski procedure
  for (int i = 0; i < basisSize; i++) {  // time DOFs
    // Compute the derivatives in x direction (independent from the y
    // derivative)
    for (int j = 0; j < basisSize; j++) {
      // Fortran: gradQ(:,1,:,j,i) = 1.0/dx(1) * lqh(:,i,:,j) *
      // dudx(:,:)^T
      for (int k = 0; k < basisSize; k++) {
        for (int l = 0; l < numberOfVariables; l++) {
          for (int m = 0; m < basisSize; m++) {
            gradQ[i * basisSize2 * 2 * numberOfVariables +
                  j * basisSize * 2 * numberOfVariables +
                  k * 2 * numberOfVariables + 0 * numberOfVariables + l] +=
                1.0 / dx[0] * lQh[j * basisSize2 * numberOfVariables +
                                  m * basisSize * numberOfVariables +
                                  i * numberOfVariables + l] *
                kernels::dudx[order][m][k];
          }
        }
      }
    }

    // y direction (independent from the x derivative)
    for (int j = 0; j < basisSize; j++) {
      // Fortran: gradQ(:,2,j,:,i) = 1.0/dx(2) * lqh(:,i,j,:) *
      // dudx(:,:)^T
      for (int k = 0; k < basisSize; k++) {
        for (int l = 0; l < numberOfVariables; l++) {
          for (int m = 0; m < basisSize; m++) {
            gradQ[i * basisSize2 * 2 * numberOfVariables +
                  k * basisSize * 2 * numberOfVariables +
                  j * 2 * numberOfVariables + 1 * numberOfVariables + l] +=
                1.0 / dx[1] * lQh[m * basisSize2 * numberOfVariables +
                                  j * basisSize * numberOfVariables +
                                  i * numberOfVariables + l] *
                kernels::dudx[order][m][k];
          }
        }
      }
    }

    // Compute the fluxes
    for (int j = 0; j < basisSize; j++) {
      for (int k = 0; k < basisSize; k++) {
        PDENCP(&lQh[j * basisSize2 * numberOfVariables +
                    k * basisSize * numberOfVariables + i * numberOfVariables],
               &gradQ[i * basisSize2 * 2 * numberOfVariables +
                      j * basisSize * 2 * numberOfVariables +
                      k * 2 * numberOfVariables],
               &lFh[i * basisSize2 * 2 * numberOfVariables +
                    j * basisSize * 2 * numberOfVariables +
                    k * 2 * numberOfVariables]);
      }
    }

    for (int j = 0; j < basisSize; j++) {
      for (int k = 0; k < basisSize; k++) {
        // lQh(:,k,j,i+1) -= SUM(lFh(:,1:nDim,k,j,i), dim=2)
        for (int l = 0; l < 2; l++) {
          for (int m = 0; m < numberOfVariables; m++) {
            lQh[(i + 1) * basisSize2 * numberOfVariables +
                j * basisSize * numberOfVariables + k * numberOfVariables +
                m] -=
                lFh[i * basisSize2 * 2 * numberOfVariables +
                    j * basisSize * 2 * numberOfVariables +
                    k * 2 * numberOfVariables + l * numberOfVariables + m];
          }
        }
      }
    }
  }

  // Immediately compute the time-averaged space-time polynomials
  // Fortran: lQhi(:,:,:) = lQh(:,1,:,:)
  for (int i = 0; i < basisSize; i++) {
    for (int j = 0; j < basisSize; j++) {
      for (int k = 0; k < numberOfVariables; k++) {
        lQhi[i * basisSize * numberOfVariables + j * numberOfVariables + k] =
            lQh[i * basisSize2 * numberOfVariables +
                j * basisSize * numberOfVariables + 0 * numberOfVariables + k];
      }
    }
  }

  double dtavFac = 0.5 * dt;
  for (int i = 1; i < basisSize; i++) {
    // Fortran: lQhi(:,:,:) += dtavFac * lQh(:,i,:,:)
    for (int j = 0; j < basisSize; j++) {
      for (int k = 0; k < basisSize; k++) {
        for (int l = 0; l < numberOfVariables; l++) {
          lQhi[j * basisSize * numberOfVariables + k * numberOfVariables + l] +=
              lQh[j * basisSize2 * numberOfVariables +
                  k * basisSize * numberOfVariables + i * numberOfVariables +
                  l];
        }
      }
    }
    dtavFac *= dt / (i + 2);
  }

  // lFhi(:,:,:,:) = lFh(:,:,:,1)
  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < basisSize; j++) {
      for (int k = 0; k < basisSize; k++) {
        for (int l = 0; l < numberOfVariables; l++) {
          lFhi[i * basisSize2 * numberOfVariables +
               j * basisSize * numberOfVariables + k * numberOfVariables + l] =
              lFh[0 * basisSize2 * 2 * numberOfVariables +
                  j * basisSize * 2 * numberOfVariables +
                  k * 2 * numberOfVariables + i * numberOfVariables + l];
        }
      }
    }
  }

  dtavFac = 0.5 * dt;
  for (int i = 1; i < basisSize; i++) {
    // Fortran: lFhi(:,:,:,:) += dtavFac*lFh(:,:,:,:,i)
    for (int j = 0; j < 2; j++) {
      for (int k = 0; k < basisSize; k++) {
        for (int l = 0; l < basisSize; l++) {
          for (int m = 0; m < numberOfVariables; m++) {
            lFhi[j * basisSize2 * numberOfVariables +
                 k * basisSize * numberOfVariables + l * numberOfVariables +
                 m] +=
                lFh[i * basisSize2 * 2 * numberOfVariables +
                    k * basisSize * 2 * numberOfVariables +
                    l * 2 * numberOfVariables + j * numberOfVariables + m];
          }
        }
      }
    }
    dtavFac *= dt / (i + 2);
  }

  // Compute the boundary-extrapolated values for Q and F*n
  std::memset(lQbnd, 0, 4 * basisSize * numberOfVariables * sizeof(double));
  std::memset(lFbnd, 0, 4 * basisSize * numberOfVariables * sizeof(double));

  // x-direction: face 1 (left) and face 2 (right)
  for (int i = 0; i < basisSize; i++) {
    // Fortran:
    // lQbnd(:,i,1) = lQhi(:,:,i) * FLCoeff(:)
    // lQbnd(:,i,2) = lQhi(:,:,i) * FRCoeff(:)
    // lFbnd(:,i,1) = lFhi(:,:,i,1) * FLCoeff(:)
    // lFbnd(:,i,2) = lFhi(:,:,i,1) * FRCoeff(:)
    for (int j = 0; j < numberOfVariables; j++) {
      for (int k = 0; k < basisSize; k++) {
        // left
        lQbnd[0 * basisSize * numberOfVariables + i * numberOfVariables + j] +=
            lQhi[i * basisSize * numberOfVariables + k * numberOfVariables +
                 j] *
            kernels::FLCoeff[order][k];

        // right
        lQbnd[1 * basisSize * numberOfVariables + i * numberOfVariables + j] +=
            lQhi[i * basisSize * numberOfVariables + k * numberOfVariables +
                 j] *
            kernels::FRCoeff[order][k];

        // left
        lFbnd[0 * basisSize * numberOfVariables + i * numberOfVariables + j] +=
            lFhi[0 * basisSize2 * numberOfVariables +
                 i * basisSize * numberOfVariables + k * numberOfVariables +
                 j] *
            kernels::FLCoeff[order][k];

        // right
        lFbnd[1 * basisSize * numberOfVariables + i * numberOfVariables + j] +=
            lFhi[0 * basisSize2 * numberOfVariables +
                 i * basisSize * numberOfVariables + k * numberOfVariables +
                 j] *
            kernels::FRCoeff[order][k];
      }
    }
  }

  // y-direction: face 3 (left) and face 4 (right)
  for (int i = 0; i < basisSize; i++) {
    // Fortran:
    // lQbnd(:,i,3) = lQhi(:,i,:) * FLCoeff(:)
    // lQbnd(:,i,4) = lQhi(:,i,:) * FRCoeff(:)
    // lFbnd(:,i,3) = lFhi(:,i,:,2) * FLCoeff(:)
    // lFbnd(:,i,4) = lFhi(:,i,:,2) * FRCoeff(:)
    for (int j = 0; j < numberOfVariables; j++) {
      for (int k = 0; k < basisSize; k++) {
        // left
        lQbnd[2 * basisSize * numberOfVariables + i * numberOfVariables + j] +=
            lQhi[k * basisSize * numberOfVariables + i * numberOfVariables +
                 j] *
            kernels::FLCoeff[order][k];

        // right
        lQbnd[3 * basisSize * numberOfVariables + i * numberOfVariables + j] +=
            lQhi[k * basisSize * numberOfVariables + i * numberOfVariables +
                 j] *
            kernels::FRCoeff[order][k];

        // left
        lFbnd[2 * basisSize * numberOfVariables + i * numberOfVariables + j] +=
            lFhi[1 * basisSize2 * numberOfVariables +
                 k * basisSize * numberOfVariables + i * numberOfVariables +
                 j] *
            kernels::FLCoeff[order][k];

        // right
        lFbnd[3 * basisSize * numberOfVariables + i * numberOfVariables + j] +=
            lFhi[1 * basisSize2 * numberOfVariables +
                 k * basisSize * numberOfVariables + i * numberOfVariables +
                 j] *
            kernels::FRCoeff[order][k];
      }
    }
  }

  // delete heap allocated arrays
  delete[] lQh;
  delete[] gradQ;
  delete[] lFh;
}

#endif  // DIMENSIONS == 2

}  // namespace c
}  // namespace generic
}  // namespace aderdg
}  // namespace kernels
