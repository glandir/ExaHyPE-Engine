/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon 
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/
 
#include "kernels/aderdg/generic/Kernels.h"

#include <algorithm>

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/DGMatrices.h"

#if DIMENSIONS == 2

template <void PDEBoundaryConditions(const double* const x,const double t, const int faceIndex, const int normalNonZero, const double * const fluxIn, const double* const stateIn, double *fluxOut, double* stateOut)>
void kernels::aderdg::generic::c::boundaryConditions(double* fluxOut,
                        double* stateOut,
                        const double* const fluxIn,
                        const double* const stateIn,
                        const tarch::la::Vector<DIMENSIONS, double>& cellCentre,
                        const tarch::la::Vector<DIMENSIONS,double>& cellSize,
                        const double t,const double dt,
                        const int faceIndex,
                        const int normalNonZero,
                        const int numberOfVariables, const int basisSize) {
  // Determine if face is "left" (0,2,4) or "right" face (1,2,3).
  const int f = faceIndex-2*normalNonZero;

  // Determine the free direction from the non-zero normal entry.
  // @todo(Dominic,31/07/16) I might have confused these directions. Please start here with the debugging.
  int d1=0;
  switch(normalNonZero) {
    case 0:
      d1=1;
      break;
    case 1:
      d1=0;
      break;
    default:
      assertionMsg(false,"normalNonZero must be either 0 or 1.");
      break;
  }

  // TODO: Please pass dt to PDEBoundaryConditions!
  
  double x[DIMENSIONS];
  x[normalNonZero] = cellCentre[normalNonZero] + (-0.5 + f)*cellSize[normalNonZero];
  for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
    x[d1] = cellCentre[d1] + cellSize[d1] * (kernels::gaussLegendreNodes[basisSize-1][ii] - 0.5);
      PDEBoundaryConditions(x,t,faceIndex,normalNonZero,
                            &fluxIn[nidx1(ii)],&stateIn[nidx1(ii)],
                            &fluxOut[nidx1(ii)],&stateOut[nidx1(ii)]);
  }
}

#endif  // DIMENSIONS == 2
