/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

// #include "../Kernels.h"

// #include "string.h"

// #include "tarch/la/Scalar.h"
// #include "tarch/la/ScalarOperations.h"

// #include "kernels/GaussLegendreQuadrature.h"
// #include "kernels/DGMatrices.h"

// #define EXAHYPE_CFL_FACTOR 0.9

// #include <fstream>

// using std::endl;
// using std::cout;

#include <cassert>

// todo change template parameter in header and generator
// template <void PDEFlux2d(const double * const Q, double * f, double * g)>
template <void PDEEigenvalues(const double* const Q, const int normalNonZero,
                              double* lambda)>
void kernels::aderdg::generic::c::riemannSolverNonlinear(
    double* FL, double* FR, const double* const QL, const double* const QR,
    const double dt, const int normalNonZero, const int numberOfVariables,
    const int numberOfParameters, const int basisSize) {
  // TODO(guera): Fix and remove
  assert(numberOfParameters == 0 &&
         "numberOfParameters has to be 0 at the moment");

  double* QavL = new double[numberOfVariables];
  double* QavR = new double[numberOfVariables];
  double* lambdaL = new double[numberOfVariables];
  double* lambdaR = new double[numberOfVariables];

  // Compute the average states from the left and the right, which we need to
  // compute the numerical dissipation
  memset((double*)QavL, 0, numberOfVariables * sizeof(double));
  memset((double*)QavR, 0, numberOfVariables * sizeof(double));

  for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
    const int nodeIndex = ii;
    const int dofStartIndex = nodeIndex * numberOfVariables;

    double weight = kernels::gaussLegendreWeights[basisSize - 1][ii];

    for (int ivar = 0; ivar < numberOfVariables; ivar++) {
      QavL[ivar] += weight * QL[dofStartIndex + ivar];
      QavR[ivar] += weight * QR[dofStartIndex + ivar];
    }
  }
  //
  // Here, we implement a very simple Rusanov scheme with scalar dissipation
  // (smax*Id).
  // We can change this into a more sophisticated Osher or HLLEM Riemann solver
  // whenever needed.
  //
  PDEEigenvalues(QavL, normalNonZero, lambdaL);
  PDEEigenvalues(QavR, normalNonZero, lambdaR);

  double sMax = 0;
  for (int ivar = 0; ivar < numberOfVariables; ivar++) {
    sMax = std::max(sMax, std::max(fabs(lambdaL[ivar]), fabs(lambdaR[ivar])));
  }
  //
  // We now compute the numerical flux. Note that the scheme is at the moment
  // written in
  // CONSERVATION FORM => no fluctuations, but real fluxes.
  // Later, this will be converted into the left and right fluctuations.
  //
  for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
    const int nodeIndex = ii;
    const int dofStartIndex = nodeIndex * numberOfVariables;

    // sum can only be done if all contributions are up
    for (int ivar = 0; ivar < numberOfVariables; ivar++) {
      FL[dofStartIndex + ivar] =
          0.5 * (FL[dofStartIndex + ivar] + FR[dofStartIndex + ivar]) -
          0.5 * sMax * (QR[dofStartIndex + ivar] - QL[dofStartIndex + ivar]);

      FR[dofStartIndex + ivar] = FL[dofStartIndex + ivar];
    }
  }
  //  // @todo 04/02/16:Dominic Etienne Charrier
  //  // for debugging purposes
  //  int _errors = 0;
  //  bool _error = false;
  //  std::cout << "sMax" << sMax << std::endl;
  //  validateNumericalEqualsWithEps(sMax, 1.18321595661992, 1e-10);

  delete[] QavL;
  delete[] QavR;
  delete[] lambdaL;
  delete[] lambdaR;
}
