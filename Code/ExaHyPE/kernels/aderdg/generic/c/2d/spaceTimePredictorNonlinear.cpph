/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

// #include "kernels/aderdg/generic/Kernels.h"

// #include "string.h"

// #include "tarch/la/Scalar.h"
// #include "tarch/la/ScalarOperations.h"

// #include "kernels/GaussLegendreQuadrature.h"
// #include "kernels/DGMatrices.h"

// #define EXAHYPE_CFL_FACTOR 0.9

// #include <fstream>

// using std::endl;
// using std::cout;

#if DIMENSIONS == 2

template <void PDEFlux(const double* const Q, double** F)>
void kernels::aderdg::generic::c::spaceTimePredictorNonlinear(
    double* lQi, double* lFi, double* lQhi, double* lFhi, double* lQhbnd,
    double* lFhbnd, const double* const luh,
    const tarch::la::Vector<DIMENSIONS, double>& dx, const double dt,
    const int numberOfVariables, const int numberOfParameters,
    const int basisSize) {
  assert(numberOfParameters == 0 &&
         "number of parameters != 0 not yet supported");
  // todo Angelika
  // Please remove the typedefs in generic kernels again since numberOf(...)Dof
  // is not
  // a compile time variable anymore
  // helper variables
  // const int order = basisSize-1;

  // UNCOMMENT FOR DEBUGGING PURPOSES
  //  lQi[0] = 1;
  //  lFi[0] = 2;
  //  lQhi[0] = 3;
  //  lFhi[0] = 4;
  //
  //  constexpr int numberOfFaceDof = 5 * (3+1);
  //
  //  lQhbnd[EXAHYPE_FACE_LEFT*numberOfFaceDof] = 11;
  //  lFhbnd[EXAHYPE_FACE_LEFT*numberOfFaceDof] = 21;
  //
  //  lQhbnd[EXAHYPE_FACE_RIGHT*numberOfFaceDof] = 12;
  //  lFhbnd[EXAHYPE_FACE_RIGHT*numberOfFaceDof] = 22;
  //
  //  lQhbnd[EXAHYPE_FACE_FRONT*numberOfFaceDof] = 13;
  //  lFhbnd[EXAHYPE_FACE_FRONT*numberOfFaceDof] = 23;
  //
  //  lQhbnd[EXAHYPE_FACE_BACK*numberOfFaceDof] = 14;
  //  lFhbnd[EXAHYPE_FACE_BACK*numberOfFaceDof] = 24;
  //  constexpr int DIMENSIONS = DIMENSIONS;                // 2
  //  constexpr int DIMENSIONSTimesTwo = (2 * DIMENSIONS);  // 4
  //  constexpr int basisSize = (3 + 1);             // basisSize=order+1
  //  constexpr int numberOfVariables = 5;                        //
  //  numberOfVariables

  // helper variables
  const int numberOfSpaceTimeDof =
      numberOfVariables * basisSize * basisSize *
      basisSize; /*tarch::la::aPowI(DIMENSIONS+1,basisSize); */
  const int numberOfDof = numberOfVariables * basisSize *
                          basisSize; /*tarch::la::aPowI(DIMENSIONS,basisSize);*/

  double* rhs0 = new double[numberOfSpaceTimeDof];
  double* rhs = new double[numberOfSpaceTimeDof];
  double* tmp = new double[numberOfVariables * basisSize];

  for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
    for (int jj = 0; jj < basisSize; jj++) {
      for (int ll = 0; ll < basisSize; ll++) {  // loop over dof
        // location and index of nodal degrees of freedom
        const int nodeIndex = ii + basisSize * jj;
        const int spaceTimeNodeIndex =
            ii + basisSize * jj + basisSize * basisSize * ll;

        const int dofStartIndex = nodeIndex * numberOfVariables;
        const int spaceTimeDofStartIndex =
            spaceTimeNodeIndex * numberOfVariables;

        for (int ivar = 0; ivar < numberOfVariables; ivar++) {
          // Trivial initial guess (can be significantly improved)
          lQi[spaceTimeDofStartIndex + ivar] = luh[dofStartIndex + ivar];
          assertion(lQi[spaceTimeDofStartIndex + ivar] ==
                    lQi[spaceTimeDofStartIndex + ivar]);

          // Compute the contribution of the initial condition uh to the time
          // update. I prefer to compute it once
          // and store it in rhs0, but if you think it is faster, you can also
          // recompute this contribution
          // inside the Picard loop (DO iter = 1, N+1)
          rhs0[spaceTimeDofStartIndex + ivar] =
              kernels::gaussLegendreWeights[basisSize - 1][ii] *
              kernels::gaussLegendreWeights[basisSize - 1][jj] *
              kernels::F0[basisSize - 1][ll] * luh[dofStartIndex + ivar];
        }
      }
    }
  }
  // Above seems to work!

  double* Q;
  double* f;
  double* g;

  // double* dqdt = (double*) std::malloc(numberOfVariables * basisSize *
  // sizeof(double)); //
  // todo this is just for debugging; in general, do not use mallocs

  // Discrete Picard iterations. This set of nested loops should (theoretically)
  // be a dream for vectorization, since they are rather independent...
  for (int iter = 1; iter < basisSize + 1; iter++) {
    // Compute the fluxes (once these fluxes are available, the subsequent
    // operations are independent from each other)
    for (int ll = 0; ll < basisSize; ll++) {    // loop over dof (time)
      for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
        for (int jj = 0; jj < basisSize; jj++) {
          const int nodeIndex = ii + basisSize * jj;
          const int spaceTimeNodeIndex = nodeIndex + basisSize * basisSize * ll;

          const int spaceTimeDofStartIndex =
              spaceTimeNodeIndex * numberOfVariables;
          const int spaceTimeFluxDofStartIndex =
              spaceTimeDofStartIndex * DIMENSIONS;

          Q = &lQi[spaceTimeDofStartIndex];
          double* F[2];
          F[0] = &lFi[spaceTimeFluxDofStartIndex];
          F[1] = &lFi[spaceTimeFluxDofStartIndex + numberOfVariables];

          // @todo Angelika's old code
          // exahype::problem::PDEFlux(Q,f,g);
          PDEFlux(Q, F);
          assertion(lQi[spaceTimeDofStartIndex] == lQi[spaceTimeDofStartIndex]);
        }
      }
      // Above seems okay!

      // x direction (independent from the y and z derivatives)
      // Kxi : basisSize * basisSize
      // lFh : numberOfVariables * basisSize

      // Compute the "derivatives" (contributions of the stiffness matrix)
      // x direction (independent from the y and z derivatives)
      for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
        for (int jj = 0; jj < basisSize; jj++) {
          const int nodeIndex = ii + basisSize * jj;
          const int spaceTimeNodeIndex = nodeIndex + basisSize * basisSize * ll;
          const int spaceTimeDofStartIndex =
              spaceTimeNodeIndex * numberOfVariables;

          double weight = kernels::gaussLegendreWeights[basisSize - 1][ll] *
                          kernels::gaussLegendreWeights[basisSize - 1][jj];

          // COMPUTE SPATIAL DERIVATIVES FOR TESTING PURPOSES
          // for (int ll=0; ll < basisSize; ll++) { // set tmp = 0
          //  for(int ivar=0; ivar < numberOfVariables; ivar++) {
          //    tmp[ivar + numberOfVariables*ll] = 0.;
          //  }
          //}
          //
          // for(int mm=0; mm < basisSize; mm++) {
          //  const int mmNodeIndex        = mm + basisSize * jj;
          //  const int mmSpaceTimeNodeIndex         = mmNodeIndex  + basisSize
          //  * basisSize * ll;
          //  const int mmSpaceTimeDofStartIndex     = mmSpaceTimeNodeIndex *
          //  numberOfVariables;
          //  const int mmSpaceTimeFluxDofStartIndex = mmSpaceTimeDofStartIndex
          //  * DIMENSIONS;
          //
          //  Q = &(lQi [mmSpaceTimeDofStartIndex]);
          //  for(int ivar=0; ivar < numberOfVariables; ivar++) {
          //    tmp[ivar] += 1./dxPatch * dg::dudx[ii][mm] * Q[ivar];
          //  }
          //}
          for (int ivar = 0; ivar < numberOfVariables; ivar++) {
            rhs[spaceTimeDofStartIndex + ivar] =
                rhs0[spaceTimeDofStartIndex + ivar];
          }

          for (int mm = 0; mm < basisSize; mm++) {
            const int mmNodeIndex = mm + basisSize * jj;
            const int mmSpaceTimeNodeIndex =
                mmNodeIndex + basisSize * basisSize * ll;
            const int mmSpaceTimeDofStartIndex =
                mmSpaceTimeNodeIndex * numberOfVariables;
            const int mmSpaceTimeFluxDofStartIndex =
                mmSpaceTimeDofStartIndex * DIMENSIONS;

            f = &lFi[mmSpaceTimeFluxDofStartIndex];

            for (int ivar = 0; ivar < numberOfVariables; ivar++) {
              rhs[spaceTimeDofStartIndex + ivar] -=
                  weight * dt / dx[0] * kernels::Kxi[basisSize - 1][mm][ii] *
                  f[ivar];
            }
          }
        }
      }
      // Above seems okay!

      // Compute the "derivatives" (contributions of the stiffness matrix)
      // y direction (independent from the x and z derivatives)
      for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
        for (int jj = 0; jj < basisSize; jj++) {
          const int nodeIndex = ii + basisSize * jj;
          const int spaceTimeNodeIndex = nodeIndex + basisSize * basisSize * ll;
          const int spaceTimeDofStartIndex =
              spaceTimeNodeIndex * numberOfVariables;

          double weight = kernels::gaussLegendreWeights[basisSize - 1][ll] *
                          kernels::gaussLegendreWeights[basisSize - 1][ii];

          for (int mm = 0; mm < basisSize; mm++) {
            const int mmNodeIndex = ii + basisSize * mm;
            const int mmSpaceTimeNodeIndex =
                mmNodeIndex + basisSize * basisSize * ll;
            const int mmSpaceTimeDofStartIndex =
                mmSpaceTimeNodeIndex * numberOfVariables;
            const int mmSpaceTimeFluxDofStartIndex =
                mmSpaceTimeDofStartIndex * DIMENSIONS;

            g = &lFi[mmSpaceTimeFluxDofStartIndex + numberOfVariables];

            for (int ivar = 0; ivar < numberOfVariables; ivar++) {
              rhs[spaceTimeDofStartIndex + ivar] -=
                  weight * dt / dx[1] * kernels::Kxi[basisSize - 1][mm][jj] *
                  g[ivar];
            }
          }
        }
      }
    }  // end of time dof loop

    // Above seems okay!

    for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
      for (int jj = 0; jj < basisSize; jj++) {
        const int nodeIndex = ii + basisSize * jj;

        double iWeight =
            1. / (kernels::gaussLegendreWeights[basisSize - 1][ii] *
                  kernels::gaussLegendreWeights[basisSize - 1][jj]);

        for (int ll = 0; ll < basisSize; ll++) {  // set tmp = 0
          for (int ivar = 0; ivar < numberOfVariables; ivar++) {
            tmp[ivar + numberOfVariables * ll] = 0.;
          }
        }

        for (int ll = 0; ll < basisSize; ll++) {  // loop over dof

          for (int nn = 0; nn < basisSize; nn++) {
            const int nnSpaceTimeNodeIndex =
                nodeIndex + basisSize * basisSize * nn;
            const int nnSpaceTimeDofStartIndex =
                nnSpaceTimeNodeIndex * numberOfVariables;

            for (int ivar = 0; ivar < numberOfVariables; ivar++) {
              tmp[ivar + numberOfVariables * ll] +=
                  iWeight * kernels::iK1[basisSize - 1][ll][nn] *
                  rhs[nnSpaceTimeDofStartIndex + ivar];
              assertion8(tmp[ivar + numberOfVariables * ll] ==
                             tmp[ivar + numberOfVariables * ll],
                         ivar, numberOfVariables, ll, iWeight,
                         kernels::iK1[basisSize - 1][ll][nn],
                         rhs[nnSpaceTimeDofStartIndex + ivar],
                         nnSpaceTimeDofStartIndex, nn);
            }
          }
        }

        for (int ll = 0; ll < basisSize; ll++) {  // loop over dof
          const int spaceTimeNodeIndex = nodeIndex + basisSize * basisSize * ll;
          const int spaceTimeDofStartIndex =
              spaceTimeNodeIndex * numberOfVariables;

          for (int ivar = 0; ivar < numberOfVariables; ivar++) {
            lQi[spaceTimeDofStartIndex + ivar] =
                tmp[ivar + numberOfVariables * ll];
            assertion4(lQi[spaceTimeDofStartIndex + ivar] ==
                           lQi[spaceTimeDofStartIndex + ivar],
                       spaceTimeDofStartIndex, ivar, numberOfVariables, ll);
          }
        }

        // UNCOMMENT FOR DEBUGGING PURPOSES
        //        // dqdt
        //        for (int ll=0; ll < basisSize; ll++) { // set tmp = 0
        //          for(int ivar=0; ivar < numberOfVariables; ivar++) {
        //            dqdt[ivar + numberOfVariables*ll] = 0.;
        //          }
        //        }
        //
        //        for (int ll=0; ll<basisSize; ll++) { // loop over dof
        //
        //          for(int ivar=0; ivar < numberOfVariables; ivar++) {
        //
        //            for(int nn=0; nn < basisSize; nn++) {
        //              const int nnSpaceTimeNodeIndex         = nodeIndex  +
        //              basisSize * basisSize * nn;
        //              const int nnSpaceTimeDofStartIndex     =
        //              nnSpaceTimeNodeIndex * numberOfVariables;
        //
        //              dqdt[ivar + numberOfVariables*ll] += 1./dt *
        //              dg::dudx[ll][nn] *
        //                  lQi[nnSpaceTimeDofStartIndex+ivar];
        //            }
        //          }
        //        }
      }
    }
  }  // end of Picard iteration

  /////////////////////////////////////////////////
  // Post processing of the predictor:
  // Immediately compute the time-averaged space-time polynomials
  /////////////////////////////////////////////////
  const int numberOfFluxDof = numberOfDof * DIMENSIONS;

  memset((double*)lQhi, 0, sizeof(double) * numberOfDof);
  memset((double*)lFhi, 0, sizeof(double) * numberOfFluxDof);

  // memory layout of lFhi:
  // lFhi = [ lFhi_x | lFhi_y ] ordered as
  // (a) lFhi_x[nDOF_y][nDOF_x][nVar]
  // (b) lFhi_y[nDOF_x][nDOF_y][nVar]
  // Note the order of lFhi_y. Rationale is that matrix multiplications
  // then no longer have strided access pattern
  //
  // For 3D the variables should be as follows.
  // lFhi = [ lFhi_x | lFhi_y | lFhi_z ] where
  // (a) lFhi_x[nDOF_z][nDOF_y][nDOF_x][nVar]
  // (b) lFhi_y[nDOF_z][nDOF_x][nDOF_y][nVar]
  // (c) lFhi_z[nDOF_x][nDOF_y][nDOF_z][nVar]
  //
  double* lFhi_x = &lFhi[0];
  double* lFhi_y = &lFhi[numberOfDof];

  for (int jj = 0; jj < basisSize; jj++) {  // loop over dof
    for (int ii = 0; ii < basisSize; ii++) {
      const int nodeIndex = ii + basisSize * jj;
      const int dofStartIndex = nodeIndex * numberOfVariables;
      // const int fluxDofStartIndex = DIMENSIONS * dofStartIndex;

      for (int ll = 0; ll < basisSize; ll++) {  // loop over dof
        const int spaceTimeNodeIndex = nodeIndex + basisSize * basisSize * ll;
        const int spaceTimeDofStartIndex =
            spaceTimeNodeIndex * numberOfVariables;
        const int spaceTimeFluxDofStartIndex =
            spaceTimeDofStartIndex * DIMENSIONS;

        Q = &lQi[spaceTimeDofStartIndex];

        f = &lFi[spaceTimeFluxDofStartIndex];
        g = &lFi[spaceTimeFluxDofStartIndex + numberOfVariables];

        double weight = kernels::gaussLegendreWeights[basisSize - 1][ll];

        // double * temp = &(lQhi[dofStartIndex]);
        for (int ivar = 0; ivar < numberOfVariables; ivar++) {
          lQhi[dofStartIndex + ivar] += weight * Q[ivar];
          lFhi_x[dofStartIndex + ivar] +=
              weight * f[ivar];  // lFhi_x(DOFy,DOFx,nVar)
          lFhi_y[(jj + basisSize * ii) * numberOfVariables + ivar] +=
              weight * g[ivar];  // lFhi_y(DOFx,DOFy,nVar)
        }
      }
    }
  }

  /////////////////////////////////////////////////
  // Compute the bounday-extrapolated values for Q and F*n
  /////////////////////////////////////////////////
  const int numberOfFaceDof =
      numberOfVariables *
      basisSize;  // tarch::la::aPowI(DIMENSIONS-1,basisSize);

  memset((double*)&lQhbnd[0], 0,
         sizeof(double) * numberOfFaceDof * DIMENSIONS_TIMES_TWO);
  memset((double*)&lFhbnd[0], 0,
         sizeof(double) * numberOfFaceDof * DIMENSIONS_TIMES_TWO);

  //
  // x-direction: face 0 (left) and face 1 (right)
  //
  for (int jj = 0; jj < basisSize; jj++) {
    const int nodeIndex = jj;
    const int dofStartIndexL =
        EXAHYPE_FACE_LEFT * numberOfFaceDof + nodeIndex * numberOfVariables;
    const int dofStartIndexR =
        EXAHYPE_FACE_RIGHT * numberOfFaceDof + nodeIndex * numberOfVariables;

    for (int mm = 0; mm < basisSize; mm++) {  // loop over dof
      const int mmNodeIndex = mm + basisSize * jj;
      const int mmDofStartIndex = mmNodeIndex * numberOfVariables;

      Q = &lQhi[mmDofStartIndex];

      for (int ivar = 0; ivar < numberOfVariables; ivar++) {
        lQhbnd[dofStartIndexL + ivar] += kernels::FLCoeff[basisSize - 1][mm] *
                                         Q[ivar];  // lQhbnd(Facei,nDOF,nVar)
        lQhbnd[dofStartIndexR + ivar] += kernels::FRCoeff[basisSize - 1][mm] *
                                         Q[ivar];  // lQhbnd(Facei,nDOF,nVar)

        lFhbnd[dofStartIndexL + ivar] +=
            kernels::FLCoeff[basisSize - 1][mm] *
            lFhi_x[mmDofStartIndex + ivar];  // lFhi_x * FLCoeff
        lFhbnd[dofStartIndexR + ivar] +=
            kernels::FRCoeff[basisSize - 1][mm] *
            lFhi_x[mmDofStartIndex + ivar];  // lFhi_x * FRCoeff
      }
    }
    continue;
  }

  //
  // y-direction: face 2 (left) and face 3 (right)
  //
  for (int ii = 0; ii < basisSize; ii++) {
    const int nodeIndex = ii;
    const int dofStartIndexL =
        EXAHYPE_FACE_FRONT * numberOfFaceDof + nodeIndex * numberOfVariables;
    const int dofStartIndexR =
        EXAHYPE_FACE_BACK * numberOfFaceDof + nodeIndex * numberOfVariables;

    for (int mm = 0; mm < basisSize; mm++) {
      const int mmNodeIndex = ii + basisSize * mm;
      const int mmDofStartIndex = mmNodeIndex * numberOfVariables;

      Q = &lQhi[mmDofStartIndex];

      for (int ivar = 0; ivar < numberOfVariables; ivar++) {
        lQhbnd[dofStartIndexL + ivar] +=
            kernels::FLCoeff[basisSize - 1][mm] * Q[ivar];
        lQhbnd[dofStartIndexR + ivar] +=
            kernels::FRCoeff[basisSize - 1][mm] * Q[ivar];

        // without reordering of lFhi_y
        // lFhbnd[dofStartIndexL+ivar] += kernels::FLCoeff[basisSize-1][mm] *
        // lFhi_y[mmDofStartIndex+ivar]; // lFhi_y * FLCoeff
        // lFhbnd[dofStartIndexR+ivar] += kernels::FRCoeff[basisSize-1][mm] *
        // lFhi_y[mmDofStartIndex+ivar]; // lFhi_y * FRCoeff
        lFhbnd[dofStartIndexL + ivar] +=
            kernels::FLCoeff[basisSize - 1][mm] *
            lFhi_y[(mm + basisSize * ii) * numberOfVariables +
                   ivar];  // lFhi_y * FLCoeff
        lFhbnd[dofStartIndexR + ivar] +=
            kernels::FRCoeff[basisSize - 1][mm] *
            lFhi_y[(mm + basisSize * ii) * numberOfVariables +
                   ivar];  // lFhi_y * FRCoeff
      }  // mmDOfStartIndex = (mm  + basisSize * ii) * numberOfVariables
    }
    continue;
  }

  // clean up
  //  std::free(dqdt);
  delete[] rhs0;
  delete[] rhs;
  delete[] tmp;
}

/******************************************************************************************************
*******************************************************************************************************
******************************************************************************************************/

template <void PDEFlux(const double* const Q, double** F)>
void kernels::aderdg::generic::c::spaceTimePredictorNonlinear(
    double* lQi, double* lFi, const double* const luh,
    const tarch::la::Vector<DIMENSIONS, double>& dx, const double dt,
    int numberOfVariables, int numberOfParameters, int basisSize) {
  std::cout << "spaceTimePredictor Picard only" << std::endl;
  // todo Angelika
  // Please remove the typedefs in generic kernels again since numberOf(...)Dof
  // is not
  // a compile time variable anymore
  // helper variables
  // const int order = basisSize-1;

  // UNCOMMENT FOR DEBUGGING PURPOSES
  //  lQi[0] = 1;
  //  lFi[0] = 2;
  //  lQhi[0] = 3;
  //  lFhi[0] = 4;
  //
  //  constexpr int numberOfFaceDof = 5 * (3+1);
  //
  //  lQhbnd[EXAHYPE_FACE_LEFT*numberOfFaceDof] = 11;
  //  lFhbnd[EXAHYPE_FACE_LEFT*numberOfFaceDof] = 21;
  //
  //  lQhbnd[EXAHYPE_FACE_RIGHT*numberOfFaceDof] = 12;
  //  lFhbnd[EXAHYPE_FACE_RIGHT*numberOfFaceDof] = 22;
  //
  //  lQhbnd[EXAHYPE_FACE_FRONT*numberOfFaceDof] = 13;
  //  lFhbnd[EXAHYPE_FACE_FRONT*numberOfFaceDof] = 23;
  //
  //  lQhbnd[EXAHYPE_FACE_BACK*numberOfFaceDof] = 14;
  //  lFhbnd[EXAHYPE_FACE_BACK*numberOfFaceDof] = 24;
  //  const int DIMENSIONS = 2;  // 2
  // constexpr int DIMENSIONSTimesTwo = (2*2);     // 4
  //  constexpr int basisSize = (3 + 1);  // basisSize=order+1
  //  constexpr int numberOfVariables = 5;             // numberOfVariables

  // helper variables
  const int numberOfSpaceTimeDof =
      numberOfVariables * basisSize * basisSize *
      basisSize; /*tarch::la::aPowI(DIMENSIONS+1,basisSize); */
                 //  constexpr int numberOfDof =
                 //      numberOfVariables * basisSize * basisSize;
                 //      /*tarch::la::aPowI(DIMENSIONS,basisSize);*/

  double* rhs0 = new double[numberOfSpaceTimeDof];
  double* rhs = new double[numberOfSpaceTimeDof];
  double* tmp = new double[numberOfVariables * basisSize];

  for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
    for (int jj = 0; jj < basisSize; jj++) {
      for (int ll = 0; ll < basisSize; ll++) {  // loop over dof
        // location and index of nodal degrees of freedom
        const int nodeIndex = ii + basisSize * jj;
        const int spaceTimeNodeIndex =
            ii + basisSize * jj + basisSize * basisSize * ll;

        const int dofStartIndex = nodeIndex * numberOfVariables;
        const int spaceTimeDofStartIndex =
            spaceTimeNodeIndex * numberOfVariables;

        for (int ivar = 0; ivar < numberOfVariables; ivar++) {
          // Trivial initial guess (can be significantly improved)
          lQi[spaceTimeDofStartIndex + ivar] = luh[dofStartIndex + ivar];

          // Compute the contribution of the initial condition uh to the time
          // update. I prefer to compute it once
          // and store it in rhs0, but if you think it is faster, you can also
          // recompute this contribution
          // inside the Picard loop (DO iter = 1, N+1)
          rhs0[spaceTimeDofStartIndex + ivar] =
              kernels::gaussLegendreWeights[basisSize - 1][ii] *
              kernels::gaussLegendreWeights[basisSize - 1][jj] *
              kernels::F0[basisSize - 1][ll] * luh[dofStartIndex + ivar];
        }
      }
    }
  }
  // Above seems to work!

  double* Q;
  double* f;
  double* g;

  // double* dqdt = (double*) std::malloc(numberOfVariables * basisSize *
  // sizeof(double)); //
  // todo this is just for debugging; in general, do not use mallocs

  // Discrete Picard iterations. This set of nested loops should (theoretically)
  // be a dream for vectorization, since they are rather independent...
  for (int iter = 1; iter < basisSize + 1; iter++) {
    // Compute the fluxes (once these fluxes are available, the subsequent
    // operations are independent from each other)
    for (int ll = 0; ll < basisSize; ll++) {    // loop over dof (time)
      for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
        for (int jj = 0; jj < basisSize; jj++) {
          const int nodeIndex = ii + basisSize * jj;
          const int spaceTimeNodeIndex = nodeIndex + basisSize * basisSize * ll;

          const int spaceTimeDofStartIndex =
              spaceTimeNodeIndex * numberOfVariables;
          const int spaceTimeFluxDofStartIndex =
              spaceTimeDofStartIndex * DIMENSIONS;

          Q = &lQi[spaceTimeDofStartIndex];
          double* F[2];
          F[0] = &lFi[spaceTimeFluxDofStartIndex];
          F[1] = &lFi[spaceTimeFluxDofStartIndex + numberOfVariables];

          // @todo Angelika's old code
          // exahype::problem::PDEFlux(Q,f,g);
          PDEFlux(Q, F);
        }
      }
      // Above seems okay!

      // x direction (independent from the y and z derivatives)
      // Kxi : basisSize * basisSize
      // lFh : numberOfVariables * basisSize

      // Compute the "derivatives" (contributions of the stiffness matrix)
      // x direction (independent from the y and z derivatives)
      for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
        for (int jj = 0; jj < basisSize; jj++) {
          const int nodeIndex = ii + basisSize * jj;
          const int spaceTimeNodeIndex = nodeIndex + basisSize * basisSize * ll;
          const int spaceTimeDofStartIndex =
              spaceTimeNodeIndex * numberOfVariables;

          double weight = kernels::gaussLegendreWeights[basisSize - 1][ll] *
                          kernels::gaussLegendreWeights[basisSize - 1][jj];

          // COMPUTE SPATIAL DERIVATIVES FOR TESTING PURPOSES
          // for (int ll=0; ll < basisSize; ll++) { // set tmp = 0
          //  for(int ivar=0; ivar < numberOfVariables; ivar++) {
          //    tmp[ivar + numberOfVariables*ll] = 0.;
          //  }
          //}
          //
          // for(int mm=0; mm < basisSize; mm++) {
          //  const int mmNodeIndex        = mm + basisSize * jj;
          //  const int mmSpaceTimeNodeIndex         = mmNodeIndex  + basisSize
          //  * basisSize * ll;
          //  const int mmSpaceTimeDofStartIndex     = mmSpaceTimeNodeIndex *
          //  numberOfVariables;
          //  const int mmSpaceTimeFluxDofStartIndex = mmSpaceTimeDofStartIndex
          //  * DIMENSIONS;
          //
          //  Q = &(lQi [mmSpaceTimeDofStartIndex]);
          //  for(int ivar=0; ivar < numberOfVariables; ivar++) {
          //    tmp[ivar] += 1./dxPatch * dg::dudx[ii][mm] * Q[ivar];
          //  }
          //}
          for (int ivar = 0; ivar < numberOfVariables; ivar++) {
            rhs[spaceTimeDofStartIndex + ivar] =
                rhs0[spaceTimeDofStartIndex + ivar];
          }

          for (int mm = 0; mm < basisSize; mm++) {
            const int mmNodeIndex = mm + basisSize * jj;
            const int mmSpaceTimeNodeIndex =
                mmNodeIndex + basisSize * basisSize * ll;
            const int mmSpaceTimeDofStartIndex =
                mmSpaceTimeNodeIndex * numberOfVariables;
            const int mmSpaceTimeFluxDofStartIndex =
                mmSpaceTimeDofStartIndex * DIMENSIONS;

            f = &lFi[mmSpaceTimeFluxDofStartIndex];

            for (int ivar = 0; ivar < numberOfVariables; ivar++) {
              rhs[spaceTimeDofStartIndex + ivar] -=
                  weight * dt / dx[0] * kernels::Kxi[basisSize - 1][mm][ii] *
                  f[ivar];
            }
          }
        }
      }
      // Above seems okay!

      // Compute the "derivatives" (contributions of the stiffness matrix)
      // y direction (independent from the x and z derivatives)
      for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
        for (int jj = 0; jj < basisSize; jj++) {
          const int nodeIndex = ii + basisSize * jj;
          const int spaceTimeNodeIndex = nodeIndex + basisSize * basisSize * ll;
          const int spaceTimeDofStartIndex =
              spaceTimeNodeIndex * numberOfVariables;

          double weight = kernels::gaussLegendreWeights[basisSize - 1][ll] *
                          kernels::gaussLegendreWeights[basisSize - 1][ii];

          for (int mm = 0; mm < basisSize; mm++) {
            const int mmNodeIndex = ii + basisSize * mm;
            const int mmSpaceTimeNodeIndex =
                mmNodeIndex + basisSize * basisSize * ll;
            const int mmSpaceTimeDofStartIndex =
                mmSpaceTimeNodeIndex * numberOfVariables;
            const int mmSpaceTimeFluxDofStartIndex =
                mmSpaceTimeDofStartIndex * DIMENSIONS;

            g = &lFi[mmSpaceTimeFluxDofStartIndex + numberOfVariables];

            for (int ivar = 0; ivar < numberOfVariables; ivar++) {
              rhs[spaceTimeDofStartIndex + ivar] -=
                  weight * dt / dx[1] * kernels::Kxi[basisSize - 1][mm][jj] *
                  g[ivar];
            }
          }
        }
      }
    }  // end of time dof loop

    // Above seems okay!

    for (int ii = 0; ii < basisSize; ii++) {  // loop over dof
      for (int jj = 0; jj < basisSize; jj++) {
        const int nodeIndex = ii + basisSize * jj;

        double iWeight =
            1. / (kernels::gaussLegendreWeights[basisSize - 1][ii] *
                  kernels::gaussLegendreWeights[basisSize - 1][jj]);

        for (int ll = 0; ll < basisSize; ll++) {  // set tmp = 0
          for (int ivar = 0; ivar < numberOfVariables; ivar++) {
            tmp[ivar + numberOfVariables * ll] = 0.;
          }
        }

        for (int ll = 0; ll < basisSize; ll++) {  // loop over dof

          for (int nn = 0; nn < basisSize; nn++) {
            const int nnSpaceTimeNodeIndex =
                nodeIndex + basisSize * basisSize * nn;
            const int nnSpaceTimeDofStartIndex =
                nnSpaceTimeNodeIndex * numberOfVariables;

            for (int ivar = 0; ivar < numberOfVariables; ivar++) {
              tmp[ivar + numberOfVariables * ll] +=
                  iWeight * kernels::iK1[basisSize - 1][ll][nn] *
                  rhs[nnSpaceTimeDofStartIndex + ivar];
            }
          }
        }

        for (int ll = 0; ll < basisSize; ll++) {  // loop over dof
          const int spaceTimeNodeIndex = nodeIndex + basisSize * basisSize * ll;
          const int spaceTimeDofStartIndex =
              spaceTimeNodeIndex * numberOfVariables;

          for (int ivar = 0; ivar < numberOfVariables; ivar++) {
            lQi[spaceTimeDofStartIndex + ivar] =
                tmp[ivar + numberOfVariables * ll];
          }
        }
      }
    }
  }  // end of Picard iteration
}

#endif  // DIMENSIONS == 2

/******************************************************************************************************
*******************************************************************************************************
******************************************************************************************************/
