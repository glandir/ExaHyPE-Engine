/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

#include <tarch/la/Vector.h>
#include <cstring>
#include <utility>

#include "../../../../DGMatrices.h"
#include "../../../../GaussLegendreQuadrature.h"
#include "../../../../KernelUtils.h"

#if DIMENSIONS == 2

namespace kernels {
namespace aderdg {
namespace generic {
namespace c {

namespace {

template <void PDEFlux2d(const double* const Q, double** F),
          void PDESource(const double* const Q, double* S)>
void aderPicardLoopNonlinear(const double* luh, const double dt,
                             const tarch::la::Vector<DIMENSIONS, double>& dx,
                             int numberOfVariables, int basisSize, double* lQi,
                             double* lFi) {
  idx3 idx_luh(basisSize, basisSize, numberOfVariables);
  idx4 idx_lQi(basisSize, basisSize, basisSize, numberOfVariables);
  idx5 idx_lFi(basisSize, basisSize, basisSize, DIMENSIONS + 1,
               numberOfVariables);

  const int order = basisSize - 1;
  const int basisSize2 = basisSize * basisSize;
  const int basisSize3 = basisSize2 * basisSize;

  // 1. Trivial initial guess
  for (int j = 0; j < basisSize; j++) {
    for (int k = 0; k < basisSize; k++) {
      for (int l = 0; l < basisSize; l++) {
        for (int m = 0; m < numberOfVariables; m++) {
          // Fortran: lQi(m,:,k,j) = luh(m,k,j)
          lQi[idx_lQi(j, k, l, m)] = luh[idx_luh(j, k, m)];
        }
      }
    }
  }

  // 2. Compute the contribution of the initial condition uh to the time update
  double* rhs0 = new double[basisSize3 * numberOfVariables];
  idx4 idx_rhs(basisSize, basisSize, basisSize, numberOfVariables);
  for (int j = 0; j < basisSize; j++) {
    for (int k = 0; k < basisSize; k++) {
      for (int l = 0; l < numberOfVariables; l++) {
        for (int m = 0; m < basisSize; m++) {
          rhs0[idx_rhs(m, j, k, l)] =
              kernels::F0[order][m] * luh[idx_luh(j, k, l)];
        }
      }
    }
  }

  // 3. Discrete Picard iterations
  double* lQi2 = new double[basisSize3 * numberOfVariables];

  double* lQi_new = lQi;
  double* lQi_old = lQi2;

  double* rhs = new double[basisSize3 * numberOfVariables];

  const int MaxIterations = 2 * (order + 1);

  for (int iter = 0; iter < MaxIterations; iter++) {
    // Save old space-time DOF
    std::swap(lQi_new, lQi_old);

    for (int i = 0; i < basisSize; i++) {  // time DOF
                                           // Compute the fluxes
      for (int k = 0; k < basisSize; k++) {
        for (int l = 0; l < basisSize; l++) {
          // Call PDE fluxes
          const double* Q = &lQi_old[idx_lQi(k, l, i, 0)];
          double* F[2];
          F[0] = &lFi[idx_lFi(i, k, l, 0, 0)];
          F[1] = &lFi[idx_lFi(i, k, l, 1, 0)];
          double* S = &lFi[idx_lFi(i, k, l, 2, 0)];
          PDEFlux2d(Q, F);
          PDESource(Q, S);
        }
      }
    }

    // Copy rhs0 -> rhs
    std::copy(rhs0, rhs0 + basisSize3 * numberOfVariables, rhs);

    // Compute the "derivatives" (contributions of the stiffness matrix)
    // x direction (independent from the y derivatives)
    for (int i = 0; i < basisSize; i++) {  // time DOF
      for (int k = 0; k < basisSize; k++) {
        const double updateSize =
            kernels::gaussLegendreWeights[order][i] * dt / dx[0];
        // Matrix operation
        for (int l = 0; l < basisSize; l++) {
          for (int m = 0; m < numberOfVariables; m++) {
            for (int n = 0; n < basisSize; n++) {
              rhs[idx_rhs(i, k, l, m)] -=
                  updateSize / kernels::gaussLegendreWeights[order][l] *
                  lFi[idx_lFi(i, k, n, 0, m)] * kernels::Kxi[order][n][l];
            }
          }
        }
      }
    }

    // y direction (independent from the x derivatives)
    for (int i = 0; i < basisSize; i++) {  // time DOF
      for (int k = 0; k < basisSize; k++) {
        const double updateSize =
            kernels::gaussLegendreWeights[order][i] * dt / dx[1];

        // Matrix operation
        for (int l = 0; l < basisSize; l++) {
          for (int m = 0; m < numberOfVariables; m++) {
            for (int n = 0; n < basisSize; n++) {
              rhs[idx_rhs(i, l, k, m)] -=
                  updateSize / kernels::gaussLegendreWeights[order][l] *
                  lFi[idx_lFi(i, n, k, 1, m)] * kernels::Kxi[order][n][l];
            }
          }
        }
      }
    }

    // source
    for (int i = 0; i < basisSize; i++) {  // time DOF
      for (int k = 0; k < basisSize; k++) {
        for (int l = 0; l < basisSize; l++) {
          const double updateSize =
              kernels::gaussLegendreWeights[order][i] * dt;
          double* S = &lFi[idx_lFi(i, k, l, 2, 0)];

          // TODO: numberOfVariables - numberOfParameters would do

          // TODO: Subtract nonconservative part from S
          for (int m = 0; m < numberOfVariables; m++) {
            rhs[idx_rhs(i, k, l, m)] += updateSize * S[m];
          }
        }
      }
    }  // end time dof

    // 4. Multiply with (K1)^(-1) to get the discrete time integral of the
    // discrete Picard iteration
    std::memset(lQi_new, 0, basisSize3 * numberOfVariables * sizeof(double));
    for (int j = 0; j < basisSize; j++) {
      for (int k = 0; k < basisSize; k++) {
        // Matrix operation
        for (int l = 0; l < basisSize; l++) {
          for (int m = 0; m < numberOfVariables; m++) {
            for (int n = 0; n < basisSize; n++) {
              lQi_new[idx_lQi(j, k, l, m)] +=
                  rhs[idx_rhs(n, j, k, m)] * kernels::iK1[order][l][n];
              // TODO: Check if we store iK1 or rather its transpose
            }
          }
        }
      }
    }

    // 5. Exit condition
    // TODO(guera): Stability of sum? -> Kahan, reduction?
    // TODO(guera): Is there something like kernels::tol?
    // TODO(guera): Dangerous!
    const double tol = 1e-7;
    double sq_res = 0.0;
    for (int i = 0; i < basisSize3 * numberOfVariables; i++) {
      sq_res += (lQi_old[i] - lQi_new[i]) * (lQi_old[i] - lQi_new[i]);
    }
    if (sq_res < tol * tol) {
      break;
    }

    if (iter == MaxIterations) {  // No convergence after last iteration
      static tarch::logging::Log _log("kernels::aderdg::generic::c");
      logWarning("aderPicardLoopNonlinear(...)",
                 "|res|^2=" << sq_res << " > |tol|^2=" << tol * tol << " after "
                            << iter << " iterations. Solver seems not to have "
                                       "converged properly within maximum "
                                       "number of iteration steps");
    }
  }  // end iter

  // If the number of iterations has been odd lQi2 containes the latest solution
  // instead of lQi.
  if (lQi_new == lQi2) {
    std::copy(lQi2, lQi2 + basisSize3 * numberOfVariables, lQi);
  }

  // Delete heap-allocated arrays
  delete[] rhs0;
  delete[] lQi2;
  delete[] rhs;
}

void aderPredictorNonlinear(const double* lQi, const double* lFi,
                            int numberOfVariables, int basisSize, double* lQhi,
                            double* lFhi_x, double* lFhi_y, double* lShi) {
  // Immediately compute the time - averaged space - time polynomials

  const int basisSize2 = basisSize * basisSize;
  const int order = basisSize - 1;

  idx4 idx_lQi(basisSize, basisSize, basisSize, numberOfVariables);
  idx5 idx_lFi(basisSize, basisSize, basisSize, DIMENSIONS + 1,
               numberOfVariables);

  idx3 idx_lQhi(basisSize, basisSize, numberOfVariables);
  idx3 idx_lFhi(basisSize, basisSize, numberOfVariables);
  idx3 idx_lShi(basisSize, basisSize, numberOfVariables);

  std::memset(lQhi, 0, basisSize2 * numberOfVariables * sizeof(double));
  std::memset(lFhi_x, 0, basisSize2 * numberOfVariables * sizeof(double));
  std::memset(lFhi_y, 0, basisSize2 * numberOfVariables * sizeof(double));
  std::memset(lShi, 0, basisSize2 * numberOfVariables * sizeof(double));

  for (int j = 0; j < basisSize; j++) {
    for (int k = 0; k < basisSize; k++) {
      for (int l = 0; l < numberOfVariables; l++) {
        // Matrix-Vector Products
        for (int m = 0; m < basisSize; m++) {
          // Fortran: lQhi(:,k,j) = lQi(:,:,k,j) * wGPN(:)
          lQhi[idx_lQhi(j, k, l)] += lQi[idx_lQi(j, k, m, l)] *
                                     kernels::gaussLegendreWeights[order][m];

          // Fortran: lFhi_x(:,k,j) = lFh(:,1,k,j,:) * wGPN(:)
          lFhi_x[idx_lFhi(j, k, l)] += lFi[idx_lFi(m, j, k, 0, l)] *
                                       kernels::gaussLegendreWeights[order][m];

          // Fortran: lFhi_y(:,j,k) = lFh(:,2,:k,j,:) * wGPN(:)
          lFhi_y[idx_lFhi(k, j, l)] += lFi[idx_lFi(m, j, k, 1, l)] *
                                       kernels::gaussLegendreWeights[order][m];

          // Fortran: lShi(:,k,j) = lSh(:,k,j,:) * wGPN(:)
          lShi[idx_lShi(j, k, l)] += lFi[idx_lFi(m, j, k, 2, l)] *
                                     kernels::gaussLegendreWeights[order][m];
        }
      }
    }
  }
}

void aderExtrapolatorNonlinear(const double* lQhi, const double* lFhi_x,
                               const double* lFhi_y, int numberOfVariables,
                               int basisSize, double* lQhbnd, double* lFhbnd) {
  // Compute the boundary-extrapolated values for Q and F*n

  const int order = basisSize - 1;

  idx3 idx_lQhi(basisSize, basisSize, numberOfVariables);
  idx3 idx_lFhi(basisSize, basisSize, numberOfVariables);

  idx3 idx_lQhbnd(2 * DIMENSIONS, basisSize, numberOfVariables);
  idx3 idx_lFhbnd(2 * DIMENSIONS, basisSize, numberOfVariables);

  std::memset(lQhbnd, 0,
              2 * DIMENSIONS * basisSize * numberOfVariables * sizeof(double));
  std::memset(lFhbnd, 0,
              2 * DIMENSIONS * basisSize * numberOfVariables * sizeof(double));

  // x-direction: face 1 (left) and face 2 (right)
  for (int j = 0; j < basisSize; j++) {
    // Matrix-Vector Products
    for (int k = 0; k < numberOfVariables; k++) {
      for (int l = 0; l < basisSize; l++) {
        // Fortran: lQhbnd(:,j,1) = lQhi(:,:,j) * FLCoeff(:)
        lQhbnd[idx_lQhbnd(0, j, k)] +=
            lQhi[idx_lQhi(j, l, k)] * kernels::FLCoeff[order][l];

        // Fortran: lQhbnd(:,j,2) = lQhi(:,:,j) * FRCoeff(:)
        lQhbnd[idx_lQhbnd(1, j, k)] +=
            lQhi[idx_lQhi(j, l, k)] * kernels::FRCoeff[order][l];

        // Fortran: lFhbnd(:,j,1) = lFhi_x(:,:,j) * FLCoeff(:)
        lFhbnd[idx_lFhbnd(0, j, k)] +=
            lFhi_x[idx_lFhi(j, l, k)] * kernels::FLCoeff[order][l];

        // Fortran: lFhbnd(:,j,2) = lFhi_x(:,:,j) * FRCoeff(:)
        lFhbnd[idx_lFhbnd(1, j, k)] +=
            lFhi_x[idx_lFhi(j, l, k)] * kernels::FRCoeff[order][l];
      }
    }
  }

  // y-direction: face 3 (left) and face 4 (right)
  for (int j = 0; j < basisSize; j++) {
    for (int k = 0; k < numberOfVariables; k++) {
      // Matrix-Vector Products
      for (int l = 0; l < basisSize; l++) {
        // Fortran: lQhbnd(:,j,3) = lQhi(:,j,:) * FLCoeff(:)
        lQhbnd[idx_lQhbnd(2, j, k)] +=
            lQhi[idx_lQhi(l, j, k)] * kernels::FLCoeff[order][l];

        // Fortran: lQhbnd(:,j,4) = lQhi(:,j,:) * FRCoeff(:)
        lQhbnd[idx_lQhbnd(3, j, k)] +=
            lQhi[idx_lQhi(l, j, k)] * kernels::FRCoeff[order][l];

        // Fortran: lFhbnd(:,j,3) = lFhi_y(:,:,j) * FLCoeff(:)
        lFhbnd[idx_lFhbnd(2, j, k)] +=
            lFhi_y[idx_lFhi(j, l, k)] * kernels::FLCoeff[order][l];

        // Fortran: lFhbnd(:,j,4) = lFhi_y(:,:,j) * FRCoeff(:)
        lFhbnd[idx_lFhbnd(3, j, k)] +=
            lFhi_y[idx_lFhi(j, l, k)] * kernels::FRCoeff[order][l];
      }
    }
  }
}

}  // namespace

template <void PDEFlux2d(const double* const Q, double** F),
          void PDESource(const double* const Q, double* S)>
void spaceTimePredictorNonlinear(
    double* lQi, double* lFi, double* lQhi, double* lFhi, double* lQhbnd,
    double* lFhbnd, const double* luh,
    const tarch::la::Vector<DIMENSIONS, double>& dx, double dt,
    int numberOfVariables, int numberOfParameters, int basisSize) {
  const int basisSize2 = basisSize * basisSize;

  aderPicardLoopNonlinear<PDEFlux2d, PDESource>(luh, dt, dx, numberOfVariables,
                                                basisSize, lQi, lFi);

  aderPredictorNonlinear(lQi, lFi, numberOfVariables, basisSize, lQhi,
                         &lFhi[0 * basisSize2 * numberOfVariables],  // lFhi_x
                         &lFhi[1 * basisSize2 * numberOfVariables],  // lFhi_y
                         &lFhi[2 * basisSize2 * numberOfVariables]   // lShi
                         );

  aderExtrapolatorNonlinear(
      lQhi,
      &lFhi[0 * basisSize2 * numberOfVariables],  // lFhi_x
      &lFhi[1 * basisSize2 * numberOfVariables],  // lFhi_y
      numberOfVariables, basisSize, lQhbnd, lFhbnd);
}

}  // namespace c
}  // namespace generic
}  // namespace aderdg
}  // namespace kernels

#endif  // DIMENSIONS == 2
