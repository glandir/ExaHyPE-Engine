/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

#include <algorithm> 
 
#if DIMENSIONS == 3 
 
namespace kernels {
namespace limiter {
namespace generic {
namespace c {
        
//TODO JMG
void getGaussLobattoData(const double* const luh, const int numberOfVariables, const int basisSize, double* lob, int& basisSizeLob) {
  basisSizeLob = 0;
}

//TODO JMG
void getFVMData(const double* const luh, const int numberOfVariables, const int basisSize, double* lim, int& basisSizeLim) {
  basisSizeLim= 0;
}

/**
 * localMin, localMax are double[numberOfVariables]
 */
void findCellLocallocalMinlocalMax(const double* const luh, const int numberOfVariables, const int basisSize, double* localMin, double* localMax) {      

  int index, ii;
  
  // initialize and process luh
  index = 0;
  for(int iVar = 0; iVar < numberOfVariables; iVar++) {
    localMin[iVar] = luh[index];
    localMax[iVar] = luh[index];   
    index++;
  }
  for(ii = 1; ii < basisSize*basisSize*basisSize; ii++) {
    for(int iVar = 0; iVar < numberOfVariables; iVar++) {
      if(luh[index] < localMin[iVar]) {
        localMin[iVar] = luh[index];
      } else if(luh[index] > localMax[iVar]) {
        localMax[iVar] = luh[index];
      }    
      index++;
    }
  }
 
  // process lob
  double* lob = 0;
  int basisSizeLob = 0;
  getGaussLobattoData(luh, numberOfVariables, basisSize, lob, basisSizeLob);
  index = 0;
  for(ii = 0; ii < basisSizeLob*basisSizeLob*basisSizeLob; ii++) {
    for(int iVar = 0; iVar < numberOfVariables; iVar++) {
      if(lob[index] < localMin[iVar]) {
        localMin[iVar] = lob[index];
      } else if(lob[index] > localMax[iVar]) {
        localMax[iVar] = lob[index];
      }    
      index++;
    }
  }
  
  // process lim
  index = 0;
  double* lim = 0;
  int basisSizeLim = 0;
  getFVMData(luh, numberOfVariables, basisSize, lim, basisSizeLim);
  for(ii = 0; ii < basisSizeLim*basisSizeLim*basisSizeLim; ii++) {
    for(int iVar = 0; iVar < numberOfVariables; iVar++) {
      if(lim[index] < localMin[iVar]) {
        localMin[iVar] = lim[index];
      } else if(lim[index] > localMax[iVar]) {
        localMax[iVar] = lim[index];
      }    
      index++;
    }
  }

}


bool isTroubledCell(const double* const luh, const int numberOfVariables, const int basisSize, const double* const troubledMin, const double* const troubledMax) {
  
  double minMarginOfError = 0.0001;
  double diffScaling = 0.001;
  
  double* localMin = new double[numberOfVariables];
  double* localMax = new double[numberOfVariables];
  findCellLocallocalMinlocalMax(luh, numberOfVariables, basisSize, localMin, localMax);
  
  double ldiff;

  for(int iVar = 0; iVar < numberOfVariables; iVar++) {
    ldiff = std::max((troubledMax[iVar] - troubledMin[iVar]) * diffScaling, minMarginOfError);
    if((localMin[iVar] < (troubledMin[iVar] - ldiff)) || (localMax[iVar] > (troubledMax[iVar] + ldiff))) {
      return true;
    }
  }
  
  //TODO JMG (todo or not needed???) check PDE positivity and lim data not NAN 
  
  return false;
}

} // namespace c
} // namespace generic
} // namespace limiter
} // namespace kernel

#endif //DIMENSIONS == 3