{# /**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/ #}

#include <cstring>
 
#include "kernels/aderdg/optimised/Kernels.h"
#include "kernels/aderdg/optimised/GaussLegendreQuadrature.h"
#include "kernels/aderdg/optimised/DGMatrices.h"
//#include "kernels/aderdg/optimised/asm_extrapolatedPredictor.c"
 
void kernels::aderdg::optimised::extrapolatorNonlinear(
        const double* restrict const lQhi, 
        const double* restrict const lFhi,
        double* restrict lQhbnd, 
        double* restrict lFhbnd) {
  // Compute the boundary-extrapolated values for Q and F*n

  std::memset(lQhbnd, 0, {{2*nDim*bndBlockSize*nVar}} * sizeof(double));
  std::memset(lFhbnd, 0, {{2*nDim*bndBlockSize*nVar}} * sizeof(double));

  // x-direction: face 1 (left) and face 2 (right)
  for (int ij = 0; ij < {{nDof*nDof3D}}; ij++) {
    // Matrix-Vector Products
    for (int n = 0; n < {{nVar}}; n++) {
      for (int l = 0; l < {{nDof}}; l++) {
        // Fortran: lQhbnd(:,j,i,1) = lQhi(:,:,j,i) * FLCoeff(:)
        lQhbnd[ij+{{bndBlockSize}}*n] +=
            lQhi[n+{{nVarPad}}*(l+{{nDof}}*ij)] * FLCoeff[l];

        // Fortran: lQhbnd(:,j,i,2) = lQhi(:,:,j,i) * FRCoeff(:)
        lQhbnd[ij+{{bndBlockSize}}*n+{{1*nVar*bndBlockSize}}] +=
            lQhi[n+{{nVarPad}}*(l+{{nDof}}*ij)] * FRCoeff[l];

        // Fortran: lFhbnd(:,j,i,1) = lFhi_x(:,:,j,i) * FLCoeff(:)
        lFhbnd[ij+{{bndBlockSize}}*n] +=
            lFhi[n+{{nVarPad}}*(l+{{nDof}}*ij)] * FLCoeff[l];

        // Fortran: lFhbnd(:,j,i,2) = lFhi_x(:,:,j,i) * FRCoeff(:)
        lFhbnd[ij+{{bndBlockSize}}*n+{{1*nVar*bndBlockSize}}] +=
            lFhi[n+{{nVarPad}}*(l+{{nDof}}*ij)] * FRCoeff[l];
      }
    }
  }

  // y-direction: face 3 (left) and face 4 (right)
  for (int ij = 0; ij < {{nDof*nDof3D}}; ij++) {
    for (int n = 0; n < {{nVar}}; n++) {
      // Matrix-Vector Products
      for (int l = 0; l < {{nDof}}; l++) {
        {% if nDim==3 %}
        const int i = ij / {{nDof}};
        const int j = ij % {{nDof}};
        {% else %}
        const int i = 0;
        const int j = ij;
        {% endif %}
        // Fortran: lQhbnd(:,j,i,3) = lQhi(:,j,:,i) * FLCoeff(:)
        lQhbnd[ij+{{bndBlockSize}}*n+{{2*nVar*bndBlockSize}}] +=
            lQhi[n+{{nVarPad}}*(j+{{nDof}}*(l+{{nDof3D}}*i))] * FLCoeff[l];

        // Fortran: lQhbnd(:,j,i,4) = lQhi(:,j,:,i) * FRCoeff(:)
        lQhbnd[ij+{{bndBlockSize}}*n+{{3*nVar*bndBlockSize}}] +=
            lQhi[n+{{nVarPad}}*(j+{{nDof}}*(l+{{nDof3D}}*i))] * FRCoeff[l];

        // Fortran: lFhbnd(:,j,i,3) = lFhi_y(:,:,j,i) * FLCoeff(:)
        lFhbnd[ij+{{bndBlockSize}}*n+{{2*nVar*bndBlockSize}}] +=
            lFhi[n+{{nVarPad}}*(l+{{nDof}}*ij)+{{1*nVarPad*(nDof**nDim)}}] * FLCoeff[l];

        // Fortran: lFhbnd(:,j,i,4) = lFhi_y(:,:,j,i) * FRCoeff(:)
        lFhbnd[ij+{{bndBlockSize}}*n+{{3*nVar*bndBlockSize}}] +=
            lFhi[n+{{nVarPad}}*(l+{{nDof}}*ij)+{{1*nVarPad*(nDof**nDim)}}] * FRCoeff[l];
      }
    }
  }

  
  {% if nDim==3 %}
  // z-direction: face 5 (left) and face 6 (right)
  for (int ij = 0; ij < {{nDof*nDof}}; ij++) {
    for (int n = 0; n < {{nVar}}; n++) {
      // Matrix-Vector Products
      for (int l = 0; l < {{nDof}}; l++) {
        // Fortran: lQhbnd(:,j,i,5) = lQhi(:,j,i,:) * FLCoeff(:)
        lQhbnd[ij+{{bndBlockSize}}*n+{{4*nVar*bndBlockSize}}] +=
            lQhi[n+{{nVarPad}}*(ij+{{nDof*nDof}}*l)] * FLCoeff[l];

        // Fortran: lQhbnd(:,j,i,6) = lQhi(:,j,i,:) * FRCoeff(:)
        lQhbnd[ij+{{bndBlockSize}}*n+{{5*nVar*bndBlockSize}}] +=
            lQhi[n+{{nVarPad}}*(ij+{{nDof*nDof}}*l)] * FRCoeff[l];

        // Fortran: lFhbnd(:,j,i,5) = lFhi_z(:,:,j,i) * FLCoeff(:)
        lFhbnd[ij+{{bndBlockSize}}*n+{{4*nVar*bndBlockSize}}] +=
            lFhi[n+{{nVarPad}}*(l+{{nDof}}*ij)+{{2*nVarPad*(nDof**nDim)}}] * FLCoeff[l];

        // Fortran: lFhbnd(:,j,i,6) = lFhi_z(:,:,j,i) * FRCoeff(:)
        lFhbnd[ij+{{bndBlockSize}}*n+{{5*nVar*bndBlockSize}}] +=
            lFhi[n+{{nVarPad}}*(l+{{nDof}}*ij)+{{2*nVarPad*(nDof**nDim)}}] * FRCoeff[l];
      }
    }
  }
  {% endif %}
}