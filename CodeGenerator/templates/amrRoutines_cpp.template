/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon 
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/
#include "tarch/la/Scalar.h"
#include "tarch/la/ScalarOperations.h"

#include "{{pathToOptKernel}}/Kernels.h"
#include "{{pathToOptKernel}}/DGMatrices.h"
#include "{{pathToOptKernel}}/GaussLegendreQuadrature.h"


// Helper template functions
//--------------------------

//TODO JMG optimize amr with libxsmm (tensor-tensor product)

template<int dataSize>
void singleLevelFaceUnknownsProlongation(double* fine, const double* coarse, const tarch::la::Vector<DIMENSIONS-1, int>& subfaceIndex) {
  for (int m2=0; m2<{{nDof3D}}; m2++) {
    for (int m1 = 0; m1<{{nDof}}; m1++) {
      for (int d = 0; d<dataSize; d++) {
        for (int n2=0; n2<{{nDof3D}}; n2++) {
          for (int n1 = 0; n1<{{nDof}}; n1++) {
            fine[(m2*{{nDof}}+m1)*dataSize+d] +=
                coarse[(n2*{{nDof}}+n1)*dataSize+d]
{% if nDim==3 %}
                * {{codeNamespace}}::fineGridProjector1d[subfaceIndex[1]][m2*{{nDofPad}}+n2]
{% endif %}
                * {{codeNamespace}}::fineGridProjector1d[subfaceIndex[0]][m1*{{nDofPad}}+n1];
          }
        }
      }
    }
  }
}

template <int dataSize>
void singleLevelFaceUnknownsRestriction(double* coarse, const double* fine, const tarch::la::Vector<DIMENSIONS-1, int>& subfaceIndex) {
   for (int m2=0; m2<{{nDof3D}}; m2++) {
    for (int m1 = 0; m1<{{nDof}}; m1++) {
      for (int d = 0; d<dataSize; d++) {
        for (int n2=0; n2<{{nDof3D}}; n2++) {
          for (int n1 = 0; n1<{{nDof}}; n1++) {          
            coarse[(m2*{{nDof}}+m1)*dataSize+d] +=
                             fine[(n2*{{nDof}}+n1)*dataSize+d]
                             * {{codeNamespace}}::fineGridProjector1d_T[subfaceIndex[0]][m1*{{nDofPad}}+n1]
{% if nDim==3 %}                             
                             * {{codeNamespace}}::fineGridProjector1d_T[subfaceIndex[1]][m2*{{nDofPad}}+n2]
{% endif %}
                             * {{codeNamespace}}::weights2[n2*{{nDof}}+n1]
                             / {{codeNamespace}}::weights2[m2*{{nDof}}+m1]
                             / {{ 9.0 if nDim==3 else 3.0}};
          }
        }
      }
    }
  }
}

template <int dataSize>
void singleLevelVolumeUnknownsProlongation(double* fine, const double* coarse, const tarch::la::Vector<DIMENSIONS, int>& subcellIndex) {
  for (int m3=0; m3<{{nDof3D}}; m3++) {
    for (int m2=0; m2<{{nDof}}; m2++) {
      for (int m1 = 0; m1<{{nDof}}; m1++) {
        for (int d = 0; d<dataSize; d++) {
          for (int n3=0; n3<{{nDof3D}}; n3++) {
            for (int n2=0; n2<{{nDof}}; n2++) {
              for (int n1 = 0; n1<{{nDof}}; n1++) {  
                fine[((m3*{{nDof}}+m2)*{{nDof}}+m1)*dataSize+d]
                        += coarse[((m3*{{nDof}}+m2)*{{nDof}}+m1)*dataSize+d] *
{% if nDim==3 %} 
                        {{codeNamespace}}::fineGridProjector1d[subcellIndex[2]][m3*{{nDofPad}}+n3] *
{% endif %}
                        {{codeNamespace}}::fineGridProjector1d[subcellIndex[0]][m2*{{nDofPad}}+n2] *
                        {{codeNamespace}}::fineGridProjector1d[subcellIndex[1]][m1*{{nDofPad}}+n1];
              }
            }
          }
        }
      }
    }
  }
}

template <int dataSize>
void singleLevelVolumeUnknownsRestriction(double* coarse, const double* fine, const tarch::la::Vector<DIMENSIONS, int>& subcellIndex) {
  for (int m3=0; m3<{{nDof3D}}; m3++) {
    for (int m2=0; m2<{{nDof}}; m2++) {
      for (int m1 = 0; m1<{{nDof}}; m1++) {
        for (int d = 0; d<dataSize; d++) {
          for (int n3=0; n3<{{nDof3D}}; n3++) {
            for (int n2=0; n2<{{nDof}}; n2++) {
              for (int n1 = 0; n1<{{nDof}}; n1++) {  
                coarse[((m3*{{nDof}}+m2)*{{nDof}}+m1)*dataSize+d] +=
                    fine[((m3*{{nDof}}+m2)*{{nDof}}+m1)*dataSize+d]
                    * {{codeNamespace}}::fineGridProjector1d_T[subcellIndex[0]][m1*{{nDofPad}}+n1]
                    * {{codeNamespace}}::fineGridProjector1d_T[subcellIndex[1]][m2*{{nDofPad}}+n2]
{% if nDim==3 %}
                    * {{codeNamespace}}::fineGridProjector1d_T[subcellIndex[2]][m3*{{nDofPad}}+n3]
{% endif %}
                    * {{codeNamespace}}::weights3[(n3*{{nDof}}+n2)*{{nDof}}+n1]
                    / {{codeNamespace}}::weights3[(m3*{{nDof}}+m2)*{{nDof}}+m1]
                    / {{ 27.0 if nDim==3 else 9.0}};
              }
            }
          }
        }
      }
    }
  }
}



// AMR Routines
//-------------



void {{codeNamespace}}::faceUnknownsProlongation(
    double* lQhbndFine,
    double* lFhbndFine,
    const double* lQhbndCoarse,
    const double* lFhbndCoarse,
    const int coarseGridLevel,
    const int fineGridLevel,
    const tarch::la::Vector<DIMENSIONS-1, int>& subfaceIndex
) {
  const int levelDelta = fineGridLevel - coarseGridLevel;

  double lQhbndFineTemp[{{nDof*nDof3D*nDataPad}}];
  double lFhbndFineTemp[{{nDof*nDof3D*nVarPad }}];

  double * pointerQhbnd1 = 0;
  double * pointerFhbnd1 = 0;

  double * pointerQhbnd2 = 0;
  double * pointerFhbnd2 = 0;

  // This ensures that the pointerQhbnd1 
  // of the last iteration points to lQhbndFine.
  // The same is done for pointerFhbnd1.
  if (levelDelta % 2 == 0) {
    pointerQhbnd1 = lQhbndFineTemp;
    pointerFhbnd1 = lFhbndFineTemp;
  } else {
    pointerQhbnd1 = lQhbndFine;
    pointerFhbnd1 = lFhbndFine;
  }

  tarch::la::Vector<DIMENSIONS-1,int> subfaceIndexPrevious (subfaceIndex);
  tarch::la::Vector<DIMENSIONS-1,int> subfaceIndexCurrent;

  tarch::la::Vector<DIMENSIONS-1,int> subintervalIndex;
  // This loop decodes the elements of subfaceIndex into a tertiary basis
  // starting with the highest significance 3^(levelDelta-1).
  // 
  // Per iteration, the digits corresponding to the current significances then determine
  // the subintervals for the single level prolongation.
  for (int l = 1; l < levelDelta+1; ++l) {
    const int significance = tarch::la::aPowI(levelDelta-l,3);
    subfaceIndexCurrent[0] = subfaceIndexPrevious[0] % significance;
    subfaceIndexCurrent[1] = subfaceIndexPrevious[1] % significance;
    subintervalIndex[0]    = (subfaceIndexPrevious[0] - subfaceIndexCurrent[0])/significance;
    subintervalIndex[1]    = (subfaceIndexPrevious[1] - subfaceIndexCurrent[1])/significance;
    assertion(subintervalIndex[0] < 3);
    assertion(subintervalIndex[1] < 3);

    // Zero the values of the first pointer.
    std::fill_n(pointerQhbnd1, {{nDof*nDof3D*nDataPad}}, 0.0);
    std::fill_n(pointerFhbnd1, {{nDof*nDof3D*nVarPad }}, 0.0);

    // Apply the single level prolongation operator.
    // Use the coarse level unknowns as input in the first iteration.
    if (l==1) {
      singleLevelFaceUnknownsProlongation<{{nDataPad}}>(pointerQhbnd1, lQhbndCoarse, subintervalIndex);
      singleLevelFaceUnknownsProlongation<{{nVarPad }}>(pointerFhbnd1, lFhbndCoarse, subintervalIndex);
    } else {
      singleLevelFaceUnknownsProlongation<{{nDataPad}}>(pointerQhbnd1, pointerQhbnd2, subintervalIndex);
      singleLevelFaceUnknownsProlongation<{{nVarPad }}>(pointerFhbnd1, pointerFhbnd2, subintervalIndex);
    }

    // Prepare next iteration.
    subfaceIndexPrevious = subfaceIndexCurrent;

    pointerQhbnd2 = pointerQhbnd1;
    pointerFhbnd2 = pointerFhbnd1;
    
    // Toggle the addresses of the pointers.
    if (pointerQhbnd1 == lQhbndFineTemp) {
      pointerQhbnd1 = lQhbndFine;
      pointerFhbnd1 = lFhbndFine;
    } else {
      pointerQhbnd1 = lQhbndFineTemp;
      pointerFhbnd1 = lFhbndFineTemp;
    }
  }
}


void {{codeNamespace}}::faceUnknownsRestriction(
    double* lQhbndCoarse,
    double* lFhbndCoarse,
    const double* lQhbndFine,
    const double* lFhbndFine,
    const int coarseGridLevel,
    const int fineGridLevel,
    const tarch::la::Vector<DIMENSIONS-1, int>& subfaceIndex
) {
  const int levelDelta     = fineGridLevel - coarseGridLevel;

  double lQhbndCoarseTemp1[{{nDof*nDof3D*nDataPad}}];
  double lFhbndCoarseTemp1[{{nDof*nDof3D*nVarPad }}];
  double lQhbndCoarseTemp2[{{nDof*nDof3D*nDataPad}}];
  double lFhbndCoarseTemp2[{{nDof*nDof3D*nVarPad }}];

  double * pointerQhbnd1 = 0;
  double * pointerQhbnd2 = 0;
  double * pointerFhbnd1 = 0;
  double * pointerFhbnd2 = 0;

  pointerQhbnd1 = lQhbndCoarseTemp1;
  pointerFhbnd1 = lFhbndCoarseTemp1;

  tarch::la::Vector<DIMENSIONS-1,int> subfaceIndexCurrent(subfaceIndex);

  tarch::la::Vector<DIMENSIONS-1,int> subintervalIndex;
  
  // This loop decodes the indices of subfaceIndex into a tertiary basis
  // starting with the lowest significance 3^0 (in contrast to the prolongation loop).
  //
  // Per iteration, the digits corresponding to the current significances then determine
  // the subintervals for the single level restriction.
  for (int l = 1; l < levelDelta+1; ++l) {
    subintervalIndex[0]    = subfaceIndexCurrent[0] % 3;
    subintervalIndex[1]    = subfaceIndexCurrent[1] % 3;
    subfaceIndexCurrent[0] = (subfaceIndexCurrent[0] - subintervalIndex[0])/3;
    subfaceIndexCurrent[1] = (subfaceIndexCurrent[1] - subintervalIndex[1])/3;
    assertion(subintervalIndex[0] < 3);
    assertion(subintervalIndex[1] < 3);

    // Zero the values of of the first pair of pointers.
    std::fill_n(pointerQhbnd1, {{nDof*nDof3D*nDataPad}}, 0.0);
    std::fill_n(pointerFhbnd1, {{nDof*nDof3D*nVarPad }}, 0.0);

    // Apply the single level restriction operator.
    // Use the fine level unknowns as input in the first iteration.
    if (l==1) {
      singleLevelFaceUnknownsRestriction<{{nDataPad}}>(pointerQhbnd1, lQhbndFine, subintervalIndex);
      singleLevelFaceUnknownsRestriction<{{nVarPad }}>(pointerFhbnd1, lFhbndFine, subintervalIndex);
    } else {
      singleLevelFaceUnknownsRestriction<{{nDataPad}}>(pointerQhbnd1, pointerQhbnd2, subintervalIndex);
      singleLevelFaceUnknownsRestriction<{{nVarPad }}>(pointerFhbnd1, pointerFhbnd2, subintervalIndex);
    }

    // Prepare next iteration.
    pointerQhbnd2 = pointerQhbnd1;
    pointerFhbnd2 = pointerFhbnd1;
    // Toggle pointer pairs.
    if (pointerQhbnd1 == lQhbndCoarseTemp1) {
      pointerQhbnd1 = lQhbndCoarseTemp2;
      pointerFhbnd1 = lFhbndCoarseTemp2;
    } else {
      pointerQhbnd1 = lQhbndCoarseTemp1;
      pointerFhbnd1 = lFhbndCoarseTemp1;
    }
  }

  // Add restricted fine level unknowns to coarse level unknowns.
  for (int i = 0; i < {{nDof*nDof3D*nDataPad}}; ++i) {
    lQhbndCoarse[i] += pointerQhbnd2[i];
  }
  for (int i = 0; i < {{nDof*nDof3D*nVarPad }}; ++i) {
    lFhbndCoarse[i] += pointerFhbnd2[i];
  }
}


void {{codeNamespace}}::volumeUnknownsProlongation(
    double* luhFine,
    const double* luhCoarse,
    const int coarseGridLevel,
    const int fineGridLevel,
    const tarch::la::Vector<DIMENSIONS, int>& subcellIndex
){
  const int levelDelta = fineGridLevel - coarseGridLevel;

  double luhFineTemp[{{nDof*nDof*nDof3D*nData}}];

  double * pointerUh1 = 0;
  double * pointerUh2 = 0;

  // This ensures that the first pointer 
  // points to luhFine in the last iteration
  // of the following loop.
  if (levelDelta % 2 == 0) {
    pointerUh1 = luhFineTemp;
  } else {
    pointerUh1 = luhFine;
  }

  tarch::la::Vector<DIMENSIONS,int> subcellIndexPrevious (subcellIndex);
  tarch::la::Vector<DIMENSIONS,int> subcellIndexCurrent;

  tarch::la::Vector<DIMENSIONS,int> subintervalIndex;
  // This loop step by step decodes the elements of subcellIndex into a tertiary basis
  // starting with the highest significance 3^(levelDelta-1).
  // 
  // Per iteration, the digits corresponding to the current significances then determine
  // the subintervals for the single level prolongation.
  for (int l = 1; l < levelDelta+1; ++l) {
    const int significance = tarch::la::aPowI(levelDelta-l,3);
    subcellIndexCurrent[0] = subcellIndexPrevious[0] % significance;
    subcellIndexCurrent[1] = subcellIndexPrevious[1] % significance;
    subcellIndexCurrent[2] = subcellIndexPrevious[2] % significance;
    subintervalIndex[0]    = (subcellIndexPrevious[0] - subcellIndexCurrent[0])/significance;
    subintervalIndex[1]    = (subcellIndexPrevious[1] - subcellIndexCurrent[1])/significance;
    subintervalIndex[2]    = (subcellIndexPrevious[2] - subcellIndexCurrent[2])/significance;
    assertion(subintervalIndex[0] < 3);
    assertion(subintervalIndex[1] < 3);
    assertion(subintervalIndex[2] < 3);

    // Zero the values of the first pointer.
    std::fill_n(pointerUh1, {{nDof*nDof*nDof3D*nData}}, 0.0);

    // Apply the single level prolongation operator.
    // Use the coarse level unknowns as input in the first iteration.
    if (l==1) {
      singleLevelVolumeUnknownsProlongation<{{nData}}>(pointerUh1, luhCoarse, subintervalIndex);
    } else {
      singleLevelVolumeUnknownsProlongation<{{nData}}>(pointerUh1, pointerUh2, subintervalIndex);
    }

    // Prepare next iteration.
    subcellIndexPrevious = subcellIndexCurrent;

    pointerUh2 = pointerUh1;

    // Toggle pointers.
    if (pointerUh1 == luhFineTemp) {
      pointerUh1 = luhFine;
    } else {
      pointerUh1 = luhFineTemp;
    }
  }
}


void {{codeNamespace}}::volumeUnknownsRestriction(
    double* luhCoarse,
    const double* luhFine,
    const int coarseGridLevel,
    const int fineGridLevel,
    const tarch::la::Vector<DIMENSIONS, int>& subcellIndex
) {
  const int levelDelta    = fineGridLevel - coarseGridLevel;

  double luhCoarseTemp1[{{nDof*nDof*nDof3D*nData}}];
  double luhCoarseTemp2[{{nDof*nDof*nDof3D*nData}}];

  double * pointerUh1 = 0;
  double * pointerUh2 = 0;

  pointerUh1 = luhCoarseTemp1;

  tarch::la::Vector<DIMENSIONS,int> subcellIndexCurrent(subcellIndex);

  tarch::la::Vector<DIMENSIONS,int> subintervalIndex;
  // This loop step by step decodes the elements of subcellIndex into a tertiary basis
  // starting with the lowest significance 3^0 (in contrast to the prolongation decoding).
  //
  // Per iteration, the digits corresponding to the current significances then determine
  // the subintervals for the single level restriction.
  for (int l = 1; l < levelDelta+1; ++l) {
    subintervalIndex[0]    = subcellIndexCurrent[0] % 3;
    subintervalIndex[1]    = subcellIndexCurrent[1] % 3;
    subintervalIndex[2]    = subcellIndexCurrent[2] % 3;
    subcellIndexCurrent[0] = (subcellIndexCurrent[0] - subintervalIndex[0])/3;
    subcellIndexCurrent[1] = (subcellIndexCurrent[1] - subintervalIndex[1])/3;
    subcellIndexCurrent[2] = (subcellIndexCurrent[2] - subintervalIndex[2])/3;
    assertion(subintervalIndex[0] < 3);
    assertion(subintervalIndex[1] < 3);
    assertion(subintervalIndex[2] < 3);

    // Zero the values of the first pointer.
    std::fill_n(pointerUh1, {{nDof*nDof*nDof3D*nData}}, 0.0);

    // Apply the single level restriction operator.
    // Use the fine level unknowns as input in the first iteration.
    if (l==1) {
      singleLevelVolumeUnknownsRestriction<{{nData}}>(pointerUh1, luhFine, subintervalIndex);
    } else {
      singleLevelVolumeUnknownsRestriction<{{nData}}>(pointerUh1, pointerUh2, subintervalIndex);
    }

    // Prepare next iteration.
    pointerUh2 = pointerUh1;

    // Toggle the addresses of the pointers.
    if (pointerUh1 == luhCoarseTemp1) {
      pointerUh1 = luhCoarseTemp2;
    } else {
      pointerUh1 = luhCoarseTemp1;
    }
  }

  // Add restricted fine level unknowns to coarse level unknowns.
  for (int i = 0; i < {{nDof*nDof*nDof3D*nData}}; ++i) {
    luhCoarse[i] += pointerUh2[i];
  }
}