{# /**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/ #}

#ifndef _EXAHYPE_{{guardNamespace}}_KERNELS_H_
#define _EXAHYPE_{{guardNamespace}}_KERNELS_H_

#include "tarch/la/Vector.h"
#include "peano/utils/Globals.h"


{% if useDeepProfiler %}
#include "exahype/profilers/Profiler.h"
{% endif %}

#ifndef __INTEL_COMPILER
#include <mm_malloc.h>
#endif
#include <vector>

//forward declaration of the user solver
namespace {{solverNamespace}} {
  class {{solverClass}};
}

{% if useLimiter %}
//forward declaration of the ADERDGSolver for limiter functions
namespace exahype {
namespace solvers {
 class ADERDGSolver;
}
}
{% endif %}


#define NDEBUG
{% for namespaceName in codeNamespaceList %}
namespace {{namespaceName}} {
{% endfor %}
{% if isLinear %}
  int fusedSpaceTimePredictorVolumeIntegral(
    {{solverName}}& solver,
    double* restrict lduh,
    double* restrict lQhbnd, 
    double* restrict lFhbnd,
    double* restrict lQi,
    double* restrict lFi,
    double* restrict lSi,   // for NCP or Source
    double* restrict lQhi,
    double* restrict lFhi,
    double* restrict lShi,  // for NCP or Source
    double* restrict gradQ, // for NCP or Source
    double* restrict PSi,   // for pointSource
    double* restrict PSderivatives, // for pointSource
    const double* const restrict luh,
    const tarch::la::Vector<DIMENSIONS, double>& center,
    const double dx, // Assume dx[0] == dx[1] == dx[2]
    const double tStep, // == t
    const double dt,
    std::vector<int>* pointSources // will be deleted in the end if set
  );
{% if usePointSources %}
int fusedSpaceTimePredictorVolumeIntegral_WithoutPS(
    {{solverName}}& solver,
    double* restrict lduh,
    double* restrict lQhbnd, 
    double* restrict lFhbnd,
    double* restrict lQi,
    double* restrict lFi,
    double* restrict lSi,   // for NCP or Source
    double* restrict lQhi,
    double* restrict lFhi,
    double* restrict lShi,  // for NCP or Source
    double* restrict gradQ, // for NCP or Source
    double* restrict PSi,   // for pointSource
    double* restrict PSderivatives, // for pointSource
    const double* const restrict luh,
    const tarch::la::Vector<DIMENSIONS, double>& center,
    const double dx, // Assume dx[0] == dx[1] == dx[2]
    const double tStep, // == t
    const double dt,
    std::vector<int>* pointSources // will be deleted in the end if set
  );
{% endif %}  
{% else %}
  int fusedSpaceTimePredictorVolumeIntegral(
    {{solverName}}& solver,
    double* restrict lduh,
    double* restrict lQhbnd, 
    double* restrict lFhbnd,
    double* restrict lQi,
    double* restrict rhs,
    double* restrict lFi,
    double* restrict lSi,   // for NCP or Source
    double* restrict lQhi,
    double* restrict lFhi,
    double* restrict lShi,  // for NCP or Source
    double* restrict gradQ, // for NCP or Source
    const double* const restrict luh,
    const tarch::la::Vector<DIMENSIONS, double>& inverseDx,
    const double dt
  );
{% endif %}

  void solutionUpdate( 
    double* restrict luh, 
    const double* restrict const lduh, 
    const double dt
  );
  
  void surfaceIntegral( 
    double* restrict lduh, 
    const double* restrict const lFhbnd, 
    const tarch::la::Vector<DIMENSIONS,double> &inverseDx
  );

  void solutionAdjustment(
    {{solverName}}& solver,
    double* luh,
    const tarch::la::Vector<DIMENSIONS,double>& center,
    const tarch::la::Vector<DIMENSIONS,double>& dx,
    const double t,
    const double dt
  );

  void riemannSolver( 
    {{solverName}}& solver,
    double* restrict FL,
    double* restrict FR,
    const double* restrict const QL,
    const double* restrict const QR,
    const double dt,
    const int direction
{% if useDeepProfiler %}
    , exahype::profilers::Profiler* profiler
{% endif %}
  );

  double stableTimeStepSize(
    {{solverName}}& solver,
    const double* restrict const luh,
    const tarch::la::Vector<DIMENSIONS,double>& inverseDx
  );

  void boundaryConditions(
    {{solverName}}& solver,
    double* fluxOut, 
    double* stateOut, 
    const double* const fluxIn, 
    const double* const stateIn, 
    const tarch::la::Vector<DIMENSIONS, double>& cellCentre, 
    const tarch::la::Vector<DIMENSIONS,double>& cellSize, 
    const double t,const double dt, 
    const int faceIndex, 
    const int normalNonZero 
  );

{% if usePointSources %}
  std::vector<int>* getPointSources(
    {{solverName}}& solver,
    const tarch::la::Vector<DIMENSIONS, double>& center,
    const tarch::la::Vector<DIMENSIONS, double>& dx
  );
  
  void deltaDistribution(
    {{solverName}}& solver,
    const double* const restrict luh,
    const double t,
    const double dt,
    const tarch::la::Vector<DIMENSIONS, double>& center,
    const tarch::la::Vector<DIMENSIONS, double>& dx,
    std::vector<int>* pointSources, // will be deleted in the end
    double* restrict PSi
  );
{% endif %}
  
//AMR Routines
//------------

  void faceUnknownsProlongation(
    double* restrict lQhbndFine,
    double* restrict lFhbndFine,
    const double* restrict lQhbndCoarse,
    const double* restrict lFhbndCoarse,
    const int coarseGridLevel,
    const int fineGridLevel,
    const tarch::la::Vector<DIMENSIONS-1, int>& subfaceIndex
  );

  void faceUnknownsRestriction(
    double* restrict lQhbndCoarse,
    double* restrict lFhbndCoarse,
    const double* restrict lQhbndFine,
    const double* restrict lFhbndFine,
    const int coarseGridLevel,
    const int fineGridLevel,
    const tarch::la::Vector<DIMENSIONS-1, int>& subfaceIndex
  );

  void volumeUnknownsProlongation(
    double* restrict luhFine,
    const double* restrict luhCoarse,
    const int coarseGridLevel,
    const int fineGridLevel,
    const tarch::la::Vector<DIMENSIONS, int>& subcellIndex
  );
  
  void volumeUnknownsRestriction(
    double* restrict luhCoarse,
    const double* restrict luhFine,
    const int coarseGridLevel,
    const int fineGridLevel,
    const tarch::la::Vector<DIMENSIONS, int>& subcellIndex
  );

{% if useLimiter %}
//Limiter
//-------

  void projectOnFVLimiterSpace(const double* const luh, double* const lim);

  void projectOnDGSpace(const double* const lim, double* const luh);

  void findCellLocalMinAndMax(
    const double* const luh,
    const exahype::solvers::ADERDGSolver* solver,
    double* const localMinPerVariables, 
    double* const localMaxPerVariable
  );

  void findCellLocalLimiterMinAndMax(
    const double* const lim,
    const exahype::solvers::ADERDGSolver* solver,
    double* const localMinPerObservable, 
    double* const localMaxPerObservable
  );

  bool discreteMaximumPrincipleAndMinAndMaxSearch(
    const double* const luh,
    const exahype::solvers::ADERDGSolver* solver,
    const double relaxationParameter,
    const double differenceScaling,
    double* boundaryMinPerVariables, 
    double* boundaryMaxPerVariables
  );

  //private
  void compareWithADERDGSolutionAtGaussLobattoNodes(
    const double* const luh,
    const exahype::solvers::ADERDGSolver* solver,
    double* min, 
    double* max
  );

  //private
  void compareWithADERDGSolutionAtFVSubcellCenters(
    const double* const luh,
    const exahype::solvers::ADERDGSolver* solver,
    double* min, 
    double* max
  );
{% endif %}
  
{% for namespaceName in codeNamespaceList %}
}
{% endfor %}

#include "{{pathToOptKernel}}/ConfigurationParameters.cpph"
{% if useVectPDEs %}
#include "{{pathToOptKernel}}/matrixUtils.cpph"
{% endif %}

#endif // _EXAHYPE_{{guardNamespace}}_KERNELS_H_
