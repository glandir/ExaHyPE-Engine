/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/

#include <cstring>
#include <algorithm>

#include "{{pathToOptKernel}}/Kernels.h"
#include "{{pathToOptKernel}}/DGMatrices.h"
#include "{{pathToOptKernel}}/Quadrature.h"

{% if useLibxsmm %}
#include "{{pathToOptKernel}}/gemmsCPP.h"
{% endif %}

#include "{{solverHeader}}"

//NOTE JMG lFi/gradQ swap nDim to lowest coordinate


/*
 * For the linear kernels, we need the material parameters in the
 * space-time predictor lQi, time-averaged predictor lQhi,
 * and extrapolated predictor lQhbnd.
 * Currently we simply copy them over from the solution array.
 */
void {{codeNamespace}}::spaceTimePredictorLinear(
    {{solverName}}& solver,
    double* restrict lQhbnd, 
    double* restrict lFhbnd,
    double* restrict lQi,
    double* restrict lFi,
    double* restrict lSi,   // for NCP or Source
    double* restrict lQhi,
    double* restrict lFhi,
    double* restrict lShi,  // for NCP or Source
    double* restrict gradQ, // for NCP or Source
    double* restrict PSi,   // for pointSource
    double* restrict PSderivatives, // for pointSource
    const double* const restrict luh,
    const tarch::la::Vector<DIMENSIONS, double>& inverseDx,
    const double dt
) {
  
  // Define constants
  // constexpr int numberOfVariables  = SolverType::NumberOfVariables;
  // constexpr int numberOfParameters = SolverType::NumberOfParameters;
  // constexpr int numberOfData       = numberOfVariables+numberOfParameters;
  // constexpr int basisSize          = SolverType::Order+1;
  // constexpr int basisSize2         = basisSize * basisSize;
  // constexpr int basisSize3         = basisSize2 * basisSize;
  // constexpr int basisSize4         = basisSize2 * basisSize2;
  // constexpr int order              = basisSize - 1;
  
  //constexpr int sourceIndex = DIMENSIONS;

  const double invDt = 1. / dt;
  
  // Matrices
  
  // double* PSi = tempPointForceSources[0];    // nullptr if bnot usePointSource,  size: basisSize3 * (basisSize + 1) * numberOfVariables
  // idx5 idx_PSi(basisSize + 1, basisSize, basisSize, basisSize, numberOfVariables);
  
  // double* PSderivatives = tempPointForceSources[1]; // nullptr if bnot usePointSource, size: basisSize3 * (basisSize + 1) * numberOfVariables
  // double* tmp_PSderivatives = tempSpaceTimeFluxUnknowns[0]; 
  // idx5 idx_PSderivatives(basisSize, basisSize, basisSize, basisSize, numberOfVariables); //no need for 0th time derivative
  double* tmp_PSderivatives = lFi; // it's actually lFi used here as a temp array //TODO do something cleaner?
  
  // double* lQi = tempSpaceTimeUnknowns[0]; // size: basisSize3 * (basisSize + 1) * numberOfData;
  // idx5 idx_lQi(basisSize + 1, basisSize, basisSize, basisSize, numberOfData);
  // std::fill_n(lQi, basisSize3 * (basisSize + 1) * numberOfData, 0.);
  std::memset(lQi, 0, {{(nDof+1)*(nDof**nDim)*nDataPad}}*sizeof(double));
  
  // double* lFi = tempSpaceTimeFluxUnknowns[0]; // size: basisSize4 * DIMENSIONS+1 * numberOfVariables
  // idx6 idx_lFi(basisSize, basisSize, basisSize, basisSize, DIMENSIONS+1, numberOfVariables);
  // std::fill_n(lFi,basisSize4*(DIMENSIONS+1)*numberOfVariables, 0.);
  std::memset(lFi, 0, {{nDim*nDof*(nDof**nDim)*nVarPad}}*sizeof(double));
  
  // double* gradQ = tempSpaceTimeFluxUnknowns[1]; //  nullptr if not useNCP, size: basisSize4 * DIMENSIONS * numberOfVariables
  // idx6 idx_gradQ(basisSize, basisSize, basisSize, basisSize, DIMENSIONS, numberOfVariables);
  
{% if useNCP %}
  std::memset(gradQ, 0, {{nDim*nDof*(nDof**nDim)*nVarPad}}*sizeof(double));
  std::memset(lSi  , 0, {{nDof*(nDof**nDim)*nVarPad}}*sizeof(double));
{% endif %}

  //idx4 idx_luh(basisSize, basisSize, basisSize, numberOfData);
 
  // local tmp array
  double fluxDerivative[{{nDof*nVarPad}}] __attribute__((aligned(ALIGNMENT))); 
  //idx2 idx_fluxDerivative(basisSize, numberOfVariables);
  
  double ncpResult[{{nVar*nDim}}] __attribute__((aligned(ALIGNMENT))); 
  //idx2 idx_ncpResult(DIMENSIONS, numberOfVariables);
  double gradQNoPad[{{nVar*nDim}}] __attribute__((aligned(ALIGNMENT))); 
  
  //***************************
  //**** Cauchy-Kovalewski ****
  //***************************
  
  
  // 1. Initialize time derivative
  // The zeroth time derivative (time dof number 1) is the initial condition
  for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
    std::copy_n(luh+xyz*{{nData}}, {{nData}}, lQi+xyz*{{nDataPad}});
  }
   
  //2. Add point source (if required) to the zeroth time derivative 
{% if usePointSources %}
  for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
    for (int n = 0; n < {{nDof}}; n++) {  
      #pragma simd
      for (int m = 0; m < {{nVar}}; m++) { //skip parameters
        lQi[xyz*{{nDataPad}}+m] += dt*weights1[n]*PSi[((n+1)*{{nDof**nDim}}+xyz)*{{nVarPad}}+m];
      }
    }
  }

  // copy the source vector at the quadrature nodes  into the temporary array PSderivatives (remove 0th time derivative)
  std::copy_n(PSi+{{(nDof**nDim)*nVarPad}}, {{(nDof**nDim)*nDof*nVarPad}}, PSderivatives);

  // Add point source to the first time derivative
  for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
    #pragma simd
    for (int n = 0; n < {{nVarPad}}; n++) { //skip parameters, var padding should be zero
      lQi[{{(nDof**nDim)*nDataPad}}+(xyz*{{nDataPad}}+n)] += PSi[xyz*{{nVarPad}}+n];
    }
  }

  for (int i = 2; i < {{nDof}}; i++) {
    std::memset(tmp_PSderivatives, 0, {{nDof*(nDof**nDim)*nVarPad}}*sizeof(double));
    // compute (t+1)-th derivative in time of point source
    for(int t = 0; t < {{nDof}}; t++ ){
     for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
        for (int s = 0; s < {{nDof}}; s++) {
          #pragma simd
          for (int n = 0; n < {{nVarPad}}; n++) {
            tmp_PSderivatives[(t*{{nDof**nDim}}+xyz)*{{nVarPad}}+n] += PSderivatives[(s*{{nDof**nDim}}+xyz)*{{nVarPad}}+n] * dudx[t*{{nDofPad}}+s] * invDt;
          }
        }
      } 
    }

    // project derivative on to t_n
    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      for (int t = 0; t < {{nDof}}; t++) {
        #pragma simd
        for (int n = 0; n < {{nVarPad}}; n++) { //0 on the padding
          lQi[(i*{{nDof**nDim}}+xyz)*{{nDataPad}}+n] += tmp_PSderivatives[(t*{{nDof**nDim}}+xyz)*{{nVarPad}}+n]*FLCoeff[t];
        }
      }
    }

    // store (t+1)-th derivative in PSderivatives
    std::copy_n(tmp_PSderivatives, {{(nDof**nDim)*nDof*nVarPad}}, PSderivatives); 
    
  } // i
  std::memset(tmp_PSderivatives, 0, {{nDof*(nDof**nDim)*nVarPad}}*sizeof(double)); //Since we actually use lFi, TODO remove when clean solution   
{% endif %}
    
  // 3. Cauchy-Kovalewski procedure
  for (int i = 0; i < {{nDof}}; i++) {  // time DOFs

{% if useFlux %}
    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      double* F[{{nDim}}];    
      F[0] = &lFi[(i*{{nDof**nDim}}+xyz)*{{nVarPad}}];
      F[1] = &lFi[(i*{{nDof**nDim}}+xyz)*{{nVarPad}}+{{1*(nDof**nDim)*nDof*nVarPad}}];
{% if nDim == 3 %}
      F[2] = &lFi[(i*{{nDof**nDim}}+xyz)*{{nVarPad}}+{{2*(nDof**nDim)*nDof*nVarPad}}];
{% endif %}
      solver.{{solverName}}::flux(&lQi[(i*{{nDof**nDim}}+xyz)*{{nDataPad}}], F);
    }

    //dflux1 dx
    for (int yz = 0; yz < {{nDof3D*nDof}}; yz++) {
      std::memset(fluxDerivative, 0, {{nDof*nVarPad}}*sizeof(double));
      for (int l = 0; l < {{nDof}}; l++) { // TODO use Libxsmm
        for (int n = 0; n < {{nVar}}; n++) {
          for (int x = 0; x < {{nDof}}; x++) {
            fluxDerivative[l*{{nVarPad}}+n] += lFi[((i*{{nDof3D*nDof}}+yz)*{{nDof}}+x)*{{nVarPad}}+n] * dudx[l*{{nDofPad}}+x] * inverseDx[0] ;
          }
        }
      }
      std::copy_n(fluxDerivative, {{nDof*nVarPad}}, lFi+(i*{{nDof3D*nDof}}+yz)*{{nDof*nVarPad}}); 
      // for (int l = 0; l < basisSize; l++) {
        // for (int n = 0; n < numberOfVariables; n++) {
          // lFi[idx_lFi(0, i, yz, l, n)] = fluxDerivative[l*{{nVarPad}}+n];
        // }
      // }
    }

    //dflux2 dy
    for (int z = 0; z < {{nDof3D}}; z++) {
      for (int x = 0; x < {{nDof}}; x++) {
        std::memset(fluxDerivative, 0, {{nDof*nVarPad}}*sizeof(double));
        for (int l = 0; l < {{nDof}}; l++) { // TODO use Libxsmm
          for (int n = 0; n < {{nVar}}; n++) {
            for (int y = 0; y < {{nDof}}; y++) {
              fluxDerivative[l*{{nVarPad}}+n] += lFi[(((i*{{nDof3D}}+z)*{{nDof}}+y)*{{nDof}}+x)*{{nVarPad}}+n +{{1*(nDof**nDim)*nDof*nVarPad}}]*
              dudx[l*{{nDofPad}}+y] * inverseDx[1] ;
              
            }
          }
        }
        for (int l = 0; l < {{nDof}}; l++) {
          #pragma simd
          for (int n = 0; n < {{nVarPad}}; n++) {
            lFi[(((i*{{nDof3D}}+z)*{{nDof}}+l)*{{nDof}}+x)*{{nVarPad}}+n +{{1*(nDof**nDim)*nDof*nVarPad}}] = fluxDerivative[l*{{nVarPad}}+n];
          }
        }
      }
    }
{% if nDim ==3 %}

    //dflux3 dz
    for (int xy = 0; xy < {{nDof*nDof}}; xy++) {
      std::memset(fluxDerivative, 0, {{nDof*nVarPad}}*sizeof(double));
      for (int l = 0; l < basisSize; l++) { // TODO use Libxsmm
        for (int n = 0; n < numberOfVariables; n++) {
          for (int z = 0; z < basisSize; z++) {
            fluxDerivative[l*{{nVarPad}}+n] += lFi[((i*{{nDof3D}}+z)*{{nDof*nDof}}+xy)*{{nVarPad}}+n +{{2*(nDof**nDim)*nDof*nVarPad}}]*
             dudx[l*{{nDofPad}}+z] * inverseDx[2] ; 
          }
        }
      }
      for (int l = 0; l < {{nDof}}; l++) {
        #pragma simd
        for (int n = 0; n < {{nVarPad}}; n++) {
          lFi[(i*{{nDof3D}}+l)*{{nDof*nDof}}+xy)*{{nVarPad}}+n +{{2*(nDof**nDim)*nDof*nVarPad}}] =  fluxDerivative[l*{{nVarPad}}+n];
        }
      }
    }
{% endif %}

{% endif %} {# useFlux #}
{% if useNCP %}
    // Compute the derivatives in x direction (independent from the y and z derivatives)
    for (int yz = 0; yz < {{nDof*nDof3D}}; yz++) {
      for (int x = 0; x < {{nDof}}; x++) { // TODO use Libxsmm
        for (int n = 0; n < {{nVar}}; n++) { // Skip parameters
          for (int l = 0; l < {{nDof}}; l++) {
            gradQ[((i*{{nDof*nDof3D}}+yz)*{{nDof}}+x)*{{nVarPad}}+n] += lQi[((i*{{nDof*nDof3D}}+yz)*{{nDof}}+l)*{{nDataPad}}+n] * dudx[x*{{nDofPad}}+l] * inverseDx[0];
          }
        }
      }
    }

    // y direction (independent from the x and z derivatives)
    for (int z = 0; z < {{nDof3D}}; z++) {
      for (int x = 0; x < {{nDof}}; x++) {
        for (int y = 0; y < {{nDof}}; y++) { //TODO use Libxsmm
          for (int n = 0; n < {{nVar}}; n++) { // Skip parameters
            for (int l = 0; l < {{nDof}}; l++) {
              gradQ[(((i*{{nDof3D}}+z)*{{nDof}}+y)*{{nDof}}+x)*{{nVarPad}}+n +{{1*(nDof**nDim)*nDof*nVarPad}}] += lQi[(((i*{{nDof3D}}+z)*{{nDof}}+l)*{{nDof}}+x)*{{nDataPad}}+n] * dudx[y*{{nDofPad}}+l] * inverseDx[1];
            }
          }
        }
      }
    }
{% if nDim ==3 %}

    // z direction (independent from the x and y derivatives)
    for (int xy = 0; xy < {{nDof*nDof}}; xy++) {
      for (int z = 0; z < {{nDof}}; z++) {     
        for (int n = 0; n < {{nVar}}; n++) {// Skip parameters
          for (int l = 0; l < {{nDof}}; l++) {
            gradQ[((i*{{nDof3D}}+z)*{{nDof*nDof}}+xy)*{{nVarPad}}+n +{{2*(nDof**nDim)*nDof*nVarPad}})] += lQi[((i*{{nDof3D}}+l)*{{nDof*nDof}}+xy)*{{nDataPad}}+n] * dudx[z*{{nDofPad}}+l] * inverseDx[2];
          }
        }
      }
    }
{% endif %}
  
    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      std::memset(ncpResult, 0, {{nDim*nVarPad}}*sizeof(double)); // zero out ncpResult
      std::copy_n(gradQ+(i*{{nDof**nDim}}+xyz)*{{nVarPad}}, {{nVar}}, gradQNoPad); //x
      std::copy_n(gradQ+(i*{{nDof**nDim}}+xyz)*{{nVarPad}}+{{1*(nDof**nDim)*nDof*nVarPad}}, {{nVar}}, gradQNoPad+{{1*nVar}}); //y
{% if nDim==3 %}
      std::copy_n(gradQ+(i*{{nDof**nDim}}+xyz)*{{nVarPad}}+{{2*(nDof**nDim)*nDof*nVarPad}}, {{nVar}}, gradQNoPad+{{2*nVar}}); //z
{% endif %}
      solver.{{solverName}}::nonConservativeProduct(&lQi[(i*{{nDof**nDim}}+xyz)*{{nDataPad}}], &gradQNoPad[0], &ncpResult[0]);
      for(int d = 0; d < {{nDim}}; d++) {
        #pragma simd
        for (int n = 0; n < {{nVar}}; n++) {
          lFi[((d*{{nDof}}+i)*{{nDof**nDim}}+xyz)*{{nVarPad}}+n] += ncpResult[d*{{nVar}}+n];
        }
      }
    }
{% endif %} {# useNCP #}
  
{% if useMaterialParam %}
    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      double* F[{{nDim}}];    
      F[0] = &lFi[(i*{{nDof**nDim}}+xyz)*{{nVarPad}}];
      F[1] = &lFi[(i*{{nDof**nDim}}+xyz)*{{nVarPad}}+{{1*(nDof**nDim)*nDof*nVarPad}}];
{% if nDim == 3 %}
      F[2] = &lFi[(i*{{nDof**nDim}}+xyz)*{{nVarPad}}+{{2*(nDof**nDim)*nDof*nVarPad}}];
{% endif %}
      solver.{{solverName}}::multiplyMaterialParameterMatrix(&lQi[(i*{{nDof**nDim}}+xyz)*{{nDataPad}}], &F[0]);
    }
{% endif %} {# useMaterialParam #}

{% if useSource %}
    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      solver.{{solverName}}::algebraicSource(&lQi[(i*{{nDof**nDim}}+xyz)*{{nDataPad}}], &lSi[(i*{{nDof**nDim}}+xyz)*{{nVarPad}}]);
    }
{% endif %} {# useSource #}

    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      #pragma simd
      for (int n = 0; n < {{nVar}}; n++) { // Skip parameters
        lQi[((i+1)*{{nDof**nDim}}+xyz)*{{nDataPad}}+n] -= lFi[(i*{{nDof**nDim}}+xyz)*{{nVarPad}}+n];
        lQi[((i+1)*{{nDof**nDim}}+xyz)*{{nDataPad}}+n] -= lFi[(i*{{nDof**nDim}}+xyz)*{{nVarPad}}+n+{{1*(nDof**nDim)*nDof*nVarPad}}];
{% if nDim==3 %}
        lQi[((i+1)*{{nDof**nDim}}+xyz)*{{nDataPad}}+n] -= lFi[(i*{{nDof**nDim}}+xyz)*{{nVarPad}}+n+{{2*(nDof**nDim)*nDof*nVarPad}}];
{% endif %}
{% if useSource %}
        lQi[((i+1)*{{nDof**nDim}}+xyz)*{{nDataPad}}+n] -= lSi[(i*{{nDof**nDim}}+xyz)*{{nVarPad}}+n];
{% endif %}
      }
    }

{% if nPar > 0 %}
    // Copy parameters
    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      std::copy_n(lQi+(i*{{nDof**nDim}}+xyz)*{{nDataPad}}+{{nVar}}, {{nPar}}, lQi+((i+1)*{{nDof**nDim}}+xyz)*{{nDataPad}}+{{nVar}});
    }
{% endif %}
    
  } //i

  //*****************************
  //**** Averaging over time ****
  //*****************************
  
  //double* lQhi = tempUnknowns;
  //idx4 idx_lQhi(basisSize, basisSize, basisSize, numberOfData);
  
  //double* lFhi = tempFluxUnknowns;
  //idx5 idx_lFhi(DIMENSIONS+1, basisSize, basisSize, basisSize, numberOfVariables);

  // Immediately compute the time-averaged space-time polynomials
  // Fortran: lQhi(:,:,:,:) = lQi(:,:,:,:,1)
  std::copy_n(lQi, {{(nDof**nDim)*nDataPad}}, lQhi); 

  double dtavFac = 0.5 * dt;
  for (int i = 1; i < {{nDof}}; i++) {
    // Fortran: lQhi(:,:,:,:) += dtavFac * lQi(:,i,:,:,:)
    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      for (int n = 0; n < {{nVar}}; n++) { // skip parameters
        lQhi[xyz*{{nDataPad}}+n] += dtavFac * lQi[(i*{{nDof**nDim}}+xyz)*{{nDataPad}}+n];
      }
    }
    dtavFac *= dt / (i + 2);
  }

 
  // lFhi(m,l,k,j,i) = lFi(m,i,l,k,j,1)
  // for (int i = 0; i < DIMENSIONS; i++) {
    // for (int j = 0; j < basisSize; j++) {
      // for (int k = 0; k < basisSize; k++) {
        // for (int l = 0; l < basisSize; l++) {
          // for (int m = 0; m < numberOfVariables; m++) {
            // lFhi[idx_lFhi(i, j, k, l, m)] = lFi[idx_lFi(0, j, k, l, i, m)];
          // }
        // }
      // }
    // }
  // }  
  std::copy_n(lFi, {{(nDof**nDim)*nVarPad}}, lFhi); //x
  std::copy_n(lFi+{{1*nDof*(nDof**nDim)*nVarPad}}, {{(nDof**nDim)*nVarPad}}, lFhi+{{1*(nDof**nDim)*nVarPad}}); //y
{% if nDim==3 %}
  std::copy_n(lFi+{{2*nDof*(nDof**nDim)*nVarPad}}, {{(nDof**nDim)*nVarPad}}, lFhi+{{2*(nDof**nDim)*nVarPad}}); //z
{% endif %}

  // if(useSource){
    // for (int j = 0; j < basisSize; j++) {
      // for (int k = 0; k < basisSize; k++) {
        // for (int l = 0; l < basisSize; l++) {
          // for (int m = 0; m < numberOfVariables; m++) {
            // lFhi[idx_lFhi(sourceIndex, j, k, l, m)] = lFi[idx_lFi(0, j, k, l, sourceIndex, m)];
          // }
        // }
      // }
    // }
  // }
{% if useSource %}
  std::copy_n(lSi, {{(nDof**nDim)*nVarPad}}, lShi); //source
{% endif %}

  dtavFac = 0.5 * dt;
  for (int i = 1; i < {{nDof}}; i++) {
    // Fortran: lFhi(n,m,l,k,j) += dtavFac*lFi(n,j,m,l,k,i)
    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      #pragma simd
      for (int n = 0; n < {{nVarPad}}; n++) {
        lFhi[xyz*{{nVarPad}}+n] += dtavFac * lFi[(i*{{nDof**nDim}}+xyz)*{{nDataPad}}+n]; //x
        lFhi[xyz*{{nVarPad}}+n+{{1*(nDof**nDim)*nVarPad}}] += dtavFac * lFi[(i*{{nDof**nDim}}+xyz)*{{nDataPad}}+n+{{1*nDof*(nDof**nDim)*nVarPad}}]; //y
{% if nDim==3 %}
        lFhi[xyz*{{nVarPad}}+n+{{2*(nDof**nDim)*nVarPad}}] += dtavFac * lFi[(i*{{nDof**nDim}}+xyz)*{{nDataPad}}+n+{{2*nDof*(nDof**nDim)*nVarPad}}]; //z
{% endif %}
{% if useSource %}
        lShi[xyz*{{nVarPad}}+n] += dtavFac * lSi[(i*{{nDof**nDim}}+xyz)*{{nDataPad}}+n]; //source
{% endif %}
      }
    }

    // if(useSource){
      // for (int k = 0; k < basisSize; k++) {
        // for (int l = 0; l < basisSize; l++) {
          // for (int m = 0; m < basisSize; m++) {
            // for (int n = 0; n < numberOfVariables; n++) {
              // lFhi[idx_lFhi(sourceIndex, k, l, m, n)] += dtavFac * lFi[idx_lFi(i, k, l, m, sourceIndex, n)];
            // }
          // }
        // }
      // }
    // }
    
    dtavFac *= dt / (i + 2);
  }

  // Add point source to the right hand side
{% if usePointSources %}
  for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
    for (int n = 0; n < {{nVar}}; n++) {
      double sum = 0.0;
      for (int n0 = 1; n0 < {{nDof+1}}; n0++) {    
        sum += weights1[n0-1]*PSi[(n0*{{nDof**nDim}}+xyz)*{{nVarPad}}+n];
      }
      lFhi[xyz*{{nVarPad}}+n] += sum/{{nDim}}; //x
      lFhi[xyz*{{nVarPad}}+n+{{1*(nDof**nDim)*nVarPad}}] += sum/{{nDim}}; //y
{% if nDim==3 %}
      lFhi[xyz*{{nVarPad}}+n+{{2*(nDof**nDim)*nVarPad}}] += sum/{{nDim}}; //z
{% endif %}
    }
  }
{% endif %}

  //***********************
  //**** Extrapolation ****
  //***********************
  
  //idx4 idx_lQhbnd(2 * DIMENSIONS, basisSize, basisSize, numberOfData);
  std::memset(lQhbnd, 0, {{2*nDim*nDof*nDof3D*nDataPad}}*sizeof(double));

  //idx4 idx_lFhbnd(2 * DIMENSIONS, basisSize, basisSize, numberOfVariables);
  std::memset(lFhbnd, 0, {{2*nDim*nDof*nDof3D*nVarPad}}*sizeof(double));

  // x-direction: face 1 (left) and face 2 (right)
  for (int yz = 0; yz < {{nDof*nDof3D}}; yz++) {
    for (int x = 0; x < {{nDof}}; x++) {
      #pragma simd
      for (int n = 0; n < {{nDataPad}}; n++) {
        // left
        lQhbnd[yz*{{nDataPad}}+n] += lQhi[(yz*{{nDof}}+x)*{{nDataPad}}+n] * FLCoeff[x];
        // right
        lQhbnd[yz*{{nDataPad}}+n+{{1*nDof*nDof3D*nDataPad}}] += lQhi[(yz*{{nDof}}+x)*{{nDataPad}}+n] * FRCoeff[x];
        }
      }
    for (int x = 0; x < {{nDof}}; x++) {
      #pragma simd
      for (int n = 0; n < {{nVarPad}}; n++) {
        // left
        lFhbnd[yz*{{nVarPad}}+n] += lFhi[(yz*{{nDof}}+x)*{{nVarPad}}+n] * FLCoeff[x];
        // right
        lFhbnd[yz*{{nVarPad}}+n+{{1*nDof*nDof3D*nVarPad}}] += lFhi[(yz*{{nDof}}+x)*{{nVarPad}}+n] * FRCoeff[x];
      }
    }
  }


  // y-direction: face 3 (left) and face 4 (right)
  for (int z = 0; z < {{nDof3D}}; z++) {
    for (int x = 0; x < {{nDof}}; x++) {
      // lQhbnd(:,j,i,3) = lQhi(:,j,:,i) * FLCoeff(:)
      // lQhbnd(:,j,i,4) = lQhi(:,j,:,i) * FRCoeff(:)
      for (int y = 0; y < {{nDof}}; y++) {
        #pragma simd
        for (int n = 0; n < {{nDataPad}}; n++) {
          // left
          lQhbnd[(z*{{nDof3D}}+x)*{{nDataPad}}+n+{{2*nDof*nDof3D*nDataPad}}] += lQhi[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nDataPad}}+n] * FLCoeff[y];
          // right
          lQhbnd[(z*{{nDof3D}}+x)*{{nDataPad}}+n+{{3*nDof*nDof3D*nDataPad}}] += lQhi[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nDataPad}}+n] * FRCoeff[y];
        }
      }
      // lFhbnd(:,j,i,3) = lFhi(:,j,:,i,2) * FLCoeff(:)
      // lFhbnd(:,j,i,4) = lFhi(:,j,:,i,2) * FRCoeff(:)
      for (int y = 0; y < {{nDof}}; y++) {
        #pragma simd
        for (int n = 0; n < {{nVarPad}}; n++) {
          // left
          lFhbnd[(z*{{nDof3D}}+x)*{{nVarPad}}+n+{{2*nDof*nDof3D*nVarPad}}] += lFhi[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nVarPad}}+n+{{1*(nDof**nDim)*nVarPad}}] * FLCoeff[y];
          // right
          lFhbnd[(z*{{nDof3D}}+x)*{{nVarPad}}+n+{{3*nDof*nDof3D*nVarPad}}] += lFhi[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nVarPad}}+n+{{1*(nDof**nDim)*nVarPad}}] * FRCoeff[y];
        }
      }
    }
  }
{% if nDim==3 %}

  // z-direction: face 5 (left) and face 6 (right)
  for (int xy = 0; xy < {{nDof*nDof3D}}; xy++) {
    // lQhbnd(:,j,i,5) = lQhi(:,j,i,:) * FLCoeff(:)
    // lQhbnd(:,j,i,6) = lQhi(:,j,i,:) * FRCoeff(:)
    for (int z = 0; z < {{nDof}}; z++) {
      for (int n = 0; n <{{nDataPad}}; n++) {
        // left
        lQhbnd[xy*{{nDataPad}}+n+{{4*nDof*nDof3D*nDataPad}}] += lQhi[(z*{{nDof*nDof}}+xy)*{{nDataPad}}+n] * FLCoeff[z];
        // right
        lQhbnd[xy*{{nDataPad}}+n+{{5*nDof*nDof3D*nDataPad}}] += lQhi[(z*{{nDof*nDof}}+xy)*{{nDataPad}}+n] * FRCoeff[z];
      }
    }
    // lFhbnd(:,j,i,5) = lFhi(:,j,i,:,3) * FLCoeff(:)
    // lFhbnd(:,j,i,6) = lFhi(:,j,i,:,3) * FRCoeff(:)
    for (int z = 0; z < {{nDof}}; z++) {
      for (int n = 0; n < {{nVarPad}}; n++) {
        // left
        lFhbnd[xy*{{nVarPad}}+n+{{4*nDof*nDof3D*nVarPad}}] += lFhi[(z*{{nDof*nDof}}+xy)*{{nVarPad}}+n+{{2*(nDof**nDim)*nVarPad}}] * FLCoeff[z];
        // right
        lFhbnd[xy*{{nVarPad}}+n+{{5*nDof*nDof3D*nVarPad}}] += lFhi[(z*{{nDof*nDof}}+xy)*{{nVarPad}}+n+{{2*(nDof**nDim)*nVarPad}}] * FRCoeff[z];
      }
    }
  }
{% endif %}
  
} //
