{# /**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/ #}

// Solve the volume integral 

#include <cstring>

#include "kernels/aderdg/optimised/Kernels.h"
#include "kernels/aderdg/optimised/DGMatrices.h"
#include "kernels/aderdg/optimised/GaussLegendreQuadrature.h"

#include "kernels/aderdg/optimised/asm_volumeIntegral.c"

void kernels::aderdg::optimised::volumeIntegral( 
  double* restrict lduh, 
  const double* restrict const lFi,
  const double* restrict const lSi, //nullptr if not used
  const tarch::la::Vector<DIMENSIONS,double> &inverseDx
) {
  memset(lduh, 0, sizeof(lduh)*{{nVar*(nDof**nDim)}});

#ifdef __INTEL_COMPILER
  __assume_aligned(lFi, ALIGNMENT);
  __assume_aligned(Kxi_T, ALIGNMENT);
  __assume_aligned(weights1, ALIGNMENT);
  __assume_aligned(weights2, ALIGNMENT);
  __assume_aligned(lduh, ALIGNMENT); //lduh should be aligned, see Solver.h
{% if useSourceOrNCP %}
  __assume_aligned(lSi, ALIGNMENT);
{% endif %}
#endif

    for (int i = 0; i < {{nDof}}; i++) { // loop over time unknowns
      // x-direction
      for (int j = 0; j < {{nDof3D}}; j++) { // z 
        for (int k = 0; k < {{nDof}}; k++) { // y
          const double weight =
              weights1[i] * // t
{% if nDim == 3 %} 
              weights1[j] * // z
{% endif %}               
              weights1[k];  // y

          const double updateSize = weight * inverseDx[0];
          for (int l = 0; l < {{nDof}}; l++) { // x
            for (int m = 0; m < {{nVar}}; m++) {
              for (int n = 0; n < {{nDof}}; n++) {  
                lduh[m+{{nVar}}*(l+{{nDof}}*(k+{{nDof}}*j))] += 
                    Kxi_T[n+{{nDof}}*l] *
                    lFi[m+{{nVarPad}}*(n+{{nDof}}*(k+{{nDof}}*(j+{{nDof}}*i)))+{{0*(nDof**nDim)*nDof*nVarPad}}] * updateSize;
              }
            }
          }
        }
      }
      // y-direction
      for (int j = 0; j < {{nDof3D}}; j++) { // z
        for (int l = 0; l < {{nDof}}; l++) { // x 
          const double weight =
              weights1[i] * // t
{% if nDim == 3 %} 
              weights1[j] * // z
{% endif %}               
              weights1[l];  // y

          const double updateSize = weight * inverseDx[1];
          for (int k = 0; k < {{nDof}}; k++) { // y
            for (int m = 0; m < {{nVar}}; m++) {
              for (int n = 0; n < {{nDof}}; n++) {  
                lduh[m+{{nVar}}*(l+{{nDof}}*(k+{{nDof}}*j))] += 
                    Kxi_T[n+{{nDof}}*k] *
                    lFi[m+{{nVarPad}}*(l+{{nDof}}*(n+{{nDof}}*(j+{{nDof}}*i)))+{{1*(nDof**nDim)*nDof*nVarPad}}] * updateSize;
              }
            }
          }
        }
      }
{% if nDim == 3 %} 
      // z-direction
      for (int k = 0; k < {{nDof}}; k++) { // y 
        for (int l = 0; l < {{nDof}}; l++) { // x
            const double weight =
              weights1[i] * // t
              weights1[k] * // y
              weights1[l];  // x
          const double updateSize = weight * inverseDx[2];

          for (int j = 0; j < {{nDof}}; j++) { // z
            for (int m = 0; m < {{nVar}}; m++) {
              for (int n = 0; n < {{nDof}}; n++) {  
                lduh[m+{{nVar}}*(l+{{nDof}}*(k+{{nDof}}*j))] += 
                    Kxi_T[n+{{nDof}}*j] *
                    lFi[m+{{nVarPad}}*(l+{{nDof}}*(k+{{nDof}}*(n+{{nDof}}*i)))+{{2*(nDof**nDim)*nDof*nVarPad}}] * updateSize;
              }
            }
          }
        }
      }
{% endif %} 
    }


/*
  double s_m[{{nDof*nDofPad}}] __attribute__((aligned(ALIGNMENT)));  
  double lFhi_loc[{{nDof*nVarPad}}] __attribute__((aligned(ALIGNMENT)));
  // Assume equispaced mesh, dx[0] == dx[1] == dx[2]
{% for j in j_seq %} {# if nDim == 2 then j_seq == [0] #}
{% for i in i_seq %}
  #pragma vector aligned
  for(int it=0;it<{{nDof*nDofPad}};it++) 
    s_m[it] = weights2[{{i+j*nDof}}] * inverseDx[0] * Kxi_T[it];

  //x
  memset(lFhi_loc, 0, sizeof(double)*{{nDof*nVarPad}});
  for(int k=0; k<{{nDof}}; k++) {
    for(int m=0; m<{{nDof}}; m++) {
      #pragma simd
      for(int n=0; n<{{nVarPad}}; n++) {
        lFhi_loc[n+{{nVarPad}}*k] = weights1[m] * lFi[n+{{nVarPad}}*(k+{{nDof}}*({{(i+nDof*j)}}+{{nDof*nDof3D}}*m))];
      }
    }
  }
  #pragma forceinline
  {{gemm_x}}(&lFhi_loc[0],&s_m[0],&lduh[{{(j*nDof+i) * nVar * nDof}}]);
  
  //y
  memset(lFhi_loc, 0, sizeof(double)*{{nDof*nVarPad}});
  for(int k=0; k<{{nDof}}; k++) {
    for(int m=0; m<{{nDof}}; m++) {
      #pragma simd
      for(int n=0; n<{{nVarPad}}; n++) {
         lFhi_loc[n+{{nVarPad}}*k] += weights1[m] * lFi[n+{{nVarPad}}*({{j}}+{{nDof}}*(k+{{nDof}}*({{i}}+{{nDof3D}}*m)))+{{1*(nDof**nDim)*nDof*nVarPad}}];

      }
    }
  }
  #pragma forceinline
  {{gemm_y}}(&lFhi_loc[0],&s_m[0],&lduh[{{(j*nDof*nDof+i) * nVar}}]);
{% if nDim == 3 %} 

  //z
  memset(lFhi_loc, 0, sizeof(double)*{{nDof*nVarPad}});
  for(int k=0; k<{{nDof}}; k++) {
    for(int m=0; m<{{nDof}}; m++) {
      #pragma simd
      for(int n=0; n<{{nVarPad}}; n++) {
        lFhi_loc[n+{{nVarPad}}*k] += weights1[m] * lFi[n+{{nVarPad}}*({{i}}+{{nDof}}*({{j}}+{{nDof}}*(k+{{nDof3D}}*m)))+{{2*(nDof**nDim)*nDof*nVarPad}}];
      }
    }
  }
  #pragma forceinline
  {{gemm_z}}(&lFhi_loc[0],&s_m[0],&lduh[{{(j*nDof+i) * nVar}}]);
{% endif %}  
{% endfor %}
{% endfor %}
*/  
{% if useSourceOrNCP %}
  // source
  for (int ijk = 0; ijk < {{nDof**nDim}}; ijk++) {
    // Fortran: lduh(:,k,j,i) += w * lShi(:,k,j,i)
    for (int m = 0; m < {{nDof}}; m++) {
      #pragma simd
      for (int n = 0; n < {{nVar}}; n++) {
        lduh[n+{{nVar}}*ijk] += weights3[ijk] * weights1[m] * lSi[n+{{nVarPad}}*(ijk+{{nDof**nDim}}*m)]
      }
    }
  }
{% endif %}

}

