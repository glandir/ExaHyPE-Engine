{# /**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/ #}

#include "kernels/aderdg/optimised/converter.h"

void kernels::aderdg::optimised::converter::Bnd_optimised2generic(const double* const opt, double* gen) {
  for(int i=0; i<{{2 * nDim}}; i++) {
    for(int j=0; j<{{nDof**(nDim-1)}}; j++) {
      for(int l=0; l<{{nVar}}; l++) {
        gen[l+{{nVar}}*(j+{{nDof**(nDim-1)}}*i)] = opt[j+{{bndBlockSize}}*(l+{{nVar}}*i)];
      }
    }    
  }
}

void kernels::aderdg::optimised::converter::Bnd_generic2optimised(const double* const gen, double* opt) {
  for(int i=0; i<{{2 * nDim}}; i++) {
    for(int j=0; j<{{nDof**(nDim-1)}}; j++) {
      for(int l=0; l<{{nVar}}; l++) {
        opt[j+{{bndBlockSize}}*(l+{{nVar}}*i)] = gen[l+{{nVar}}*(j+{{nDof**(nDim-1)}}*i)];
      }
    }    
  }
}

void kernels::aderdg::optimised::converter::BndFace_optimised2generic(const double* const opt, double* gen) {
  for(int j=0; j<{{nDof**(nDim-1)}}; j++) {
    for(int l=0; l<{{nVar}}; l++) {
      gen[l+{{nVar}}*j] = opt[j+{{bndBlockSize}}*l];
    }
  }    
}

void kernels::aderdg::optimised::converter::BndFace_generic2optimised(const double* const gen, double* opt) {
  for(int j=0; j<{{nDof**(nDim-1)}}; j++) {
    for(int l=0; l<{{nVar}}; l++) {
      opt[j+{{bndBlockSize}}*l] = gen[l+{{nVar}}*j];
    }
  }    
}

{% if noVarPadding %}
void kernels::aderdg::optimised::converter::Fhi_optimised2generic(const double* const opt, double* gen) {
  const int size = getFhiOptArraySize();
  std::memcpy(gen, opt, size*sizeof(double));
}

void kernels::aderdg::optimised::converter::Fhi_generic2optimised(const double* const gen, double* opt) {
  const int size = getFhiOptArraySize();
  std::memcpy(opt, gen, size*sizeof(double));
}

void kernels::aderdg::optimised::converter::Qhi_optimised2generic(const double* const opt, double* gen) {
  const int size = getQhiOptArraySize();
  std::memcpy(gen, opt, size*sizeof(double));
}

void kernels::aderdg::optimised::converter::Qhi_generic2optimised(const double* const gen, double* opt) {
  const int size = getQhiOptArraySize();
  std::memcpy(opt, gen, size*sizeof(double));
}

{% else %} {# == !noVarPadding , nVar padded to nVarPad #}

void kernels::aderdg::optimised::converter::Fhi_optimised2generic(const double* const opt, double* gen) {
  for(int b=0; b<{{nDim+1}}; b++) {
    for(int j=0; j<{{nDof**nDim}}; j++) {
      #pragma simd
      for(int i=0; i<{{nVar}}; i++) {
        gen[i+{{nVar}}*j+b*{{(nDof ** nDim) * nVar}}] = opt[i+{{nVarPad}}*j+b*{{(nDof ** nDim) * nVarPad}}];
      }
    }
  }
}

void kernels::aderdg::optimised::converter::Fhi_generic2optimised(const double* const gen, double* opt) {
  for(int b=0; b<{{nDim+1}}; b++) {
    for(int j=0; j<{{nDof**nDim}}; j++) {
      #pragma simd
      for(int i=0; i<{{nVar}}; i++) {
        opt[i+{{nVarPad}}*j+b*{{(nDof ** nDim) * nVarPad}}] = gen[i+{{nVar}}*j+b*{{(nDof ** nDim) * nVar}}];
      }
    }
  }
}

void kernels::aderdg::optimised::converter::Qhi_optimised2generic(const double* const opt, double* gen) {
  for(int j=0; j<{{nDof**nDim}}; j++) {
    #pragma simd
    for(int i=0; i<{{nVar}}; i++) {
      gen[i+{{nVar}}*j] = opt[i+{{nVarPad}}*j];
    }
  }
}

void kernels::aderdg::optimised::converter::Qhi_generic2optimised(const double* const gen, double* opt) {
  for(int j=0; j<{{nDof**nDim}}; j++) {
    #pragma simd
    for(int i=0; i<{{nVar}}; i++) {
      opt[i+{{nVarPad}}*j] = gen[i+{{nVar}}*j];
    }
  }
}
{% endif %}