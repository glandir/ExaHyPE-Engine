{# /**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/ #}

#include "kernels/aderdg/optimised/converter.h"

void kernels::aderdg::optimised::converter::Bnd_optimised2generic(const double* const opt, double* gen) {
{% if nDim == 2 %}
  idx3 idx_bnd_gen({{2 * nDim}}, {{nDof}}, {{nVar}});
  idx3 idx_bnd_opt({{2 * nDim}}, {{nVar}}, {{nDofPad}});
  for(int i=0; i<{{2 * nDim}}; i++) {
    for(int j=0; j<{{nDof}}; j++) {
      for(int k=0; k<{{nVar}}; k++) {
        gen[idx_bnd_gen(i,j,k)] = opt[idx_bnd_opt(i,k,j)]; 
      }
    }    
  }
{% else %}
  idx4 idx_bnd_gen({{2 * nDim}}, {{nDof}}, {{nDof}}, {{nVar}});
  for(int i=0; i<{{2 * nDim}}; i++) {
    for(int j=0; j<{{nDof}}; j++) {
      for(int k=0; k<{{nDof}}; k++) {
        for(int l=0; l<{{nVar}}; l++) {
          gen[idx_bnd_gen(i,j,k,l)] = opt[i*{{nVar*bndBlockSize}}+l*{{bndBlockSize}}+j*{{nDof}}+k];
        }
      }
    }    
  }
{% endif%}
}

void kernels::aderdg::optimised::converter::Bnd_generic2optimised(const double* const gen, double* opt) {
{% if nDim == 2 %}
  idx3 idx_bnd_gen({{2 * nDim}}, {{nDof}}, {{nVar}});
  idx3 idx_bnd_opt({{2 * nDim}}, {{nVar}}, {{nDofPad}});
  for(int i=0; i<{{2 * nDim}}; i++) {
    for(int j=0; j<{{nDof}}; j++) {
      for(int k=0; k<{{nVar}}; k++) {
        opt[idx_bnd_opt(i,k,j)] = gen[idx_bnd_gen(i,j,k)]; 
      }
    }    
  }
{% else %}
  idx4 idx_bnd_gen({{2 * nDim}}, {{nDof}}, {{nDof}}, {{nVar}});
  for(int i=0; i<{{2 * nDim}}; i++) {
    for(int j=0; j<{{nDof}}; j++) {
      for(int k=0; k<{{nDof}}; k++) {
        for(int l=0; l<{{nVar}}; l++) {
          opt[i*{{nVar*bndBlockSize}}+l*{{bndBlockSize}}+j*{{nDof}}+k] = gen[idx_bnd_gen(i,j,k,l)];
        }
      }
    }    
  }
{% endif%}
}

{% if noVarPadding %}
void kernels::aderdg::optimised::converter::Fhi_optimised2generic(const double* const opt, double* gen) {
  const int size = getFhiOptArraySize();
  std::memcpy(gen, opt, size*sizeof(double));
}

void kernels::aderdg::optimised::converter::Fhi_generic2optimised(const double* const gen, double* opt) {
  const int size = getFhiOptArraySize();
  std::memcpy(opt, gen, size*sizeof(double));
}

void kernels::aderdg::optimised::converter::Qhi_optimised2generic(const double* const opt, double* gen) {
  const int size = getQhiOptArraySize();
  std::memcpy(gen, opt, size*sizeof(double));
}

void kernels::aderdg::optimised::converter::Qhi_generic2optimised(const double* const gen, double* opt) {
  const int size = getQhiOptArraySize();
  std::memcpy(opt, gen, size*sizeof(double));
}

{% else %} {# == !noVarPadding , nVar padded to nVarPad #}

void kernels::aderdg::optimised::converter::Fhi_optimised2generic(const double* const opt, double* gen) {
  for(int b=0; b<{{nDim+1}}; b++) {
    for(int j=0; j<{{nDof**nDim}}; j++) {
      #pragma simd
      for(int i=0; l<{{nVar}}; l++) {
        gen[i+{{nVar}}*j+b*{{(nDof ** nDim) * nVar}}] = opt[i+{{nVarPad}}*j+b*{{(nDof ** nDim) * nVarPad}}];
      }
    }
  }
}

void kernels::aderdg::optimised::converter::Fhi_generic2optimised(const double* const gen, double* opt) {
  for(int b=0; b<{{nDim+1}}; b++) {
    for(int j=0; j<{{nDof**nDim}}; j++) {
      #pragma simd
      for(int i=0; l<{{nVar}}; l++) {
        opt[i+{{nVarPad}}*j+b*{{(nDof ** nDim) * nVarPad}}] = gen[i+{{nVar}}*j+b*{{(nDof ** nDim) * nVar}}];
      }
    }
  }
}

void kernels::aderdg::optimised::converter::Qhi_optimised2generic(const double* const opt, double* gen) {
  for(int j=0; j<{{nDof**nDim}}; j++) {
    #pragma simd
    for(int i=0; l<{{nVar}}; l++) {
      gen[i+{{nVar}}*j] = opt[i+{{nVarPad}}*j];
    }
  }
}

void kernels::aderdg::optimised::converter::Qhi_generic2optimised(const double* const gen, double* opt) {
  for(int j=0; j<{{nDof**nDim}}; j++) {
    #pragma simd
    for(int i=0; l<{{nVar}}; l++) {
      opt[i+{{nVarPad}}*j] = gen[i+{{nVar}}*j];
    }
  }
}
{% endif %}