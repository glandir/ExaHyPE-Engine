{# /**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/ #}

#include <algorithm>
#include "kernels/aderdg/optimised/Kernels.h"
#include "kernels/aderdg/optimised/GaussLegendreQuadrature.h"
//#include "kernels/aderdg/optimised/asm_predictor.c"

template <bool useSource>
void kernels::aderdg::optimised::predictorNonlinear(
        const double* restrict const lQi, 
        const double* restrict const lFi,
        const double* restrict const lSi, //nullptr if not used
        double* restrict lQhi,
        double* restrict lFhi,
        double* restrict lShi //nullptr if not used
) {
  // Immediately compute the time - averaged space - time polynomials


  std::memset(lQhi, 0, {{nDof**nDim*nVarPad}} * sizeof(double));
  std::memset(lFhi, 0, {{(nDim+1)*nDof**nDim*nVarPad}} * sizeof(double));

  for (int i = 0; i < {{nDof3D}}; i++) {
    for (int j = 0; j < {{nDof}}; j++) {
      for (int k = 0; k < {{nDof}}; k++) {
        for (int n = 0; n < {{nVar}}; n++) {
          // Matrix-Vector Products
          for (int m = 0; m < {{nDof}}; m++) {
            // Fortran: lQhi(:,k,j,i) = lQi(:,:,k,j,i) * wGPN(:)
            lQhi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*i))] +=
                lQi[n+{{nVarPad}}*(m+{{nDof}}*(k+{{nDof}}*(j+{{nDof}}*i)))] * weights1[m];

            // Fortran: lFhi_x(:,k,j,i) = lFh(:,1,k,j,i,:) * wGPN(:)
            lFhi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*i))] +=
                lFi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(i+{{nDof3D}}*m)))] * weights1[m];

            // Fortran: lFhi_y(:,j,k,i) = lFh(:,2,:k,j,i,:) * wGPN(:)
            lFhi[n+{{nVarPad}}*(j+{{nDof}}*(k+{{nDof}}*i))+{{1*nVarPad*(nDof**nDim)}}] +=
                lFi[{{1*(nDof**nDim)*nDof*nVarPad}}+n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(i+{{nDof3D}}*m)))] * weights1[m];
            
            {% if nDim == 3%}
            // Fortran: lFhi_z(:,i,k,j) = lFh(:,3,k,j,i,:) * wGPN(:)
            lFhi[n+{{nVarPad}}*(i+{{nDof3D}}*(k+{{nDof}}*j))+{{2*nVarPad*(nDof**nDim)}}] +=
                lFi[{{2*(nDof**nDim)*nDof*nVarPad}}+n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(i+{{nDof3D}}*m)))] * weights1[m];
            {% endif %}
            
            // Fortran: lFhi_S(:,k,j,i) = lSh(:,k,j,i,:) * wGPN(:)
            if(useSource) { //branch optimised away at compile time
              lShi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*i))] +=
                lSi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(i+{{nDof3D}}*m)))] * weights1[m];
            }
          }
        }
      }
    }
  }
}