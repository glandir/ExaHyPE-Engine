{# /**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/ #}

#include <algorithm>
#include "kernels/aderdg/optimised/Kernels.h"
#include "kernels/aderdg/optimised/GaussLegendreQuadrature.h"
//#include "kernels/aderdg/optimised/asm_predictor.c"

template <bool useSource>
void kernels::aderdg::optimised::predictorNonlinear(
        const double* restrict const lQi, 
        const double* restrict const lFi,
        const double* restrict const lSi, //nullptr if not used
        double* restrict lQhi,
        double* restrict lFhi,
        double* restrict lShi //nullptr if not used
) {
  // Immediately compute the time - averaged space - time polynomials

#ifdef __INTEL_COMPILER
  __assume_aligned(lQi, ALIGNMENT);
  __assume_aligned(lFi, ALIGNMENT);
  __assume_aligned(lQhi, ALIGNMENT);
  __assume_aligned(lFhi, ALIGNMENT);
  __assume_aligned(weights1, ALIGNMENT);
  if(useSource) {
    __assume_aligned(lSi, ALIGNMENT);
    __assume_aligned(lShi, ALIGNMENT);
  }
#endif  

  std::memset(lQhi, 0, {{(nDof**nDim)*nVarPad}} * sizeof(double));
  std::memset(lFhi, 0, {{nDim*(nDof**nDim)*nVarPad}} * sizeof(double));
  
  if(useSource) {
    std::memset(lShi, 0, {{(nDof**nDim)*nVarPad}} * sizeof(double));
  } 

  for (int i = 0; i < {{nDof3D}}; i++) {
    for (int j = 0; j < {{nDof}}; j++) {
      for (int k = 0; k < {{nDof}}; k++) {
        
        // Matrix-Vector Products
        for (int m = 0; m < {{nDof}}; m++) {
          #pragma simd
          for (int n = 0; n < {{nVarPad}}; n++) {
            // Fortran: lQhi(:,k,j,i) = lQi(:,:,k,j,i) * wGPN(:)
            lQhi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*i))] += weights1[m] *
                lQi[n+{{nVarPad}}*(m+{{nDof}}*(k+{{nDof}}*(j+{{nDof}}*i)))];
          }
          #pragma simd
          for (int n = 0; n < {{nVarPad}}; n++) {
            // Fortran: lFhi_x(:,k,j,i) = lFh(:,1,k,j,i,:) * wGPN(:)
            lFhi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*i))] += weights1[m] *
                lFi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(i+{{nDof3D}}*m)))];
          }  
          #pragma simd
          for (int n = 0; n < {{nVarPad}}; n++) {
            // Fortran: lFhi_y(:,j,k,i) = lFh(:,2,:k,j,i,:) * wGPN(:)
            lFhi[n+{{nVarPad}}*(j+{{nDof}}*(k+{{nDof}}*i))+{{1*nVarPad*(nDof**nDim)}}] += weights1[m] *
                lFi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(i+{{nDof3D}}*m)))+{{1*(nDof**nDim)*nDof*nVarPad}}];
          }  
          {% if nDim == 3%}
          #pragma simd
          for (int n = 0; n < {{nVarPad}}; n++) {
            // Fortran: lFhi_z(:,i,k,j) = lFh(:,3,k,j,i,:) * wGPN(:)
            lFhi[n+{{nVarPad}}*(i+{{nDof}}*(k+{{nDof}}*j))+{{2*nVarPad*(nDof**nDim)}}] += weights1[m] *
                lFi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(i+{{nDof3D}}*m)))+{{2*(nDof**nDim)*nDof*nVarPad}}];
          }
          {% endif %}
            
          if(useSource) { //branch optimised away at compile time
            // Fortran: lFhi_S(:,k,j,i) = lSh(:,k,j,i,:) * wGPN(:)
            #pragma simd
            for (int n = 0; n < {{nVarPad}}; n++) {
              lShi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*i))] += weights1[m] *
                lSi[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(i+{{nDof3D}}*m)))];
            }
          }
        }
      
      }
    }
  }
}