{#

String time_var        : name of the var used in the outer time loop (use '0' is no time loop)
String input_gradQ     : name of the input gradQ array
String output          : name of the output array

#}
{% if useSourceOrNCP %}
// Compute the Nonconservative part NCP + Source
{% if useNCP %}
{% if not useNCPVect%}
double gradQ_PDE[{{nVar*nDim}}] __attribute__((aligned(ALIGNMENT)));
double ncp_tmp_output[{{nVarPad}}] __attribute__((aligned(ALIGNMENT)));
{% endif %}
{% endif %}
for(int xyz = 0; xyz < {{nDof**nDim}}; xyz++) { //zyx
  const double updateSize = weights1[{{time_var}}] * weights3[xyz] * dt;
  const int shift = {{nVarPad}}*(xyz+{{nDof**nDim}}*{{time_var}});
  const int it = {{time_var}}+{{nDof}}*xyz;
  
{% if useNCP %}
{% if useNCPVect %}
{% else %}
  //remove padding to use the same user function as generic kernel
  double gradQ_PDE[{{nVar*nDim}}]; 
  std::copy_n(&{{input_gradQ}}[{{nVarPad*nDim}}*it]              , {{nVar}}, &gradQ_PDE[{{0*nVar}}]); //x
  std::copy_n(&{{input_gradQ}}[{{nVarPad*nDim}}*it+{{1*nVarPad}}], {{nVar}}, &gradQ_PDE[{{1*nVar}}]); //y
{% if nDim==3 %}
  std::copy_n(&{{input_gradQ}}[{{nVarPad*nDim}}*it+{{2*nVarPad}}], {{nVar}}, &gradQ_PDE[{{2*nVar}}]); //z
{% endif %}
{% endif %}{# useNCPVect #}
{% endif %}{# useNCP #}
  
{% if useFusedSource %}
  //fusedSource
  #ifdef USE_IPO
    #pragma forceinline recursive
  #endif
  solver.{{solverName}}::fusedSource(&lQi[{{nDataPad}}*it], gradQ_PDE, &lSi[shift]);
{% else %}{# useFusedSource #}
{% if useSource %}
  // Source
  #ifdef USE_IPO
    #pragma forceinline recursive
  #endif
  solver.{{solverName}}::algebraicSource(&lQi[{{nDataPad}}*it], &lSi[shift]);
{% else %}
  std::memset(&lSi[shift], 0, {{nVarPad}} * sizeof(double)); // set source terms to 0
{% endif %}
{% if useNCP %}
  // NCP
  //std::memset(&ncp_tmp_output[0], 0, {{nVarPad}} * sizeof(double));
#ifdef USE_IPO
  #pragma forceinline recursive
#endif
  solver.{{solverName}}::nonConservativeProduct(&lQi[{{nDataPad}}*it], &gradQ_PDE[0], ncp_tmp_output);
  #pragma simd
  for(int n = 0; n<{{nVarPad}}; n++) {
    lSi[n+shift] -= ncp_tmp_output[n];
  }      
{% endif %} 
{% endif %}{# useFusedSource #}
  #pragma simd
  for (int n = 0; n < {{nVarPad}}; n++) {
    {{output}}[n+shift] += updateSize * lSi[n+shift];
  }
}
{% endif %}