{#
  String gemmKey
  String A
  String B
  String C
  String A_shift
  String B_shift
  String C_shift
  
  optional
  bool overrideUseLibxsmm : force locally useLibxsmm to take its value if set
  String trueB            : true array B
  String trueAlpha        : true value of the coefficent alpha (note: it will be multiplicated by the configuration alpha, /!\ sign error)
  bool forceCoeffMatrix   : only when using trueB, trueAlpha, force the no libxsmm case to also generate the coeff matrix
  
  If trueB is used, a temporary array trueAlpha*trueB 
#}
{% with %}
{# /**************************************
   **** Set up helper template values ****
   **************************************/ #}
{% set conf = gemmList[gemmKey] %}
{% if overrideUseLibxsmm is not defined %}
{% set overrideUseLibxsmm = useLibxsmm %}{# if no override then take the current value #}
{% endif %}
{% if trueB is not defined %}
{% set trueB = B %}
{% set useTrueB = False %}
{% set trueAlpha_string = '' %}
{% else %}
{% set useTrueB = True %}
{% set trueAlpha_string = trueAlpha~' * ' %}
{% endif %}
{% if forceCoeffMatrix is not defined %}
{% set forceCoeffMatrix = False %}
{% endif %}
{# /********************
   **** Subtemplate ****
   *********************/ #}
{% if overrideUseLibxsmm %}
{% if useTrueB %}
double {{B}}[{{conf.LDB*conf.K}}] __attribute__((aligned(ALIGNMENT)));
#pragma simd
for (int it = 0; it < {{conf.LDB*conf.K}}; it++) {
  {{B}}[it] = {{trueAlpha}} * {{trueB}}[it];
}
#if defined(USE_IPO) && !defined(UNSAFE_IPO)
volatile double doNotOptimizeAway_{{B}} = {{B}}[0]; //used to prevent the compiler from optimizing temp array away. Needs to be volatile
#endif
{% endif %}
#ifdef USE_IPO
  #pragma forceinline
#endif
{{conf.baseroutinename}}({{A}}+{{A_shift}}, {{B}}{% if B_shift != '0' %}+{{B_shift}}{% endif %}, {{C}}{% if C_shift != '0' %}+{{C_shift}}{% endif %});
{% else %}{# overrideUseLibxsmm #}
{% if forceCoeffMatrix %}
double {{B}}[{{conf.LDB*conf.K}}] __attribute__((aligned(ALIGNMENT)));
#pragma simd
for (int it = 0; it < {{conf.LDB*conf.K}}; it++) {
  {{B}}[it] = {{trueAlpha}} * {{trueB}}[it];
}
{% set trueAlpha_string = '' %}{# force the rest of the generated code to use the generated matrix #}
{% set trueB = B %}
{% endif %}
{% if conf.beta == 0 %}
// reset {{C}}
for (int it_1 = 0; it_1 < {{conf.K}}; it_1++) {
  #pragma simd
  for (int it_3 = 0; it_3 < {{conf.M}}; it_3++) {
    {{C}}[{{C_shift}}+it_1*{{conf.LDC}}+it_3] = 0.;
  }
}
{% endif %}
for (int it_1 = 0; it_1 < {{conf.K}}; it_1++) {
  for (int it_2 = 0; it_2 < {{conf.N}}; it_2++) {
    #pragma simd
    for (int it_3 = 0; it_3 < {{conf.M}}; it_3++) {
      {{C}}[{{C_shift}}+it_1*{{conf.LDC}}+it_3] {{ '+' if conf.alpha == 1 else '-' }}= {{A}}[{{A_shift}}+it_2*{{conf.LDA}}+it_3] * {{trueAlpha_string}}{{trueB}}[{% if B_shift != '0' %}{{B_shift}}+{% endif %}it_1*{{conf.LDB}}+it_2];
    }
  }
}
{% endif %}
{% endwith %}