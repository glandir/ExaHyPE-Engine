{#
  String inputLuh : name of the inputTensor (e.g. luh or lwh)
  String outputKi : name of the output tensor (e.g. K1 or K2)
#}
{% if useFlux %}

  // Flux component

{# ******************************************************
   **** call to flux function over {{inputLuh}} into lF_guess ****
   ****************************************************** #}
{% with inputQ=inputLuh, inputQ_varSize=nData, outputF='lF_guess',  timeInterleaved=False, time_var='0' %}
{% filter indent(width=2, indentfirst=True) %}{% include 'subtemplates/flux_PDE_over_xyz.template' %}{% endfilter %}
{% endwith %} 

  // x direction
  for (int j = 0; j < {{nDof3D}}; j++) {
    for (int k = 0; k < {{nDof}}; k++) {
{% with gemmKey='gradF_x_RKLoop', A='lF_guess', B='dudxT_by_dx', C=outputKi, A_shift='(j*'~nDof~'+k)*'~nVarPad*nDof, B_shift='0', C_shift='(j*'~nDof~'+k)*'~nVarPad*nDof %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/gemm.template' %}{% endfilter %}
{% endwith %} 
    }
  }
  
  // y direction
  for (int j = 0; j < {{nDof3D}}; j++) {
    for (int k = 0; k < {{nDof}}; k++) {
{% with gemmKey='gradF_y_RKLoop', A='lF_guess', B='dudxT_by_dx', C=outputKi, A_shift='(j*'~nDof*nDof~'+k)*'~nVarPad~'+'~(nDof**nDim)*nVarPad, B_shift='0', C_shift='(j*'~nDof*nDof~'+k)*'~nVarPad %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/gemm.template' %}{% endfilter %}
{% endwith %} 
    }
  }
  
{% if nDim==3 %}
  // z direction
  for (int j = 0; j < {{nDof}}; j++) {
    for (int k = 0; k < {{nDof}}; k++) {
{% with gemmKey='gradF_z_RKLoop', A='lF_guess', B='dudxT_by_dx', C=outputKi, A_shift='(j*'~nDof~'+k)*'~nVarPad~'+'~2*(nDof**nDim)*nVarPad, B_shift='0', C_shift='(j*'~nDof~'+k)*'~nVarPad %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/gemm.template' %}{% endfilter %}
{% endwith %} 
    }
  }
{% endif %}{# nDim == 3 #}
{% endif %}{# useFlux #}
{% if useNCP %}
  
  //NCP component
  
  // x direction
  for (int j = 0; j < {{nDof3D}}; j++) {
    for (int k = 0; k < {{nDof}}; k++) {
{% with gemmKey='gradQ_x_RKLoop', A=inputLuh, B='dudxT_by_dx', C='gradQ_guess', A_shift='(j*'~nDof~'+k)*'~nData*nDof, B_shift='0', C_shift='(j*'~nDof~'+k)*'~nVarPad*nDof %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/gemm.template' %}{% endfilter %}
{% endwith %} 
    }
  }
  
  // y direction
  for (int j = 0; j < {{nDof3D}}; j++) {
    for (int k = 0; k < {{nDof}}; k++) {
{% with gemmKey='gradQ_y_RKLoop', A=inputLuh, B='dudxT_by_dx', C='gradQ_guess', A_shift='(j*'~nDof*nDof~'+k)*'~nData, B_shift='0', C_shift='(j*'~nDof*nDof~'+k)*'~nVarPad~'+'~nVarPad*(nDof**nDim) %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/gemm.template' %}{% endfilter %}
{% endwith %} 
    }
  }
  
{% if nDim == 3 %}
  // z direction
  for (int j = 0; j < {{nDof3D}}; j++) {
    for (int k = 0; k < {{nDof}}; k++) {
{% with gemmKey='gradQ_z_RKLoop', A=inputLuh, B='dudxT_by_dx', C='gradQ_guess', A_shift='(j*'~nDof~'+k)*'~nData, B_shift='0', C_shift='(j*'~nDof~'+k)*'~nVarPad~'+'~2*nVarPad*(nDof**nDim) %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/gemm.template' %}{% endfilter %}
{% endwith %} 
    }
  }
{% endif %}
  {
    double tmp_fusedSource_output[{{nVarPad}}] __attribute__((aligned(ALIGNMENT))) = {0.};
    for(int jkl = 0; jkl < {{nDof**nDim}}; jkl++) { //zyx
      // Fusedsource (source and ncp)
      double gradQNoPad[{{nVar*nDim}}]; //remove padding to use the same user function as generic kernel
      std::copy_n(&gradQ_guess[{{nVarPad}}*jkl]              , {{nVar}}, &gradQNoPad[{{0*nVar}}]); //x
      std::copy_n(&gradQ_guess[{{nVarPad}}*jkl+{{1*nVarPad*(nDof**nDim)}}], {{nVar}}, &gradQNoPad[{{1*nVar}}]); //y
{% if nDim==3 %}
      std::copy_n(&gradQ_guess[{{nVarPad}}*jkl+{{2*nVarPad*(nDof**nDim)}}], {{nVar}}, &gradQNoPad[{{2*nVar}}]); //z
{% endif %}
      #ifdef USE_IPO
          #pragma forceinline recursive
      #endif
      solver.{{solverName}}::fusedSource(&{{inputLuh}}[{{nData}}*jkl], gradQNoPad, tmp_fusedSource_output);
      
      #pragma simd
      for (int n = 0; n < {{nVarPad}}; n++) {
        {{outputKi}}[n+{{nVarPad}}*jkl] -= tmp_fusedSource_output[n];
      }
    }
  }
{% endif %}