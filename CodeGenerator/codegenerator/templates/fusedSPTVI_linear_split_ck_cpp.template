/**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/
{% import 'subtemplates/macros.template' as m with context %}{# get template macros #}

#include <cstring>
#include <algorithm>

#include "{{pathToOptKernel}}/Kernels.h"
#include "{{pathToOptKernel}}/DGMatrices.h"
#include "{{pathToOptKernel}}/Quadrature.h"
{% if useLibxsmm %}
#include "{{pathToOptKernel}}/gemmsCPP.h"
{% endif %}

#include "kernels/DGBasisFunctions.h"

#include "{{solverHeader}}"

//NOTE lFi/gradQ swap nDim to lowest coordinate compared to generic


/*
 * For the linear kernels, we need the material parameters in the
 * space-time predictor lQi, time-averaged predictor lQhi,
 * and extrapolated predictor lQhbnd.
 * Currently we simply copy them over from the solution array.
 */
int {{codeNamespace}}::fusedSpaceTimePredictorVolumeIntegral{{nameSuffix}}(
    {{solverName}}& solver,
    double* restrict lduh,
    double* restrict lQhbnd,
    double* restrict lFhbnd,
    double* restrict lQi,
    double* restrict lFi,
    double* restrict lSi,   // for NCP or Source
    double* restrict lQhi,
    double* restrict lFhi,
    double* restrict lShi,  // for Source
    double* restrict gradQ, // for NCP or Source
    double* restrict PSi,   // for pointSource
    double* restrict PSderivatives, // for pointSource
    const double* const restrict luh,
    const double* const center,
    const double dx, // Assume dx[0] == dx[1] == dx[2]
    const double tStep, // == t
    const double dt,
    std::vector<int>* pointSources // will be deleted in the end if set
) {

  const double invDt = 1. / dt;
  const double invDx = 1. / dx;

  //std::memset(lQi, 0, {{(nDof+1)*(nDof**nDim)*nDataPad}}*sizeof(double));
  //std::memset(lFi, 0, {{nDim*nDof*(nDof**nDim)*nVarPad}}*sizeof(double));
{% if useSource %}
  //std::memset(lSi  , 0, {{nDof*(nDof**nDim)*nVarPad}}*sizeof(double));
{% endif %}

  // local tmp array
  double tmpArray[{{nVarPad}}] __attribute__((aligned(ALIGNMENT))); //used by flux and ncp
  double dudxT_by_dx[{{nDof*nDofPad}}] __attribute__((aligned(ALIGNMENT)));
{% if useLibxsmm %}
#if defined(USE_IPO) && ! defined(UNSAFE_IPO)
  double doNotOptimizeAway = dudxT_by_dx[0]; // used to prevent the compiler from optimizing dudxT_by_dx away
#endif
{% endif %}

  // TODO get as arg instead
  double* lQi_next = lQi + {{nDof**nDim*nVarPad}};
{% if nPar != 0 %}
  double* P        = lQi + {{2*nDof**nDim*nVarPad}};
{% else %}
  double* P = nullptr;
{% endif %}

  // 0. precompute 1/dx * dudx_T. Assume dx[0] == dx[1] == dx[2]
  #pragma omp simd aligned(dudxT_by_dx,dudx_T:ALIGNMENT)
  for (int it = 0; it < {{nDof*nDofPad}}; it++) {
    dudxT_by_dx[it] = invDx * dudx_T[it];
  }

  //***************************
  //**** Cauchy-Kovalewski ****
  //***************************

  for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
    std::copy_n(luh+xyz*{{nData}}, {{nVar}}, lQhi+xyz*{{nVarPad}});
    std::copy_n(luh+xyz*{{nData}}, {{nVar}}, lQi +xyz*{{nVarPad}});
{% if nPar != 0 %}
    //init material parameters
    std::copy_n(luh+xyz*{{nData}} + {{nVar}}, {{nPar}}, P+xyz*{{nParPad}});
{% endif %}
  }

  double dtavFac = 0.5 * dt;
  // 3. Cauchy-Kovalewski procedure
  for (int t = 0; t < {{nDof}}; t++) {  // time DOFs
    //put source here
    
    // reset lQi_next
    std::memset(lQi_next, 0, {{(nDof**nDim)*nVarPad}} *sizeof(double));

    //ncp in x
    // x direction (independent from the y and z derivatives)
    for (int yz = 0; yz < {{nDof*nDof3D}}; yz++) {
      {{ m.matmul('gradQ_x_sck', 'lQi', 'dudxT_by_dx', 'gradQ', 'yz*'~nDof*nVarPad, '0', 'yz*'~nDof*nVarPad) | indent(6) }}{##}
    }
    
    //call ncp in x
    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      solver.Elastic::ElasticWaveSolver::nonConservativeProduct_x(lQi+xyz*{{nVarPad}}, {% if nPar != 0 %}P+xyz*{{nParPad}}{% else %}nullptr{%endif%}, gradQ+xyz*{{nVarPad}}, tmpArray);
      #pragma omp simd aligned(lQi_next,tmpArray:ALIGNMENT)
      for (int n = 0; n < {{nVarPad}}; n++) {
        lQi_next[xyz*{{nVarPad}}+n] -= tmpArray[n]; 
      }
    }
    
    //ncp in y
    // y direction (independent from the x and z derivatives)
    for (int z = 0; z < {{nDof3D}}; z++) {
      for (int x = 0; x < {{nDof}}; x++) {
        {{ m.matmul('gradQ_y_sck', 'lQi', 'dudxT_by_dx', 'gradQ', '(z*'~nDof*nDof~'+x)*'~nVarPad, '0', '(z*'~nDof*nDof~'+x)*'~nVarPad) | indent(8) }}{##}
      }
    }
    
    //call ncp in y
    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      solver.Elastic::ElasticWaveSolver::nonConservativeProduct_y(lQi+xyz*{{nVarPad}}, {% if nPar != 0 %}P+xyz*{{nParPad}}{% else %}nullptr{%endif%}, gradQ+xyz*{{nVarPad}}, tmpArray);
      #pragma omp simd aligned(lQi_next,tmpArray:ALIGNMENT)
      for (int n = 0; n < {{nVarPad}}; n++) {
        lQi_next[xyz*{{nVarPad}}+n] -= tmpArray[n]; 
      }
    }
    
    //ncp in z
    // z direction (independent from the x and y derivatives)
    for (int xy = 0; xy < {{nDof*nDof}}; xy++) {
      {{ m.matmul('gradQ_z_sck', 'lQi', 'dudxT_by_dx', 'gradQ', 'xy*'~nVarPad, '0', 'xy*'~nVarPad) | indent(6) }}{##}
    }
    
    //call ncp in z
    for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
      solver.Elastic::ElasticWaveSolver::nonConservativeProduct_z(lQi+xyz*{{nVarPad}}, {% if nPar != 0 %}P+xyz*{{nParPad}}{% else %}nullptr{%endif%}, gradQ+xyz*{{nVarPad}}, tmpArray);
      #pragma omp simd aligned(lQi_next,tmpArray:ALIGNMENT)
      for (int n = 0; n < {{nVarPad}}; n++) {
        lQi_next[xyz*{{nVarPad}}+n] -= tmpArray[n]; 
      }
    }
    
    // update lQhi
    #pragma omp simd aligned(lQhi,lQi_next:ALIGNMENT)
    for (int it = 0; it < {{(nDof**nDim)*nVarPad}}; it++) {
        lQhi[it] += dtavFac * lQi_next[it];
    }
    dtavFac *= dt / (t + 2);
    
    //switch buffers //TODO JMG pointer swap ?
    std::copy_n(lQi_next,{{(nDof**nDim)*nVarPad}},lQi);
  
  } // end time loop
  
  
  //recompute lFhi in x
  for (int yz = 0; yz < {{nDof*nDof3D}}; yz++) {
    {{ m.matmul('gradQ_x_sck', 'lQhi', 'dudxT_by_dx', 'gradQ', 'yz*'~nDof*nVarPad, '0', 'yz*'~nDof*nVarPad) | indent(4) }}{##}
  }
  for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
    //include flux here
    std::memset(lFhi+xyz*{{nVarPad}}, 0, {{nVarPad}}*sizeof(double)); // TODO JMG flux ersatzt
    solver.Elastic::ElasticWaveSolver::nonConservativeProduct_x(lQhi+xyz*{{nVarPad}}, {% if nPar != 0 %}P+xyz*{{nParPad}}{% else %}nullptr{%endif%}, gradQ+xyz*{{nVarPad}}, tmpArray);
    #pragma omp simd aligned(lFhi,tmpArray:ALIGNMENT)
    for (int n = 0; n < {{nVarPad}}; n++) {
      lFhi[xyz*{{nVarPad}}+n] += tmpArray[n];
    }
  }
  
  
  //recompute lFhi in y
  for (int z = 0; z < {{nDof3D}}; z++) {
      for (int x = 0; x < {{nDof}}; x++) {
        {{ m.matmul('gradQ_y_sck', 'lQhi', 'dudxT_by_dx', 'gradQ', '(z*'~nDof*nDof~'+x)*'~nVarPad, '0', '(z*'~nDof*nDof~'+x)*'~nVarPad) | indent(6) }}{##}
      }
    }
  for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
    //include flux here
    std::memset(lFhi+xyz*{{nVarPad}}+{{nVarPad*(nDof**nDim)}}, 0, {{nVarPad}}*sizeof(double)); // TODO JMG flux ersatzt
    solver.Elastic::ElasticWaveSolver::nonConservativeProduct_y(lQhi+xyz*{{nVarPad}}, {% if nPar != 0 %}P+xyz*{{nParPad}}{% else %}nullptr{%endif%}, gradQ+xyz*{{nVarPad}}, tmpArray);
    #pragma omp simd aligned(lFhi,tmpArray:ALIGNMENT)
    for (int n = 0; n < {{nVarPad}}; n++) {
      lFhi[xyz*{{nVarPad}}+n+{{nVarPad*(nDof**nDim)}}] += tmpArray[n];
    }
  }
  
  //recompute lFhi in z
  for (int xy = 0; xy < {{nDof*nDof}}; xy++) {
    {{ m.matmul('gradQ_z_sck', 'lQhi', 'dudxT_by_dx', 'gradQ', 'xy*'~nVarPad, '0', 'xy*'~nVarPad) | indent(4) }}{##}
  }
  for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
    //include flux here
    std::memset(lFhi+xyz*{{nVarPad}}+{{2*nVarPad*(nDof**nDim)}}, 0, {{nVarPad}}*sizeof(double)); // TODO JMG flux ersatzt
    solver.Elastic::ElasticWaveSolver::nonConservativeProduct_z(lQhi+xyz*{{nVarPad}}, {% if nPar != 0 %}P+xyz*{{nParPad}}{% else %}nullptr{%endif%}, gradQ+xyz*{{nVarPad}}, tmpArray);
    #pragma omp simd aligned(lFhi,tmpArray:ALIGNMENT)
    for (int n = 0; n < {{nVarPad}}; n++) {
      lFhi[xyz*{{nVarPad}}+n+{{2*nVarPad*(nDof**nDim)}}] += tmpArray[n];
    }
  }


  //***********************
  //**** Extrapolation ****
  //***********************

  std::memset(lQhbnd, 0, {{2*nDim*nDof*nDof3D*nDataPad}}*sizeof(double));
  std::memset(lFhbnd, 0, {{2*nDim*nDof*nDof3D*nVarPad }}*sizeof(double));

  // x-direction: face 1 (left) and face 2 (right)
  for (int yz = 0; yz < {{nDof*nDof3D}}; yz++) {
    for (int x = 0; x < {{nDof}}; x++) {
{% if nPar == 0 %}
      #pragma omp simd aligned(lQhbnd,lQhi:ALIGNMENT)
      for (int n = 0; n < {{nDataPad}}; n++) {
        // left
        lQhbnd[yz*{{nDataPad}}+n] += lQhi[(yz*{{nDof}}+x)*{{nDataPad}}+n] * FLCoeff[x];
        // right
        lQhbnd[yz*{{nDataPad}}+n+{{1*nDof*nDof3D*nDataPad}}] += lQhi[(yz*{{nDof}}+x)*{{nDataPad}}+n] * FRCoeff[x];
      }
{% else %}
      #pragma omp simd aligned(lQhbnd,lQhi:ALIGNMENT)
      for (int n = 0; n < {{nVar}}; n++) {
        // left
        lQhbnd[yz*{{nDataPad}}+n] += lQhi[(yz*{{nDof}}+x)*{{nVarPad}}+n] * FLCoeff[x];
        // right
        lQhbnd[yz*{{nDataPad}}+n+{{1*nDof*nDof3D*nDataPad}}] += lQhi[(yz*{{nDof}}+x)*{{nVarPad}}+n] * FRCoeff[x];
      }
      #pragma omp simd aligned(lQhbnd,P:ALIGNMENT)
      for (int n = 0; n < {{nPar}}; n++) {
        // left
        lQhbnd[yz*{{nDataPad}}+n+{{0*nDof*nDof3D*nDataPad+nVar}}] += P[(yz*{{nDof}}+x)*{{nParPad}}+n] * FLCoeff[x];
        // right
        lQhbnd[yz*{{nDataPad}}+n+{{1*nDof*nDof3D*nDataPad+nVar}}] += P[(yz*{{nDof}}+x)*{{nParPad}}+n] * FRCoeff[x];
      }
{% endif %}
      #pragma omp simd aligned(lFhbnd,lFhi:ALIGNMENT)
      for (int n = 0; n < {{nVarPad}}; n++) {
        // left
        lFhbnd[yz*{{nVarPad}}+n] += lFhi[(yz*{{nDof}}+x)*{{nVarPad}}+n] * FLCoeff[x];
        // right
        lFhbnd[yz*{{nVarPad}}+n+{{1*nDof*nDof3D*nVarPad}}] += lFhi[(yz*{{nDof}}+x)*{{nVarPad}}+n] * FRCoeff[x];
      }
    }
  }


  // y-direction: face 3 (left) and face 4 (right)
  for (int z = 0; z < {{nDof3D}}; z++) {
    for (int x = 0; x < {{nDof}}; x++) {
      for (int y = 0; y < {{nDof}}; y++) {
{% if nPar == 0 %}
        #pragma omp simd aligned(lQhbnd,lQhi:ALIGNMENT)
        for (int n = 0; n < {{nDataPad}}; n++) {
          // left
          lQhbnd[(z*{{nDof3D}}+x)*{{nDataPad}}+n+{{2*nDof*nDof3D*nDataPad}}] += lQhi[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nDataPad}}+n] * FLCoeff[y];
          // right
          lQhbnd[(z*{{nDof3D}}+x)*{{nDataPad}}+n+{{3*nDof*nDof3D*nDataPad}}] += lQhi[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nDataPad}}+n] * FRCoeff[y];
        }
{% else %}
        #pragma omp simd aligned(lQhbnd,lQhi:ALIGNMENT)
        for (int n = 0; n < {{nVar}}; n++) {
          // left
          lQhbnd[(z*{{nDof3D}}+x)*{{nDataPad}}+n+{{2*nDof*nDof3D*nDataPad}}] += lQhi[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nVarPad}}+n] * FLCoeff[y];
          // right
          lQhbnd[(z*{{nDof3D}}+x)*{{nDataPad}}+n+{{3*nDof*nDof3D*nDataPad}}] += lQhi[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nVarPad}}+n] * FRCoeff[y];
        }
        #pragma omp simd aligned(lQhbnd,P:ALIGNMENT)
        for (int n = 0; n < {{nPar}}; n++) {
          // left
          lQhbnd[(z*{{nDof3D}}+x)*{{nDataPad}}+n+{{2*nDof*nDof3D*nDataPad+nVar}}] += P[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nParPad}}+n] * FLCoeff[y];
          // right
          lQhbnd[(z*{{nDof3D}}+x)*{{nDataPad}}+n+{{3*nDof*nDof3D*nDataPad+nVar}}] += P[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nParPad}}+n] * FRCoeff[y];
        }
{% endif %}
        #pragma omp simd aligned(lFhbnd,lFhi:ALIGNMENT)
        for (int n = 0; n < {{nVarPad}}; n++) {
          // left
          lFhbnd[(z*{{nDof3D}}+x)*{{nVarPad}}+n+{{2*nDof*nDof3D*nVarPad}}] += lFhi[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nVarPad}}+n+{{1*(nDof**nDim)*nVarPad}}] * FLCoeff[y];
          // right
          lFhbnd[(z*{{nDof3D}}+x)*{{nVarPad}}+n+{{3*nDof*nDof3D*nVarPad}}] += lFhi[((z*{{nDof3D}}+y)*{{nDof}}+x)*{{nVarPad}}+n+{{1*(nDof**nDim)*nVarPad}}] * FRCoeff[y];
        }
      }
    }
  }
{% if nDim==3 %}

  // z-direction: face 5 (left) and face 6 (right)
  for (int xy = 0; xy < {{nDof*nDof3D}}; xy++) {
    for (int z = 0; z < {{nDof}}; z++) {
{% if nPar == 0 %}
      #pragma omp simd aligned(lQhbnd,lQhi:ALIGNMENT)
      for (int n = 0; n <{{nDataPad}}; n++) {
        // left
        lQhbnd[xy*{{nDataPad}}+n+{{4*nDof*nDof3D*nDataPad}}] += lQhi[(z*{{nDof*nDof}}+xy)*{{nDataPad}}+n] * FLCoeff[z];
        // right
        lQhbnd[xy*{{nDataPad}}+n+{{5*nDof*nDof3D*nDataPad}}] += lQhi[(z*{{nDof*nDof}}+xy)*{{nDataPad}}+n] * FRCoeff[z];
      }
{% else %}
      #pragma omp simd aligned(lQhbnd,lQhi:ALIGNMENT)
      for (int n = 0; n <{{nVar}}; n++) {
        // left
        lQhbnd[xy*{{nDataPad}}+n+{{4*nDof*nDof3D*nDataPad}}] += lQhi[(z*{{nDof*nDof}}+xy)*{{nVarPad}}+n] * FLCoeff[z];
        // right
        lQhbnd[xy*{{nDataPad}}+n+{{5*nDof*nDof3D*nDataPad}}] += lQhi[(z*{{nDof*nDof}}+xy)*{{nVarPad}}+n] * FRCoeff[z];
      }
      #pragma omp simd aligned(lQhbnd,P:ALIGNMENT)
      for (int n = 0; n <{{nPar}}; n++) {
        // left
        lQhbnd[xy*{{nDataPad}}+n+{{4*nDof*nDof3D*nDataPad+nVar}}] += P[(z*{{nDof*nDof}}+xy)*{{nParPad}}+n] * FLCoeff[z];
        // right
        lQhbnd[xy*{{nDataPad}}+n+{{5*nDof*nDof3D*nDataPad+nVar}}] += P[(z*{{nDof*nDof}}+xy)*{{nParPad}}+n] * FRCoeff[z];
      }
{% endif %}
      #pragma omp simd aligned(lFhbnd,lFhi:ALIGNMENT)
      for (int n = 0; n < {{nVarPad}}; n++) {
        // left
        lFhbnd[xy*{{nVarPad}}+n+{{4*nDof*nDof3D*nVarPad}}] += lFhi[(z*{{nDof*nDof}}+xy)*{{nVarPad}}+n+{{2*(nDof**nDim)*nVarPad}}] * FLCoeff[z];
        // right
        lFhbnd[xy*{{nVarPad}}+n+{{5*nDof*nDof3D*nVarPad}}] += lFhi[(z*{{nDof*nDof}}+xy)*{{nVarPad}}+n+{{2*(nDof**nDim)*nVarPad}}] * FRCoeff[z];
      }
    }
  }
{% endif %}


  //*****************************
  //****** Volume Integral ******
  //*****************************


  #ifdef __INTEL_COMPILER
{% if useFlux %}
  __assume_aligned(lFhi,     ALIGNMENT);
{% endif %}{# useFlux #}
  __assume_aligned(lduh,     ALIGNMENT); //lduh should be aligned, see Solver.h
{% if useSource %}
  __assume_aligned(weights3, ALIGNMENT);
  __assume_aligned(lShi,     ALIGNMENT);
{% endif %}
#endif
  // for linear non-conservative PDE, the volume integral is trivial, since it
  // only involves the element mass matrix, which later will cancel
  memset(lduh, 0, {{nVarPad*(nDof**nDim)}}*sizeof(double));

  for (int xyz = 0; xyz < {{nDof**nDim}}; xyz++) {
    #pragma omp simd aligned(lduh,lFhi{{',lShi' if useSource else ''}}:ALIGNMENT)
    for (int n = 0; n < {{nVarPad}}; n++) {
        lduh[xyz*{{nVarPad}}+n] -= weights3[xyz] *
            (
{% if useFlux %}
                lFhi[xyz*{{nVarPad}}+n+{{0*nVarPad*nDof**nDim}}] //x
              + lFhi[xyz*{{nVarPad}}+n+{{1*nVarPad*nDof**nDim}}] //y
{% if nDim==3 %}
              + lFhi[xyz*{{nVarPad}}+n+{{2*nVarPad*nDof**nDim}}] //z
{% endif %}
{% endif %}
{% if useSource %}
              {{'+' if useFlux}} lShi[xyz*{{nVarPad}}+n] // source
{% endif %}
            );

    }
  }

  return -1; //no picard iteration in linear case

}
