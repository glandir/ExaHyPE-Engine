{#
  String inputLuh : name of the inputTensor (e.g. luh or lwh)
  int    inputLuh_dataSize
  String outputKi : name of the output tensor (e.g. K1 or K2)
#}
{# /********************
   **** Subtemplate ****
   *********************/ #}
{% if useFlux %}

  // Flux component

{# /******************************************************
   **** call to flux function over {{inputLuh}} into lF_guess ****
   ******************************************************/ #}
{% with inputQ=inputLuh, inputQ_dataSize=nData, outputF='lF_guess', timeInterleaved=False, time_var='0' %}
{% filter indent(width=2, indentfirst=True) %}{% include 'subtemplates/flux_PDE_over_xyz.template' %}{% endfilter %}
{% endwith %}

  // x direction
  for (int yz = 0; yz < {{nDof*nDof3D}}; yz++) {
{% with matmulKey='gradF_x_RKLoop', A='lF_guess', B='dudxT_by_dx', C=outputKi, A_shift='yz*'~nVarPad*nDof, B_shift='0', C_shift='yz*'~nVarPad*nDof %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/matmul.template' %}{% endfilter %}
{% endwith %}
  }
  
  // y direction
  for (int z = 0; z < {{nDof3D}}; z++) {
    for (int x = 0; x < {{nDof}}; x++) {
{% with matmulKey='gradF_y_RKLoop', A='lF_guess', B='dudxT_by_dx', C=outputKi, A_shift='(z*'~nDof*nDof~'+x)*'~nVarPad~'+'~(nDof**nDim)*nVarPad, B_shift='0', C_shift='(z*'~nDof*nDof~'+x)*'~nVarPad %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/matmul.template' %}{% endfilter %}
{% endwith %}
    }
  }
  
{% if nDim==3 %}
  // z direction
  for (int xy = 0; xy < {{nDof*nDof}}; xy++) {
{% with matmulKey='gradF_z_RKLoop', A='lF_guess', B='dudxT_by_dx', C=outputKi, A_shift='xy*'~nVarPad~'+'~2*(nDof**nDim)*nVarPad, B_shift='0', C_shift='xy*'~nVarPad %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/matmul.template' %}{% endfilter %}
{% endwith %}
  }
{% endif %}{# nDim == 3 #}
{% endif %}{# useFlux #}
{% if useNCP %}
  
  //NCP component
  std::memset(gradQ, 0, {{nDim*(nDof**nDim)*nVarPad}} * sizeof(double)); //reset gradQ to 0
  
  // x direction
  for (int yz = 0; yz < {{nDof*nDof3D}}; yz++) {
{% with matmulKey='gradQ_x_RKLoop', A=inputLuh, B='dudxT_by_dx', C='gradQ', A_shift='yz*'~nData*nDof, B_shift='0', C_shift='yz*'~nVarPad*nDof %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/matmul.template' %}{% endfilter %}
{% endwith %}
  }
  
  // y direction
  for (int z = 0; z < {{nDof3D}}; z++) {
    for (int x = 0; x < {{nDof}}; x++) {
{% with matmulKey='gradQ_y_RKLoop', A=inputLuh, B='dudxT_by_dx', C='gradQ', A_shift='(z*'~nDof*nDof~'+x)*'~nData, B_shift='0', C_shift='(z*'~nDof*nDof~'+x)*'~nVarPad~'+'~nVarPad*(nDof**nDim) %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/matmul.template' %}{% endfilter %}
{% endwith %}
    }
  }
  
{% if nDim == 3 %}
  // z direction
  for (int xy = 0; xy < {{nDof*nDof}}; xy++) {
{% with matmulKey='gradQ_z_RKLoop', A=inputLuh, B='dudxT_by_dx', C='gradQ', A_shift='xy*'~nData, B_shift='0', C_shift='xy*'~nVarPad~'+'~2*nVarPad*(nDof**nDim) %}
{% filter indent(width=6, indentfirst=True) %}{% include 'subtemplates/matmul.template' %}{% endfilter %}
{% endwith %}
  }
{% endif %}


  {
{# /***********************************************************
   **** call to Source and NCP (or FusedSource) functions ****
   ***********************************************************/ #}
{% with time_var='0', inputQ=inputLuh, output=outputKi, writeSource=False, multiplyByWeights=False, substractToOutput=True, inputQ_dataSize=inputLuh_dataSize, timeInterleaved=False %}
{% filter indent(width=4, indentfirst=True) %}{% include 'subtemplates/source_ncp_PDE_over_xyz.template' %}{% endfilter %}
{% endwith %}
  }
{% endif %}