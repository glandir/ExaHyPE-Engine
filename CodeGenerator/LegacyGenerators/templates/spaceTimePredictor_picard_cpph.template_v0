{# /**
 * This file is part of the ExaHyPE project.
 * Copyright (c) 2016  http://exahype.eu
 * All rights reserved.
 *
 * The project has received funding from the European Union's Horizon
 * 2020 research and innovation programme under grant agreement
 * No 671698. For copyrights and licensing, please consult the webpage.
 *
 * Released under the BSD 3 Open Source License.
 * For the full license text, see LICENSE.txt
 **/ #}

#include <cstring>
#include <algorithm>
#include "kernels/aderdg/optimised/Kernels.h"
#include "kernels/aderdg/optimised/DGMatrices.h"
#include "kernels/aderdg/optimised/GaussLegendreQuadrature.h"
#include "kernels/aderdg/optimised/CpphGemms.h"

//template <void PDEflux(const double* const Q, double** F), void PDEsource(const double* const Q, double* S)> 
template <void PDEflux(const double* const Q, double** F)>
void kernels::aderdg::optimised::picardLoopNonlinear(
        const double* restrict const luh, 
        const double dt,
        const tarch::la::Vector<DIMENSIONS, double>& dx,
        double* restrict lQi, double* restrict lQi_old, double* restrict rhs, double* restrict rhs_0,
        double* restrict lFi,
        double* restrict S, double* restrict gradQ, double* restrict BGradQ //source related term, nullptr if not used
) {

  // 1. Trivial initial guess
  for (int ijk = 0; ijk < {{nDof**nDim}}; ijk++) {
    for (int l = 0; l < {{nDof}}; l++) {
      for (int n = 0; n < {{nVar}}; n++) {
        // Fortran: lQi(n,:,k,j,i) = luh(n,k,j,i)
        lQi[n+{{nVarPad}}*(l+{{nDof}}*ijk)] = luh[n+{{nVar}}*ijk]; //TODO JMG memcpy ?
      }
    }
  }

  // 2. Compute the contribution of the initial condition uh to the time update
  for (int i = 0; i < {{nDof3D}}; i++) {
    for (int j = 0; j < {{nDof}}; j++) {
      for (int k = 0; k < {{nDof}}; k++) {
        const double weight = {{'weights1[i] * ' if nDim == 3 else ''}} weights1[j] * weights1[k];
        for (int n = 0; n < {{nVar}}; n++) {
          for (int m = 0; m < {{nDof}}; m++) { //TODO JMG unroll
            rhs_0[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(i+{{nDof3D}}*m)))] =
                weight * F0[m] * luh[n+{{nVar}}*(k+{{nDof}}*(j+{{nDof}}*i))];
          }
        }
      }
    }
  }

  // 3. Discrete Picard iterations
  const int MaxIterations = {{2 * nDof}};

  for (int iter = 0; iter < MaxIterations; iter++) {
    // Save old space-time DOF
    std::memcpy(lQi_old, lQi, {{nDof**(nDim+1)*nVarPad}} * sizeof(double));

    for (int i = 0; i < {{nDof}}; i++) {  // time DOF
    
      // Compute the fluxes
      for (int jkl = 0; jkl < {{nDof**nDim}}; jkl++) {
        // Call PDE fluxes
        const double* Q = &lQi[{{nVarPad}}*(i+{{nDof}}*jkl)];
        double* F[{{nDim}}];
        F[0] = &lFi[{{nVarPad}}*(jkl+{{nDof**nDim}}*i)+{{0*(nDof**nDim)*nDof*nVarPad}}];
        F[1] = &lFi[{{nVarPad}}*(jkl+{{nDof**nDim}}*i)+{{1*(nDof**nDim)*nDof*nVarPad}}];
        {% if nDim == 3 %}
        F[2] = &lFi[{{nVarPad}}*(jkl+{{nDof**nDim}}*i)+{{2*(nDof**nDim)*nDof*nVarPad}}];
        {% endif %}
        PDEflux(Q, F);
        //TODO JMG source
      }

      // Copy rhs0 -> rhs for slice at i
      std::copy(&rhs_0[i*{{(nDof**nDim)*nVarPad}}], &rhs_0[i*{{(nDof**nDim)*nVarPad}}]+{{(nDof**nDim)*nVarPad}}, &rhs[i*{{(nDof**nDim)*nVarPad}}]);
      

      // Compute the "derivatives" (contributions of the stiffness matrix)
      // x direction (independent from the y and z derivatives)
      for (int j = 0; j < {{nDof3D}}; j++) {
        for (int k = 0; k < {{nDof}}; k++) {
          const double weight = weights1[i] * {{'weights1[j] * ' if nDim == 3 else ''}} weights1[k];
          const double updateSize = weight * dt / dx[0];

          // Matrix operation
          for (int l = 0; l < {{nDof}}; l++) {
            for (int m = 0; m < {{nDof}}; m++) {
              for (int n = 0; n < {{nVar}}; n++) {
                rhs[n+{{nVarPad}}*(l+{{nDof}}*(k+{{nDof}}*(j+{{nDof3D}}*i)))] -= updateSize *
                                               lFi[n+{{nVarPad}}*(m+{{nDof}}*(k+{{nDof}}*(j+{{nDof3D}}*i)))] *
                                               Kxi[m+{{nDofPad}}*l];
              }
            }
          }
        }
      }

      // y direction (independent from the x and z derivatives)
      for (int j = 0; j < {{nDof3D}}; j++) {
        for (int k = 0; k < {{nDof}}; k++) {
          const double weight = weights1[i] * {{'weights1[j] * ' if nDim == 3 else ''}} weights1[k];
          const double updateSize = weight * dt / dx[1];

          // Matrix operation
          for (int l = 0; l < {{nDof}}; l++) {
            for (int m = 0; m < {{nDof}}; m++) {
              for (int n = 0; n < {{nVar}}; n++) {
                rhs[n+{{nVarPad}}*(k+{{nDof}}*(l+{{nDof}}*(j+{{nDof3D}}*i)))] -= updateSize *
                                               lFi[{{1*(nDof**nDim)*nDof*nVarPad}}+n+{{nVarPad}}*(k+{{nDof}}*(m+{{nDof}}*(j+{{nDof3D}}*i)))] *
                                               Kxi[m+{{nDofPad}}*l];
              }
            }
          }
        }
      }
      
      {% if nDim==3 %}
      // z direction (independent from the x and y derivatives)
      for (int j = 0; j < {{nDof}}; j++) {
        for (int k = 0; k < {{nDof}}; k++) {
          const double weight = weights1[i] *  weights1[j] * weights1[k];
          const double updateSize = weight * dt / dx[2];

          // Matrix operation
          for (int l = 0; l < {{nDof}}; l++) {
            for (int m = 0; m < {{nDof}}; m++) {
              for (int n = 0; n < {{nVar}}; n++) {
                rhs[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(l+{{nDof}}*i)))] -= updateSize *
                                               lFi[{{2*(nDof**nDim)*nDof*nVarPad}}+n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(m+{{nDof}}*i)))] *
                                               Kxi[m+{{nDofPad}}*l];
              }
            }
          }
        }
      }
      {% endif %}

      //TODO JMG source
     
    }  // end time dof

    // 4. Multiply with (K1)^(-1) to get the discrete time integral of the
    // discrete Picard iteration
    std::memset(lQi, 0, {{(nDof**nDim) * nDof * nVarPad}} * sizeof(double));
    for (int i = 0; i < {{nDof3D}}; i++) {
      for (int j = 0; j < {{nDof}}; j++) {
        for (int k = 0; k < {{nDof}}; k++) {
          const double weight = {{'weights1[i] *' if nDim == 3 else ''}} weights1[j] *  weights1[k];
          const double iweight = 1.0 / weight;

          // Matrix operation
          for (int l = 0; l < {{nDof}}; l++) {
            for (int m = 0; m < {{nDof}}; m++) {
              for (int n = 0; n < {{nVar}}; n++) {
                lQi[n+{{nVarPad}}*(l+{{nDof}}*(k+{{nDof}}*(j+{{nDof}}*i)))] += iweight *
                                               rhs[n+{{nVarPad}}*(k+{{nDof}}*(j+{{nDof}}*(i+{{nDof3D}}*m)))] *
                                               iK1[m+{{nDofPad}}*l];
              }
            }
          }
        }
      }
    }

    // 5. Exit condition
    const double tol = 1e-7;
    double sq_res = 0.0;
    for (int i = 0; i < {{nDof**(nDim+1)*nVarPad}}; i++) {
      sq_res += (lQi_old[i] - lQi[i]) * (lQi_old[i] - lQi[i]);
    }
    if (sq_res < tol * tol) {
      break;
    }

    if(false) { //no debug by default
      if (iter == MaxIterations) {  // No convergence after last iteration
        static tarch::logging::Log _log("kernels::aderdg::optimised");
        logWarning("picardLoop(...)",
                   "|res|^2=" << sq_res << " > |tol|^2=" << tol * tol << " after "
                              << iter << " iterations. Solver seems not to "
                                         "have converged properly within "
                                         "maximum number of iteration steps");
      }
    }
  }  // end iter
}