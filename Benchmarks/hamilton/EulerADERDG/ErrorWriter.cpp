// This file was generated by the ExaHyPE toolkit.
// It will not be overwritten.
//
//
// ========================
//   www.exahype.eu
// ========================
#include "ErrorWriter.h"

#include "EulerSolver.h"

#include "kernels/GaussLegendreQuadrature.h"

#include "peano/utils/Loop.h"

#include "tarch/la/VectorOperations.h"

#include <algorithm>

#include <iomanip>

EulerADERDG::ErrorWriter::ErrorWriter() : exahype::plotters::ADERDG2UserDefined::ADERDG2UserDefined(){
  // @TODO Please insert your code here.
}


void EulerADERDG::ErrorWriter::plotPatch(
    const tarch::la::Vector<DIMENSIONS, double>& offsetOfPatch,
    const tarch::la::Vector<DIMENSIONS, double>& sizeOfPatch, double* u,
    double timeStamp) {
  const tarch::la::Vector<DIMENSIONS, double> centre = offsetOfPatch + 0.5*sizeOfPatch;

  double x[DIMENSIONS];

  dfor(i,EulerSolver::Order+1) {
     double w_dV = 0;
     for (int d=0; d<DIMENSIONS; d++) {
       x[d] = offsetOfPatch[d] + sizeOfPatch[d] * kernels::gaussLegendreNodes[EulerSolver::Order][i(d)];
       w_dV = sizeOfPatch[d] * kernels::gaussLegendreWeights[EulerSolver::Order][i(d)];
     }

     double uAna[EulerSolver::NumberOfVariables];
     EulerSolver::entropyWave(x,timeStamp,uAna);

     const int iScalar  = peano::utils::dLinearised(i,EulerSolver::Order+1);
     const double* uNum = u + iScalar*EulerSolver::NumberOfVariables;

     for (int v=0; v<EulerSolver::NumberOfVariables; v++) {
        const double uDiff = std::abs(uNum[v]-uAna[v]);
        errorL2[v]   += uDiff*uDiff * w_dV;
        errorL1[v]   += uDiff * w_dV;
        errorLInf[v]  = std::max( errorLInf[v], uDiff );

        normL1Ana[v]  += std::abs(uAna[v]) * w_dV;
        normL2Ana[v]  += uAna[v] * uAna[v] * w_dV;
        normLInfAna[v] = std::max( normLInfAna[v], std::abs(uAna[v]) );
     }
  }
}

void EulerADERDG::ErrorWriter::startPlotting( double time) {
  _timeStamp = time;

  std::fill_n(errorL1,  EulerSolver::NumberOfVariables, 0.0);
  std::fill_n(errorL2,  EulerSolver::NumberOfVariables, 0.0);
  std::fill_n(errorLInf,EulerSolver::NumberOfVariables, 0.0);
  
  std::fill_n(normL1Ana,  EulerSolver::NumberOfVariables, 0.0);
  std::fill_n(normL2Ana,  EulerSolver::NumberOfVariables, 0.0);
  std::fill_n(normLInfAna,EulerSolver::NumberOfVariables, 0.0);
}

void EulerADERDG::ErrorWriter::finishPlotting() {
  for (int v=0; v<EulerSolver::NumberOfVariables; v++) {
    errorL2[v]   = sqrt(errorL2[v]);
    normL2Ana[v] = sqrt(normL2Ana[v]);
  }

  std::cout << "**Errors**" << std::endl;
  std::cout << "t_eval : "<<_timeStamp << std::endl;
  std::cout << "variable     : ";
  for (int v=0; v<EulerSolver::NumberOfVariables; v++) {
    std::cout << v << ", ";
  }
  std::cout << std::endl;

  std::cout << "absErrorL1   : ";
  for (int v=0; v<EulerSolver::NumberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL1[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "absErrorL2   : ";
  for (int v=0; v<EulerSolver::NumberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL2[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "absErrorLInf : ";
  for (int v=0; v<EulerSolver::NumberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorLInf[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "relErrorL1   : ";
  for (int v=0; v<EulerSolver::NumberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL1[v]/normL1Ana[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "relErrorL2   : ";
  for (int v=0; v<EulerSolver::NumberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorL2[v]/normL2Ana[v] << ", ";
  }
  std::cout << std::endl;

  std::cout << "relErrorLInf : ";
  for (int v=0; v<EulerSolver::NumberOfVariables; v++) {
    std::cout << std::setprecision(2) << errorLInf[v]/normLInfAna[v] << ", ";
  }
  std::cout << std::endl;
}
