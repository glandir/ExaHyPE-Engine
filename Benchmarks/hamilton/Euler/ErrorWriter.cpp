// This file was generated by the ExaHyPE toolkit.
// It will not be overwritten.
//
//
// ========================
//   www.exahype.eu
// ========================
#include "ErrorWriter.h"

#include "EulerSolver.h"

#include "kernels/GaussLegendreQuadrature.h"

#include "peano/utils/Loop.h"

#include <algorithm>


Euler::ErrorWriter::ErrorWriter() : exahype::plotters::ADERDG2UserDefined::ADERDG2UserDefined(){
  // @TODO Please insert your code here.
}


void Euler::ErrorWriter::plotPatch(
    const tarch::la::Vector<DIMENSIONS, double>& offsetOfPatch,
    const tarch::la::Vector<DIMENSIONS, double>& sizeOfPatch, double* u,
    double timeStamp) {
  double x[DIMENSIONS];

  dfor(i,EulerSolver::Order+1) {
     double w_dV = 0;
     for (int d=0; d<DIMENSIONS; d++) {
       x[d] = offsetOfPatch[d] + sizeOfPatch[d] * kernels::gaussLegendreNodes[EulerSolver::Order][i(d)];
       w_dV = sizeOfPatch[d] * kernels::gaussLegendreWeights[EulerSolver::Order][i(d)];
     }

     double uAna[EulerSolver::NumberOfVariables];
     EulerSolver::entropyWave(x,timeStamp,uAna);

     const int iScalar  = peano::utils::dLinearised(i,EulerSolver::Order+1);
     const double* uNum = u + iScalar*EulerSolver::NumberOfVariables;

     for (int v=0; v<EulerSolver::NumberOfVariables; v++) {
        const double uDiff = std::abs(uNum[v]-uAna[v]);
        errorL2[v] += uDiff*uDiff * w_dV;
     }
  }
}


void Euler::ErrorWriter::startPlotting( double time) {
  std::fill_n(errorL2, EulerSolver::NumberOfVariables, 0.0);
}


void Euler::ErrorWriter::finishPlotting() {
  for (int v=0; v<EulerSolver::NumberOfVariables; v++) {
    errorL2[v] = sqrt(errorL2[v]);
    std::cout << "eL2("<<v<<")="<<errorL2[v]<<std::endl;
  } 
}
