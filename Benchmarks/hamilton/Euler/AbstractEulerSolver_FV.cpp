// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include "AbstractEulerSolver_FV.h"

#include "kernels/finitevolumes/commons/c/commons.h"
#include "kernels/finitevolumes/musclhancock/c/musclhancock.h"
#include "kernels/finitevolumes/riemannsolvers/c/riemannsolvers.h"

#include "EulerSolver_FV.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.


#include <stdio.h>
#include <cstdlib> // abort()
#include "kernels/KernelUtils.h" // idx

#include "exahype/disableOptimization.h" // we experience compiler bugs sometimes.

Euler::EulerSolver_FV::EulerSolver_FV(double maximumMeshSize,int maximumAdaptiveMeshDepth,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs):
  AbstractEulerSolver_FV::AbstractEulerSolver_FV(maximumMeshSize,maximumAdaptiveMeshDepth,timeStepping) {
  init(cmdlineargs);
}

Euler::AbstractEulerSolver_FV::AbstractEulerSolver_FV(double maximumMeshSize,int maximumAdaptiveMeshDepth,exahype::solvers::Solver::TimeStepping timeStepping):
  exahype::solvers::FiniteVolumesSolver("EulerSolver_FV",NumberOfVariables,NumberOfParameters,PatchSize,
                                        GhostLayerWidth,maximumMeshSize,maximumAdaptiveMeshDepth,timeStepping) {
}

void Euler::AbstractEulerSolver_FV::constantsToString(std::ostream& os) {
	// This string is used in the --version output to identify compile time constants
	os << "Euler::AbstractEulerSolver_FV("
	   << "nVar=" << NumberOfVariables << ", "
	   << "nParam=" << NumberOfParameters << ", "
	   << "PatchSize=" << PatchSize << ", "
	   << "GhostLayerWidth=" << GhostLayerWidth
	   << ")";
}

void Euler::AbstractEulerSolver_FV::abortWithMsg(const char* const msg) {
	// verbosily fail even without assertions turned on
	puts(msg);
	abort();
}

void Euler::AbstractEulerSolver_FV::solutionUpdate(double* luhNew,const double* luh,double** tempStateSizedArrays,double** tempUnknowns,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt,double& maxAdmissibleDt) {
	
#define SU(useSource,useNCP,useFlux)\
  maxAdmissibleDt = kernels::finitevolumes::musclhancock::c::solutionUpdate<useSource,useNCP,useFlux, EulerSolver_FV>(\
       *static_cast<EulerSolver_FV*>(this),luhNew,luh,tempStateSizedArrays,tempUnknowns,dx,dt);

  if(useAlgebraicSource()) {
    if(useNonConservativeProduct()) {
      if(useConservativeFlux()) {
         SU(true,true,true);
      } else {
         SU(true,true,false);
      }
    } else {
      if(useConservativeFlux()) {
         SU(true,false,true);
      } else {
         SU(true,false,false);
      }
    }
  } else {
    if(useNonConservativeProduct()) {
      if(useConservativeFlux()) {
         SU(false,true,true);
      } else {
         SU(false,true,false);
      }
    } else {
      if(useConservativeFlux()) {
         SU(false,false,true);
      } else {
         SU(false,false,false);
      }
    }
  }
}


double Euler::AbstractEulerSolver_FV::stableTimeStepSize(const double* const luh,double* tempEigenvalues,const tarch::la::Vector<DIMENSIONS,double>& dx) {
  double maxAdmissibleDt = kernels::finitevolumes::commons::c::stableTimeStepSize<EulerSolver_FV>(*static_cast<EulerSolver_FV*>(this),luh,tempEigenvalues,dx);
  return maxAdmissibleDt;
}

void Euler::AbstractEulerSolver_FV::adjustSolution(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) {
  kernels::finitevolumes::commons::c::solutionAdjustment<EulerSolver_FV>(*static_cast<EulerSolver_FV*>(this),luh,center,dx,t,dt);
}

void Euler::AbstractEulerSolver_FV::boundaryConditions(double* luhbndOutside,const double* const luhbndInside,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {
  kernels::finitevolumes::commons::c::boundaryConditions<EulerSolver_FV>(*static_cast<EulerSolver_FV*>(this),luhbndOutside,luhbndInside,cellCentre,cellSize,t,dt,faceIndex,normalNonZero);
}


void Euler::AbstractEulerSolver_FV::ghostLayerFilling(double* luh,const double* luhNeighbour,const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) {
  kernels::finitevolumes::commons::c::ghostLayerFilling<EulerSolver_FV>(*static_cast<EulerSolver_FV*>(this),luh,luhNeighbour,neighbourPosition);
}

void Euler::AbstractEulerSolver_FV::ghostLayerFillingAtBoundary(double* luh,const double* luhbnd,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::commons::c::ghostLayerFillingAtBoundary<EulerSolver_FV>(*static_cast<EulerSolver_FV*>(this),luh,luhbnd,boundaryPosition);
}

void Euler::AbstractEulerSolver_FV::boundaryLayerExtraction(double* luhbnd,const double* luh,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::commons::c::boundaryLayerExtraction<EulerSolver_FV>(*static_cast<EulerSolver_FV*>(this),luhbnd,luh,boundaryPosition);
}


double Euler::AbstractEulerSolver_FV::riemannSolver(double* fL, double *fR, const double* qL, const double* qR, int normalNonZero) {
  // Default FV Riemann Solver
  #define RUSANOV(useNCP, useFlux) \
      return kernels::finitevolumes::riemannsolvers::c::rusanov<useNCP, useFlux, EulerSolver_FV>(\
          *static_cast<EulerSolver_FV*>(this), fL,fR,qL,qR,normalNonZero);

  // TODO: As always, this guard <-> templating interface is not useful.
  if(useNonConservativeProduct()) {
    if(useConservativeFlux()) {
      RUSANOV(true, true);
    } else {
      RUSANOV(true, false);
    }
  } else {
    if(useConservativeFlux()) {
      RUSANOV(false, true);
    } else {
      RUSANOV(false, false);
    }
  }
}



void Euler::AbstractEulerSolver_FV::nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) {
      abortWithMsg("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void Euler::AbstractEulerSolver_FV::algebraicSource(const double* const Q,double* S) {
      abortWithMsg("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void Euler::AbstractEulerSolver_FV::flux(const double* const Q,double** F) {
      abortWithMsg("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void Euler::AbstractEulerSolver_FV::pointSource(const double* const x,const double t,const double dt, double* forceVector, double* x0) {
      abortWithMsg("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

/**
 * Fallback implementations of joined functions. Users can either safely ignore this
 * or overwrite with their own implementations.
 **/
#include "kernels/fusedMethods.cpph"


void Euler::AbstractEulerSolver_FV::fusedSource(const double* const Q, const double* const gradQ, double* S) {
   #define FUSEDSOURCE(useSource, useNCP) \
      kernels::fusedSource<useSource, useNCP, EulerSolver_FV>(*static_cast<EulerSolver_FV*>(this), Q, gradQ, S);
  if(useAlgebraicSource()) {
    if(useNonConservativeProduct()) {
      FUSEDSOURCE(true, true);
    } else {
      FUSEDSOURCE(true, false);
    }
  } else {
    if(useNonConservativeProduct()) {
      FUSEDSOURCE(false, true);
    } else {
      FUSEDSOURCE(false, false);
    }
  }
}

void Euler::AbstractEulerSolver_FV::coefficientMatrix(const double* const Q,const int d,double* Bn) {
  kernels::coefficientMatrix<EulerSolver_FV>(*static_cast<EulerSolver_FV*>(this), Q, d, Bn);
}
