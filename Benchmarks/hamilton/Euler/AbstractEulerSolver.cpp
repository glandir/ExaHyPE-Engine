// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "AbstractEulerSolver.h"

#include "kernels/aderdg/generic/Kernels.h"

#include "EulerSolver.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include <stdio.h>

// Code generation information.
/* #define isLinear */
/* #define isFortran */

// We define the constructor of the actual solver here in order to regenerate it easily.
Euler::EulerSolver::EulerSolver(double maximumMeshSize,int maximumAdaptiveMeshDepth,int DMPObservables,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs):
  AbstractEulerSolver::AbstractEulerSolver(maximumMeshSize,maximumAdaptiveMeshDepth,DMPObservables,timeStepping) {
  init(cmdlineargs);
}


Euler::AbstractEulerSolver::AbstractEulerSolver(double maximumMeshSize,int maximumAdaptiveMeshDepth,int DMPObservables,exahype::solvers::Solver::TimeStepping timeStepping):
  exahype::solvers::ADERDGSolver("EulerSolver",NumberOfVariables,NumberOfParameters,Order+1,
                                 maximumMeshSize,maximumAdaptiveMeshDepth,DMPObservables,timeStepping) {
}

void Euler::AbstractEulerSolver::constantsToString(std::ostream& os) {
	// This string is used in the --version output to identify compile time constants
	os << "Euler::AbstractEulerSolver("
	   << "nVar=" << NumberOfVariables << ", "
	   << "nParam=" << NumberOfParameters << ", "
	   << "Order=" << Order
	   << ")";
}

void Euler::AbstractEulerSolver::abortWithMsg(const char* const msg) {
	// verbosily fail even without assertions turned on
	puts(msg);
	abort();
}

void Euler::AbstractEulerSolver::spaceTimePredictor(double* lQhbnd,double* lFhbnd,double** tempSpaceTimeUnknowns,double** tempSpaceTimeFluxUnknowns,double* tempUnknowns,double* tempFluxUnknowns,double* tempStateSizedVectors,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt, double* pointForceSources) {

#ifdef isFortran
  kernels::aderdg::generic::fortran::spaceTimePredictorNonlinear<EulerSolver>(*static_cast<EulerSolver*>(this),lQhbnd,lFhbnd,tempSpaceTimeUnknowns,tempSpaceTimeFluxUnknowns,tempUnknowns,tempFluxUnknowns,tempStateSizedVectors,luh,dx,dt, pointForceSources);
#else
#ifdef isLinear

#define STPL(usePointSource, useSource, useFlux, useNCP)				\
        kernels::aderdg::generic::c::spaceTimePredictorLinear<usePointSource, useSource, useFlux, useNCP, EulerSolver>( \
           *static_cast<EulerSolver*>(this),lQhbnd,lFhbnd, \
           tempSpaceTimeUnknowns,tempSpaceTimeFluxUnknowns,tempUnknowns,tempFluxUnknowns,tempStateSizedVectors,luh,dx,dt, pointForceSources);

 if( usePointSource() &&  useAlgebraicSource() &&  useConservativeFlux() &&  useNonConservativeProduct()) STPL(true,true,true,true);
 if( usePointSource() &&  useAlgebraicSource() &&  useConservativeFlux() && !useNonConservativeProduct()) STPL(true,true,true,false);
 if( usePointSource() &&  useAlgebraicSource() && !useConservativeFlux() &&  useNonConservativeProduct()) STPL(true,true,false,true);
 if( usePointSource() &&  useAlgebraicSource() && !useConservativeFlux() && !useNonConservativeProduct()) STPL(true,true,false,false);
 if( usePointSource() && !useAlgebraicSource() &&  useConservativeFlux() &&  useNonConservativeProduct()) STPL(true,false,true,true);
 if( usePointSource() && !useAlgebraicSource() &&  useConservativeFlux() && !useNonConservativeProduct()) STPL(true,false,true,false);
 if( usePointSource() && !useAlgebraicSource() && !useConservativeFlux() &&  useNonConservativeProduct()) STPL(true,false,false,true);
 if( usePointSource() && !useAlgebraicSource() && !useConservativeFlux() && !useNonConservativeProduct()) STPL(true,false,false,false);
 if(!usePointSource() &&  useAlgebraicSource() &&  useConservativeFlux() &&  useNonConservativeProduct()) STPL(false,true,true,true);
 if(!usePointSource() &&  useAlgebraicSource() &&  useConservativeFlux() && !useNonConservativeProduct()) STPL(false,true,true,false);
 if(!usePointSource() &&  useAlgebraicSource() && !useConservativeFlux() &&  useNonConservativeProduct()) STPL(false,true,false,true);
 if(!usePointSource() &&  useAlgebraicSource() && !useConservativeFlux() && !useNonConservativeProduct()) STPL(false,true,false,false);
 if(!usePointSource() && !useAlgebraicSource() &&  useConservativeFlux() &&  useNonConservativeProduct()) STPL(false,false,true,true);
 if(!usePointSource() && !useAlgebraicSource() &&  useConservativeFlux() && !useNonConservativeProduct()) STPL(false,false,true,false);
 if(!usePointSource() && !useAlgebraicSource() && !useConservativeFlux() &&  useNonConservativeProduct()) STPL(false,false,false,true);
 if(!usePointSource() && !useAlgebraicSource() && !useConservativeFlux() && !useNonConservativeProduct()) STPL(false,false,false,false);

#else

  // For some reason, we compile here the SpaceTimepRedictorNonLinear (STPNL) for all possible
  // combinations, even if the guards have no other possibility than staying constant for the whole
  // run (which means they could be constexpr). I have no clue why we need this overhead here. In
  // my eyes it's waste of time. Maybe somebody can explain it to me.  -- Sven, 2017-04-07.

#define STPNL(useSource, useFlux, useNCP) \
    kernels::aderdg::generic::c::spaceTimePredictorNonlinear<useSource, useFlux, useNCP, EulerSolver>(\
        *static_cast<EulerSolver*>(this), lQhbnd, lFhbnd,\
        tempSpaceTimeUnknowns,tempSpaceTimeFluxUnknowns,tempUnknowns,tempFluxUnknowns,tempStateSizedVectors,\
        luh,dx,dt);
  
  if(useAlgebraicSource()) {
    if(useConservativeFlux()) {
      if(useNonConservativeProduct()) {
        STPNL(true,true,true);
      } else {
        STPNL(true,true,false);
      }
    } else {
      if(useNonConservativeProduct()) {
        STPNL(true,false,true);
      } else {
        STPNL(true,false,false);
      }
    }
  } else {
    if(useConservativeFlux()) {
      if(useNonConservativeProduct()) {
        STPNL(false,true,true);
      } else {
        STPNL(false,true,false);
      }
    } else {
      if(useNonConservativeProduct()) {
        STPNL(false,false,true);
      } else {
        STPNL(false,false,false);
      }
    }
  } 
#endif // isLinear
#endif // isFortran

}



void Euler::AbstractEulerSolver::solutionUpdate(double* luh,const double* const lduh,const double dt) {

  kernels::aderdg::generic::c::solutionUpdate<EulerSolver>(*static_cast<EulerSolver*>(this),luh,lduh,dt);

}



void Euler::AbstractEulerSolver::volumeIntegral(double* lduh,const double* const lFhi,const tarch::la::Vector<DIMENSIONS,double>& dx) {

#ifdef isFortran
  kernels::aderdg::generic::fortran::volumeIntegralNonlinear(lduh,lFhi,dx,getNumberOfVariables(),getNumberOfParameters(),getNodesPerCoordinateAxis());
#endif
#ifndef isFortran
#ifdef isLinear
#define VI(useSource, useFlux) \
	  kernels::aderdg::generic::c::volumeIntegralLinear<useSource,useFlux,NumberOfVariables,Order+1>(lduh,lFhi,dx);

#else

#define VI(useSource, useFlux) \
	    kernels::aderdg::generic::c::volumeIntegralNonlinear<useSource,useFlux,NumberOfVariables,Order+1>(lduh,lFhi,dx);
#endif // isLinear
  
  if(useAlgebraicSource() || useNonConservativeProduct()) {
    if(useConservativeFlux()) {
      VI(true, true);
    } 	else {
      VI(true, false);
    } 
  } else {
    if(useConservativeFlux()) {
      VI(false, true);
    } else {			 
      VI(false, false);
    }
  }

#endif // !isFortran

}



void Euler::AbstractEulerSolver::surfaceIntegral(double* lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& dx) {

  kernels::aderdg::generic::c::surfaceIntegralNonlinear<NumberOfVariables,Order+1>(lduh,lFhbnd,dx);

}



void Euler::AbstractEulerSolver::riemannSolver(double* FL,double* FR,const double* const QL,const double* const QR,double* tempFaceUnknownsArray,double** tempStateSizedVectors,double** tempStateSizedSquareMatrices,const double dt,const int normalNonZeroIndex,bool isBoundaryFace) {
  assertion2(normalNonZeroIndex>=0,dt,normalNonZeroIndex);
  assertion2(normalNonZeroIndex<DIMENSIONS,dt,normalNonZeroIndex);

#ifdef isFortran
  kernels::aderdg::generic::fortran::riemannSolverNonlinear<EulerSolver>(*static_cast<EulerSolver*>(this),FL,FR,QL,QR,tempFaceUnknownsArray,tempStateSizedVectors,tempStateSizedSquareMatrices,dt,normalNonZeroIndex);
#endif
#ifndef isFortran
#ifdef isLinear
  if(useNonConservativeProduct()) {
   kernels::aderdg::generic::c::riemannSolverLinear<true,EulerSolver>(*static_cast<EulerSolver*>(this),FL,FR,QL,QR,tempFaceUnknownsArray,tempStateSizedVectors,tempStateSizedSquareMatrices,dt,normalNonZeroIndex);
  } else {
   kernels::aderdg::generic::c::riemannSolverLinear<false,EulerSolver>(*static_cast<EulerSolver*>(this),FL,FR,QL,QR,tempFaceUnknownsArray,tempStateSizedVectors,tempStateSizedSquareMatrices,dt,normalNonZeroIndex);
  }
#else
  if(useNonConservativeProduct()) {
    kernels::aderdg::generic::c::riemannSolverNonlinear<true,EulerSolver>(*static_cast<EulerSolver*>(this),FL,FR,QL,QR,tempFaceUnknownsArray,tempStateSizedVectors,tempStateSizedSquareMatrices,dt,normalNonZeroIndex);
  } else {
    kernels::aderdg::generic::c::riemannSolverNonlinear<false,EulerSolver>(*static_cast<EulerSolver*>(this),FL,FR,QL,QR,tempFaceUnknownsArray,tempStateSizedVectors,tempStateSizedSquareMatrices,dt,normalNonZeroIndex);
  }
#endif // isLinear
#endif // !isFortran

}



void Euler::AbstractEulerSolver::boundaryConditions(double* fluxOut,double* stateOut,const double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {

  kernels::aderdg::generic::c::boundaryConditions<EulerSolver>(*static_cast<EulerSolver*>(this),fluxOut,stateOut,fluxIn,stateIn,cellCentre,cellSize,t,dt,faceIndex,normalNonZero);

}



double Euler::AbstractEulerSolver::stableTimeStepSize(const double* const luh,double* tempEigenvalues,const tarch::la::Vector<DIMENSIONS,double>& dx) {

  double d = kernels::aderdg::generic::c::stableTimeStepSize<EulerSolver>(*static_cast<EulerSolver*>(this),luh,tempEigenvalues,dx);

  return d;
}



void Euler::AbstractEulerSolver::adjustSolution(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) {

  switch (useAdjustSolution(center, dx, t, dt)) {
    case AdjustSolutionValue::No:
      abortWithMsg("Branch may not be entered. Solver spec clarifies that adjust solution is not to be called, but kernel nevertheless invokes adjustSolution." );
      break;
    case AdjustSolutionValue::PointWisely:
      kernels::aderdg::generic::c::solutionAdjustment<EulerSolver>(*static_cast<EulerSolver*>(this),luh,center,dx,t,dt);
      break;
    case AdjustSolutionValue::PatchWisely:
      adjustPatchSolution(
        center, dx, t, dt, luh);
      break;
  }

}



void Euler::AbstractEulerSolver::faceUnknownsProlongation(double* lQhbndFine,double* lFhbndFine,const double* lQhbndCoarse,const double* lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {

  kernels::aderdg::generic::c::faceUnknownsProlongation<NumberOfVariables,NumberOfParameters,Order+1>(lQhbndFine,lFhbndFine,lQhbndCoarse,lFhbndCoarse,coarseGridLevel,fineGridLevel,subfaceIndex);

}



void Euler::AbstractEulerSolver::faceUnknownsRestriction(double* lQhbndCoarse,double* lFhbndCoarse,const double* lQhbndFine,const double* lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {

  kernels::aderdg::generic::c::faceUnknownsRestriction<NumberOfVariables,NumberOfParameters,Order+1>(lQhbndCoarse,lFhbndCoarse,lQhbndFine,lFhbndFine,coarseGridLevel,fineGridLevel,subfaceIndex);

}



void Euler::AbstractEulerSolver::volumeUnknownsProlongation(double* luhFine,const double* luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {

  kernels::aderdg::generic::c::volumeUnknownsProlongation<NumberOfVariables,NumberOfParameters,Order+1>(luhFine,luhCoarse,coarseGridLevel,fineGridLevel,subcellIndex);

}



void Euler::AbstractEulerSolver::volumeUnknownsRestriction(double* luhCoarse,const double* luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {

  kernels::aderdg::generic::c::volumeUnknownsRestriction<NumberOfVariables,NumberOfParameters,Order+1>(luhCoarse,luhFine,coarseGridLevel,fineGridLevel,subcellIndex);

}




void Euler::AbstractEulerSolver::pointSource(const double t,const double dt, const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx, double* tempPointForceSources) {

  kernels::aderdg::generic::c::pointSource<EulerSolver>(*static_cast<EulerSolver*>(this), t, dt, center, dx, getNumberOfVariables(),getNumberOfParameters(),getNodesPerCoordinateAxis(), tempPointForceSources);

}

void Euler::AbstractEulerSolver::flux(const double* const Q,double** F) {
      abortWithMsg("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void Euler::AbstractEulerSolver::algebraicSource(const double* const Q,double* S) {
      abortWithMsg("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}
        
void Euler::AbstractEulerSolver::nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) {
      abortWithMsg("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void Euler::AbstractEulerSolver::pointSource(const double* const x,const double t,const double dt, double* forceVector, double* x0) {
      abortWithMsg("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void Euler::AbstractEulerSolver::adjustPointSolution(const double* const x,const double w,const double t,const double dt,double* Q) {
      abortWithMsg("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );}

void Euler::AbstractEulerSolver::adjustPatchSolution(
      const tarch::la::Vector<DIMENSIONS, double>& cellCentre,
      const tarch::la::Vector<DIMENSIONS, double>& dx,
      const double t,
      const double dt,
      double* luh) {
      abortWithMsg("If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

/**
 * Fallback implementations of joined functions. Users can either safely ignore this
 * or overwrite with their own implementations.
 **/
#include "kernels/fusedMethods.cpph"

void Euler::AbstractEulerSolver::fusedSource(const double* const Q, const double* const gradQ, double* S) {
   #define FUSEDSOURCE(useSource, useNCP) \
      kernels::fusedSource<useSource, useNCP, EulerSolver>(*static_cast<EulerSolver*>(this), Q, gradQ, S);
  if(useAlgebraicSource()) {
    if(useNonConservativeProduct()) {
      FUSEDSOURCE(true, true);
    } else {
      FUSEDSOURCE(true, false);
    }
  } else {
    if(useNonConservativeProduct()) {
      FUSEDSOURCE(false, true);
    } else {
      FUSEDSOURCE(false, false);
    }
  }
}

void Euler::AbstractEulerSolver::coefficientMatrix(const double* const Q,const int d,double* Bn) {
  kernels::coefficientMatrix<EulerSolver>(*static_cast<EulerSolver*>(this), Q, d, Bn);
}


