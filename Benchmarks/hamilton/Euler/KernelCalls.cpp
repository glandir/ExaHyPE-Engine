// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================

#include <sstream>
#include <ostream>
#include "exahype/plotters/Plotter.h"
#include "exahype/profilers/ProfilerFactory.h"
#include "exahype/solvers/Solver.h"
#include "exahype/solvers/SolverCoupling.h"

#include "kernels/KernelCalls.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/GaussLobattoQuadrature.h"
#include "kernels/LimiterProjectionMatrices.h"
#include "kernels/DGMatrices.h"
#include "kernels/DGBasisFunctions.h"
#include "buildinfo.h"

#include "exahype/solvers/LimitingADERDGSolver.h"
#include "EulerSolver_ADERDG.h"
#include "EulerSolver_FV.h"
#include "ErrorWriter.h"
#include "ErrorPlotter.h"



void kernels::initSolvers(exahype::Parser& parser, std::vector<std::string>& cmdlineargs) {
  {

  // Create and register solver
  exahype::solvers::Solver* solver = nullptr;

  {
  solver = new Euler::EulerSolver_ADERDG(parser.getMaximumMeshSize(0), parser.getMaximumMeshDepth(0), parser.getDMPObservables(0), parser.getTimeStepping(0), cmdlineargs);
  }
  std::unique_ptr<exahype::solvers::ADERDGSolver> aderdgSolver(static_cast<exahype::solvers::ADERDGSolver*>(solver));
  {
  solver = new Euler::EulerSolver_FV(parser.getMaximumMeshSize(0), parser.getMaximumMeshDepth(0), parser.getTimeStepping(0),cmdlineargs);
  }
  std::unique_ptr<exahype::solvers::FiniteVolumesSolver> finiteVolumesSolver(static_cast<exahype::solvers::FiniteVolumesSolver*>(solver));
  
  exahype::solvers::RegisteredSolvers.push_back(
    new exahype::solvers::LimitingADERDGSolver("EulerSolver",std::move(aderdgSolver),std::move(finiteVolumesSolver),parser.getDMPRelaxationParameter(0),parser.getDMPDifferenceScaling(0),parser.getStepsTillCured(0) ));
  parser.checkSolverConsistency(0);
  }

  
  exahype::plotters::RegisteredPlotters.push_back( new exahype::plotters::Plotter(0,0,parser, new Euler::ErrorWriter()) );

  exahype::plotters::RegisteredPlotters.push_back( new exahype::plotters::Plotter(0,1,parser,new Euler::ErrorPlotter(  *static_cast<exahype::solvers::LimitingADERDGSolver*>(exahype::solvers::RegisteredSolvers[0])) ));


  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::initGaussLegendreNodesAndWeights(orders);
  kernels::initGaussLobattoNodesAndWeights(orders);
  kernels::initLimiterProjectionMatrices(orders);
  kernels::initDGMatrices(orders);
  kernels::initBasisFunctions(orders);
}


void kernels::finalise() {
  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::freeGaussLegendreNodesAndWeights(orders);
  kernels::freeGaussLobattoNodesAndWeights(orders);
  kernels::freeLimiterProjectionMatrices(orders);
  kernels::freeDGMatrices(orders);
  kernels::freeBasisFunctions(orders);

  for (auto solver : exahype::solvers::RegisteredSolvers) {
    delete solver;
  }
  exahype::solvers::RegisteredSolvers.clear();

  for (auto plotter : exahype::plotters::RegisteredPlotters) {
    delete plotter;
  }
  exahype::plotters::RegisteredPlotters.clear();
  for (auto coupling : exahype::solvers::RegisteredSolverCouplings) {
    delete coupling;
  }
  exahype::solvers::RegisteredSolverCouplings.clear();
}



void kernels::toString(std::ostream& ostream) {
/* Generated SolverRegistration code by the toolkit */

  ostream << "projectName: Euler\n";
  ostream << "useOptimisedKernels: no\n";
  ostream << "Kernel[0].registration: LimitingAderdgSolver\n";
  ostream << "Kernel[0].type[FV]: Euler::EulerSolver_FV\n";
  ostream << "Kernel[0].type[ADERDG]: Euler::EulerSolver_ADERDG\n";
  ostream << "Kernel[0].abstract[FV]: ";
  Euler::AbstractEulerSolver_FV::constantsToString(ostream);
  ostream << "\n";
  ostream << "Kernel[0].abstract[ADERDG]: ";
  Euler::AbstractEulerSolver_ADERDG::constantsToString(ostream);
  ostream << "\n";
  ostream << "Kernel[0].hasConstants: false\n";
  ostream << "Kernel[0].variables: rho 1 j 3 E 1 \n";
  ostream << "Kernel[0].kernelLimiter: generic::musclhancock\n";
  ostream << "Kernel[0].Plotter[0]: Euler::ErrorWriter(variables=5)\n";
  ostream << "Kernel[0].Plotter[1]: Euler::ErrorPlotter(variables=15)\n";
}


