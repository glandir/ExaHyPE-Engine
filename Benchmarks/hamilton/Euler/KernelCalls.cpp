// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================

#include <sstream>
#include <ostream>
#include "exahype/plotters/Plotter.h"
#include "exahype/profilers/ProfilerFactory.h"
#include "exahype/solvers/Solver.h"
#include "exahype/solvers/SolverCoupling.h"

#include "kernels/KernelCalls.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/GaussLobattoQuadrature.h"
#include "kernels/LimiterProjectionMatrices.h"
#include "kernels/DGMatrices.h"
#include "kernels/DGBasisFunctions.h"
#include "buildinfo.h"

#include "EulerSolver.h"
#include "ErrorWriter.h"
#include "PrimitivesWriter.h"
#include "ExactPrimitivesWriter.h"



void kernels::initSolvers(exahype::Parser& parser, std::vector<std::string>& cmdlineargs) {
  {
  // Create and register solver
  exahype::solvers::RegisteredSolvers.push_back( new Euler::EulerSolver(parser.getMaximumMeshSize(0), parser.getMaximumMeshDepth(0), 0, parser.getTimeStepping(0), cmdlineargs  ));
  parser.checkSolverConsistency(0);

  
  }
  exahype::plotters::RegisteredPlotters.push_back( new exahype::plotters::Plotter(0,0,parser, new Euler::ErrorWriter()) );

  exahype::plotters::RegisteredPlotters.push_back( new exahype::plotters::Plotter(0,1,parser,new Euler::PrimitivesWriter(  *static_cast<Euler::EulerSolver*>(exahype::solvers::RegisteredSolvers[0])) ));

  exahype::plotters::RegisteredPlotters.push_back( new exahype::plotters::Plotter(0,2,parser,new Euler::ExactPrimitivesWriter(  *static_cast<Euler::EulerSolver*>(exahype::solvers::RegisteredSolvers[0])) ));


  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::initGaussLegendreNodesAndWeights(orders);
  kernels::initGaussLobattoNodesAndWeights(orders);
  kernels::initLimiterProjectionMatrices(orders);
  kernels::initDGMatrices(orders);
  kernels::initBasisFunctions(orders);
}


void kernels::finalise() {
  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::freeGaussLegendreNodesAndWeights(orders);
  kernels::freeGaussLobattoNodesAndWeights(orders);
  kernels::freeLimiterProjectionMatrices(orders);
  kernels::freeDGMatrices(orders);
  kernels::freeBasisFunctions(orders);

  for (auto solver : exahype::solvers::RegisteredSolvers) {
    delete solver;
  }
  exahype::solvers::RegisteredSolvers.clear();

  for (auto plotter : exahype::plotters::RegisteredPlotters) {
    delete plotter;
  }
  exahype::plotters::RegisteredPlotters.clear();
  for (auto coupling : exahype::solvers::RegisteredSolverCouplings) {
    delete coupling;
  }
  exahype::solvers::RegisteredSolverCouplings.clear();
}



void kernels::toString(std::ostream& ostream) {
/* Generated SolverRegistration code by the toolkit */

  ostream << "projectName: Euler\n";
  ostream << "useOptimisedKernels: no\n";
  ostream << "Kernel[1].registration: AderdgSolver\n";
  ostream << "Kernel[1].type: Euler::EulerSolver\n";
  ostream << "Kernel[1].parent: ";
  Euler::AbstractEulerSolver::constantsToString(ostream);
  ostream << "\n";
  ostream << "Kernel[1].hasConstants: false\n";
  ostream << "Kernel[0].Plotter[0]: Euler::ErrorWriter\n";
  ostream << "Kernel[0].Plotter[1]: Euler::PrimitivesWriter\n";
  ostream << "Kernel[0].Plotter[2]: Euler::ExactPrimitivesWriter\n";
}


