// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "AbstractElasticWaveEquation.h"

#include "kernels/aderdg/generic/Kernels.h"

#include "ElasticWaveEquation.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include <stdio.h>

// We define the constructor of the actual solver here in order to regenerate it easily.
ElasticWaveEquation3D::ElasticWaveEquation::ElasticWaveEquation(double maximumMeshSize,int maximumAdaptiveMeshDepth,int DMPObservables,int limiterHelperLayers,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs):
  AbstractElasticWaveEquation::AbstractElasticWaveEquation(maximumMeshSize,maximumAdaptiveMeshDepth,DMPObservables,limiterHelperLayers,timeStepping) {
  init(cmdlineargs);
}


ElasticWaveEquation3D::AbstractElasticWaveEquation::AbstractElasticWaveEquation(double maximumMeshSize,int maximumAdaptiveMeshDepth,int DMPObservables,int limiterHelperLayers,exahype::solvers::Solver::TimeStepping timeStepping):
  exahype::solvers::ADERDGSolver("ElasticWaveEquation",NumberOfVariables,NumberOfParameters,Order+1,
                                 maximumMeshSize,maximumAdaptiveMeshDepth,DMPObservables,limiterHelperLayers,timeStepping) {
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::constantsToString(std::ostream& os) {
	// This string is used in the --version output to identify compile time constants
	os << "ElasticWaveEquation3D::AbstractElasticWaveEquation("
	   << "nVar=" << NumberOfVariables << ", "
	   << "nParam=" << NumberOfParameters << ", "
	   << "Order=" << Order
	   << ")";
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::abortWithMsg(const char* const msg) {
	// verbosily fail even without assertions turned on
	puts(msg);
	abort();
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::spaceTimePredictor(double* lQhbnd,double* lFhbnd,double** tempSpaceTimeUnknowns,double** tempSpaceTimeFluxUnknowns,double* tempUnknowns,double* tempFluxUnknowns,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt, double** tempPointForceSources) {
  kernels::aderdg::generic::c::spaceTimePredictorLinear<true, true, true, true, true, ElasticWaveEquation>(*static_cast<ElasticWaveEquation*>(this), lQhbnd, lFhbnd, tempSpaceTimeUnknowns, tempSpaceTimeFluxUnknowns, tempUnknowns, tempFluxUnknowns, luh, dx, dt, tempPointForceSources);
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::solutionUpdate(double* luh,const double* const lduh,const double dt) {
  kernels::aderdg::generic::c::solutionUpdate<ElasticWaveEquation>(*static_cast<ElasticWaveEquation*>(this),luh,lduh,dt);
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::volumeIntegral(double* lduh,const double* const lFi,const double* const lFhi,const tarch::la::Vector<DIMENSIONS,double>& dx) {
  kernels::aderdg::generic::c::volumeIntegralLinear<true, true, NumberOfVariables, Order+1>(lduh,lFhi,dx);
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::surfaceIntegral(double* lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& dx) {
  kernels::aderdg::generic::c::surfaceIntegralLinear<NumberOfVariables, Order+1>(lduh,lFhbnd,dx);
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::riemannSolver(double* FL,double* FR,const double* const QL,const double* const QR,const double dt,const int normalNonZeroIndex,bool isBoundaryFace, int faceIndex) {
  assertion2(normalNonZeroIndex>=0,dt,normalNonZeroIndex);
  assertion2(normalNonZeroIndex<DIMENSIONS,dt,normalNonZeroIndex);
    kernels::aderdg::generic::c::riemannSolverLinear<true,true,true,ElasticWaveEquation>(*static_cast<ElasticWaveEquation*>(this),FL,FR,QL,QR,dt,normalNonZeroIndex);
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::boundaryConditions(double* fluxOut,double* stateOut,const double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {
  kernels::aderdg::generic::c::boundaryConditions<ElasticWaveEquation>(*static_cast<ElasticWaveEquation*>(this),fluxOut,stateOut,fluxIn,stateIn,cellCentre,cellSize,t,dt,faceIndex,normalNonZero);
}

double ElasticWaveEquation3D::AbstractElasticWaveEquation::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx) {
  double d = kernels::aderdg::generic::c::stableTimeStepSize<ElasticWaveEquation>(*static_cast<ElasticWaveEquation*>(this),luh,dx);
  return d;
}


void ElasticWaveEquation3D::AbstractElasticWaveEquation::faceUnknownsProlongation(double* lQhbndFine,double* lFhbndFine,const double* lQhbndCoarse,const double* lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
  kernels::aderdg::generic::c::faceUnknownsProlongation<NumberOfVariables,NumberOfParameters,Order+1>(lQhbndFine,lFhbndFine,lQhbndCoarse,lFhbndCoarse,coarseGridLevel,fineGridLevel,subfaceIndex);
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::faceUnknownsRestriction(double* lQhbndCoarse,double* lFhbndCoarse,const double* lQhbndFine,const double* lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
  kernels::aderdg::generic::c::faceUnknownsRestriction<NumberOfVariables,NumberOfParameters,Order+1>(lQhbndCoarse,lFhbndCoarse,lQhbndFine,lFhbndFine,coarseGridLevel,fineGridLevel,subfaceIndex);
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::volumeUnknownsProlongation(double* luhFine,const double* luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
  kernels::aderdg::generic::c::volumeUnknownsProlongation<NumberOfVariables,NumberOfParameters,Order+1>(luhFine,luhCoarse,coarseGridLevel,fineGridLevel,subcellIndex);
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::volumeUnknownsRestriction(double* luhCoarse,const double* luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
  kernels::aderdg::generic::c::volumeUnknownsRestriction<NumberOfVariables,NumberOfParameters,Order+1>(luhCoarse,luhFine,coarseGridLevel,fineGridLevel,subcellIndex);
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::deltaDistribution(const double t,const double dt, const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx, double** tempPointForceSources) {
  kernels::aderdg::generic::c::deltaDistribution<ElasticWaveEquation>(*static_cast<ElasticWaveEquation*>(this), t, dt, center, dx,getNodesPerCoordinateAxis(), tempPointForceSources);
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::flux(const double* const Q,double** F) {
      abortWithMsg("flux: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::algebraicSource(const double* const Q,double* S) {
      abortWithMsg("algebraicSource: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}
        
void ElasticWaveEquation3D::AbstractElasticWaveEquation::nonConservativeProduct(const double* const Q,const double* const gradQ,double* BgradQ) {
      abortWithMsg("nonConservativeProduct: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void ElasticWaveEquation3D::AbstractElasticWaveEquation::pointSource(const double* const x,const double t,const double dt, double* forceVector, double* x0, int n) {
      abortWithMsg("pointSource: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

/**
 * Fallback implementations of joined functions. Users can either safely ignore this
 * or overwrite with their own implementations.
 **/
#include "kernels/fusedMethods.cpph"
