// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#ifndef __ElasticWaveEquation_Variables_CLASS_HEADER__
#define __ElasticWaveEquation_Variables_CLASS_HEADER__

#include "AbstractElasticWaveEquation.h"

#include <algorithm>

#include "tarch/la/Matrix.h"

/**
 * Generic information about the variable string as it was declared in the
 * specification file
 **/
struct ElasticWaveEquation3D::AbstractElasticWaveEquation::VariableMetrics {
  static constexpr int numDistinctVariables = 2;
  static constexpr int SizeVariables = 9; 
  static constexpr int SizeParameters = 16;
  static constexpr int Size           = 9+16;
  static constexpr int Dimensions    = DIMENSIONS;
};

/**
 * Positions of fields in the vector of unkonwns.
 *
 * With these constants, you can write Q[g11], Q[K22] and Q[B33] instead of
 * Q[0], Q[9] and Q[34]. Your code is meaningful in terms of physics while
 * you still access on a C-array level.
 *
 * You might want to use a typedef to shorten the notation or create 
 * an instance of this class.
 **/
class ElasticWaveEquation3D::AbstractElasticWaveEquation::VariableShortcuts : public ElasticWaveEquation3D::AbstractElasticWaveEquation::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
  int _Q[numDistinctVariables + 1] = { 0, 3, -1 };

  const int     v = 0;
  const int sigma = 3;


  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableShortcuts

/**
 * Lengths (multplicities) of each field inside the unknown vector Q.
 * For instance, 0 means "scalar field" while any value >0 may mean a vector field or
 * even a "linearized" tensor field
 **/
class ElasticWaveEquation3D::AbstractElasticWaveEquation::VariableMultiplicities : public ElasticWaveEquation3D::AbstractElasticWaveEquation::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
  int _Q[numDistinctVariables + 1] = { 3, 6, -1 };

  const int     v = 3;
  const int sigma = 6;


  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableMultiplicities

/**
 * Variable names as strings as given in the toolkit.
 * 
 * These names might want to be used for plotting, output, etc.
 *
 **/
class ElasticWaveEquation3D::AbstractElasticWaveEquation::VariableNames : public ElasticWaveEquation3D::AbstractElasticWaveEquation::VariableMetrics {
public:
  char const *_Q[numDistinctVariables + 1] = { "v", "sigma", nullptr };

  const char*     v = "v";
  const char* sigma = "sigma";


  const char* const* asArray() const { return _Q; } // type: whatever
  const char* operator [] (int index) const { return _Q[index]; }
  const char* operator () (int index) const { return _Q[index]; }
}; // end of VariableNames

/**
 * Positions of fields in the vector of unknowns,
 * available as namespace constants.
 * 
 * You can use this namespace similar to the class "VariableShortcuts"
 * but you don't need an object, ie. your notation can get slimmer.
 * 
 * Usage is like:
 * 
 *    void somewhere() {
 *       using namespace ElasticWaveEquation3D::ElasticWaveEquation_Variables::shortcuts;
 *       Q[foo] = 17;
 *    }
 *
 * instead of
 * 
 *    void somewhere() {
 *       ElasticWaveEquation3D::AbstractElasticWaveEquation::VariableNames q;
 *       Q[q.foo] = 17;
 *    }
 *
 **/
namespace ElasticWaveEquation3D {
	namespace ElasticWaveEquation_Variables {
		namespace shortcuts {
			  constexpr int     v = 0;
  constexpr int sigma = 3;

		} // namespace shortcuts
		namespace names {
			  constexpr char     v[] = "v";
  constexpr char sigma[] = "sigma";

		} // namespace names
	} // end of namespace ElasticWaveEquation3D::ElasticWaveEquation_Variables 
} // end of namespace ElasticWaveEquation3D

/*
 * Another class idea:
 * 
 * class ....::VariablePointers {
 *   private:   double* Q;
 *   public:
 *      double &varfoo;
 *      double &varbar;
 *      VariablePointers(double*Q) : varfoo(Q[0]), bar(Q[1]), ... {}
 * }
 * 
 * Advantages: Use as positions in Q.
 *
 */


class ElasticWaveEquation3D::AbstractElasticWaveEquation::ReadOnlyVariables : public ElasticWaveEquation3D::AbstractElasticWaveEquation::VariableMetrics {
  private:
    const double* const _Q;
  public:
    ReadOnlyVariables(const double* const Q) : _Q(Q) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    const double* data() const {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // Java-generated code for VariablesGetters:

    double v(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[0+index];
    }

    tarch::la::Vector<3,double> v() const {
      tarch::la::Vector<3,double> values;
      values=_Q[0],_Q[1],_Q[2];
      return values;
    }

    double sigma(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[3+index];
    }

    tarch::la::Vector<6,double> sigma() const {
      tarch::la::Vector<6,double> values;
      values=_Q[3],_Q[4],_Q[5],_Q[6],_Q[7],_Q[8];
      return values;
    }

    double rho() const { return _Q[9]; }

    double c(int index) const {
      assertion(index >= 0 && index<2);
      return _Q[10+index];
    }

    tarch::la::Vector<2,double> c() const {
      tarch::la::Vector<2,double> values;
      values=_Q[10],_Q[11];
      return values;
    }

    double jacobian() const { return _Q[12]; }

    double metric_derivative(int index) const {
      assertion(index >= 0 && index<9);
      return _Q[13+index];
    }

    tarch::la::Vector<9,double> metric_derivative() const {
      tarch::la::Vector<9,double> values;
      values=_Q[13],_Q[14],_Q[15],_Q[16],_Q[17],_Q[18],_Q[19],_Q[20],_Q[21];
      return values;
    }

    double curve_grid(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[22+index];
    }

    tarch::la::Vector<3,double> curve_grid() const {
      tarch::la::Vector<3,double> values;
      values=_Q[22],_Q[23],_Q[24];
      return values;
    }


}; // end of ReadOnlyVariables


class ElasticWaveEquation3D::AbstractElasticWaveEquation::Variables : public ElasticWaveEquation3D::AbstractElasticWaveEquation::VariableMetrics{
  private:
    double* _Q;
  public:
    static constexpr int SizeVariables  = 9;
    static constexpr int SizeParameters = 16;
    static constexpr int Size           = 9+16;
  
    Variables(double* Q) : _Q(Q) {}
    
    void operator = (Variables& variables) {
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    void operator = (ReadOnlyVariables& variables) {
      assertion(variables.variables()==SizeVariables);
      assertion(variables.parameters()==SizeParameters);
      assertion(variables.size()==Size);
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double* data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // Java-generated code for VariablesGetters:

    double v(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[0+index];
    }

    tarch::la::Vector<3,double> v() const {
      tarch::la::Vector<3,double> values;
      values=_Q[0],_Q[1],_Q[2];
      return values;
    }

    double sigma(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[3+index];
    }

    tarch::la::Vector<6,double> sigma() const {
      tarch::la::Vector<6,double> values;
      values=_Q[3],_Q[4],_Q[5],_Q[6],_Q[7],_Q[8];
      return values;
    }

    double rho() const { return _Q[9]; }

    double c(int index) const {
      assertion(index >= 0 && index<2);
      return _Q[10+index];
    }

    tarch::la::Vector<2,double> c() const {
      tarch::la::Vector<2,double> values;
      values=_Q[10],_Q[11];
      return values;
    }

    double jacobian() const { return _Q[12]; }

    double metric_derivative(int index) const {
      assertion(index >= 0 && index<9);
      return _Q[13+index];
    }

    tarch::la::Vector<9,double> metric_derivative() const {
      tarch::la::Vector<9,double> values;
      values=_Q[13],_Q[14],_Q[15],_Q[16],_Q[17],_Q[18],_Q[19],_Q[20],_Q[21];
      return values;
    }

    double curve_grid(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[22+index];
    }

    tarch::la::Vector<3,double> curve_grid() const {
      tarch::la::Vector<3,double> values;
      values=_Q[22],_Q[23],_Q[24];
      return values;
    }



    // Java-generated code for VariablesSetters:

    double& v(int index) { return _Q[0+index]; }

    void v(const tarch::la::Vector<3,double>& values) {
      *(_Q+0)=values[0];
      *(_Q+1)=values[1];
      *(_Q+2)=values[2];
    }

    void v(double v0,double v1,double v2) {
      *(_Q+0)=v0;
      *(_Q+1)=v1;
      *(_Q+2)=v2;
    }

    double& sigma(int index) { return _Q[3+index]; }

    void sigma(const tarch::la::Vector<6,double>& values) {
      *(_Q+3)=values[0];
      *(_Q+4)=values[1];
      *(_Q+5)=values[2];
      *(_Q+6)=values[3];
      *(_Q+7)=values[4];
      *(_Q+8)=values[5];
    }

    void sigma(double sigma0,double sigma1,double sigma2,double sigma3,double sigma4,double sigma5) {
      *(_Q+3)=sigma0;
      *(_Q+4)=sigma1;
      *(_Q+5)=sigma2;
      *(_Q+6)=sigma3;
      *(_Q+7)=sigma4;
      *(_Q+8)=sigma5;
    }

    double& rho() { return _Q[9]; }

    double& c(int index) { return _Q[10+index]; }

    void c(const tarch::la::Vector<2,double>& values) {
      *(_Q+10)=values[0];
      *(_Q+11)=values[1];
    }

    void c(double c0,double c1) {
      *(_Q+10)=c0;
      *(_Q+11)=c1;
    }

    double& jacobian() { return _Q[12]; }

    double& metric_derivative(int index) { return _Q[13+index]; }

    void metric_derivative(const tarch::la::Vector<9,double>& values) {
      *(_Q+13)=values[0];
      *(_Q+14)=values[1];
      *(_Q+15)=values[2];
      *(_Q+16)=values[3];
      *(_Q+17)=values[4];
      *(_Q+18)=values[5];
      *(_Q+19)=values[6];
      *(_Q+20)=values[7];
      *(_Q+21)=values[8];
    }

    void metric_derivative(double metric_derivative0,double metric_derivative1,double metric_derivative2,double metric_derivative3,double metric_derivative4,double metric_derivative5,double metric_derivative6,double metric_derivative7,double metric_derivative8) {
      *(_Q+13)=metric_derivative0;
      *(_Q+14)=metric_derivative1;
      *(_Q+15)=metric_derivative2;
      *(_Q+16)=metric_derivative3;
      *(_Q+17)=metric_derivative4;
      *(_Q+18)=metric_derivative5;
      *(_Q+19)=metric_derivative6;
      *(_Q+20)=metric_derivative7;
      *(_Q+21)=metric_derivative8;
    }

    double& curve_grid(int index) { return _Q[22+index]; }

    void curve_grid(const tarch::la::Vector<3,double>& values) {
      *(_Q+22)=values[0];
      *(_Q+23)=values[1];
      *(_Q+24)=values[2];
    }

    void curve_grid(double curve_grid0,double curve_grid1,double curve_grid2) {
      *(_Q+22)=curve_grid0;
      *(_Q+23)=curve_grid1;
      *(_Q+24)=curve_grid2;
    }


}; // end of Variables


class ElasticWaveEquation3D::AbstractElasticWaveEquation::Fluxes : public ElasticWaveEquation3D::AbstractElasticWaveEquation::VariableMetrics {
  private:
    double** _F;
  public:
    Fluxes(double** F) : _F(F) {}
    
    /** The rows of the flux tensor. */
    int variables() const {
      return SizeVariables;
    }
    
    /** The columns of the flux tensor. */
    int dimensions() const {
      return Dimensions;
    }


    // Java-generated code for FluxGetters:

    double v(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0+row];
    }

    tarch::la::Vector<DIMENSIONS,double> v(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0+row],_F[1][0+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0+row],_F[1][0+row],_F[2][0+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<3,DIMENSIONS,double> v() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][0],_F[1][0],
               _F[0][1],_F[1][1],
               _F[0][2],_F[1][2];
      #elif DIMENSIONS==3
      values = _F[0][0],_F[1][0],
               _F[0][1],_F[1][1],
               _F[0][2],_F[1][2];
      #endif
      return values;
    }

    double sigma(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][3+row];
    }

    tarch::la::Vector<DIMENSIONS,double> sigma(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][3+row],_F[1][3+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][3+row],_F[1][3+row],_F[2][3+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<6,DIMENSIONS,double> sigma() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][3],_F[1][3],
               _F[0][4],_F[1][4],
               _F[0][5],_F[1][5],
               _F[0][6],_F[1][6],
               _F[0][7],_F[1][7],
               _F[0][8],_F[1][8];
      #elif DIMENSIONS==3
      values = _F[0][3],_F[1][3],
               _F[0][4],_F[1][4],
               _F[0][5],_F[1][5],
               _F[0][6],_F[1][6],
               _F[0][7],_F[1][7],
               _F[0][8],_F[1][8];
      #endif
      return values;
    }



    // Java-generated code for FluxSetters:

    double& v(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0+row];
    }

    void v(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][0+row]=values[0];
      _F[1][0+row]=values[1];
      #if DIMENSIONS==2
      _F[2][0+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void v(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<3);
      _F[0][0+row]=values[0];
      _F[1][0+row]=values[1];
    }
    #endif

    void v(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][0]=values(0,0);
      _F[0][1]=values(1,0);
      _F[0][2]=values(2,0);
      _F[1][0]=values(0,1);
      _F[1][1]=values(1,1);
      _F[1][2]=values(2,1);
      #if DIMENSIONS==3
      _F[2][0]=values(0,2);
      _F[2][1]=values(1,2);
      _F[2][2]=values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void v(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][0]=values(0,0);
      _F[0][1]=values(1,0);
      _F[0][2]=values(2,0);
      _F[1][0]=values(0,1);
      _F[1][1]=values(1,1);
      _F[1][2]=values(2,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void v(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][0+row]=v0;
      _F[1][0+row]=v1;
      #if DIMENSIONS==3
      _F[2][0+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void v(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][0+row]=v0;
      _F[1][0+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void v(double v00, double v01, double v02,
           double v10, double v11, double v12,
           double v20, double v21, double v22) {
      _F[0][0]=v00;
      _F[0][1]=v10;
      _F[0][2]=v20;
      _F[1][0]=v01;
      _F[1][1]=v11;
      _F[1][2]=v21;
      #if DIMENSIONS==3
      _F[2][0]=v02;
      _F[2][1]=v12;
      _F[2][2]=v22;
      #endif
    }
    #if DIMENSIONS==2
    void v(double v00, double v01,
           double v10, double v11,
           double v20, double v21) {
      _F[0][0]=v00;
      _F[0][1]=v10;
      _F[0][2]=v20;
      _F[1][0]=v01;
      _F[1][1]=v11;
      _F[1][2]=v21;
    }
    #endif

    double& sigma(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][3+row];
    }

    void sigma(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][3+row]=values[0];
      _F[1][3+row]=values[1];
      #if DIMENSIONS==2
      _F[2][3+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void sigma(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<6);
      _F[0][3+row]=values[0];
      _F[1][3+row]=values[1];
    }
    #endif

    void sigma(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][3]=values(0,0);
      _F[0][4]=values(1,0);
      _F[0][5]=values(2,0);
      _F[0][6]=values(3,0);
      _F[0][7]=values(4,0);
      _F[0][8]=values(5,0);
      _F[1][3]=values(0,1);
      _F[1][4]=values(1,1);
      _F[1][5]=values(2,1);
      _F[1][6]=values(3,1);
      _F[1][7]=values(4,1);
      _F[1][8]=values(5,1);
      #if DIMENSIONS==3
      _F[2][3]=values(0,2);
      _F[2][4]=values(1,2);
      _F[2][5]=values(2,2);
      _F[2][6]=values(3,2);
      _F[2][7]=values(4,2);
      _F[2][8]=values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void sigma(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][3]=values(0,0);
      _F[0][4]=values(1,0);
      _F[0][5]=values(2,0);
      _F[0][6]=values(3,0);
      _F[0][7]=values(4,0);
      _F[0][8]=values(5,0);
      _F[1][3]=values(0,1);
      _F[1][4]=values(1,1);
      _F[1][5]=values(2,1);
      _F[1][6]=values(3,1);
      _F[1][7]=values(4,1);
      _F[1][8]=values(5,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void sigma(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][3+row]=v0;
      _F[1][3+row]=v1;
      #if DIMENSIONS==3
      _F[2][3+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void sigma(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][3+row]=v0;
      _F[1][3+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void sigma(double v00, double v01, double v02,
               double v10, double v11, double v12,
               double v20, double v21, double v22,
               double v30, double v31, double v32,
               double v40, double v41, double v42,
               double v50, double v51, double v52) {
      _F[0][3]=v00;
      _F[0][4]=v10;
      _F[0][5]=v20;
      _F[0][6]=v30;
      _F[0][7]=v40;
      _F[0][8]=v50;
      _F[1][3]=v01;
      _F[1][4]=v11;
      _F[1][5]=v21;
      _F[1][6]=v31;
      _F[1][7]=v41;
      _F[1][8]=v51;
      #if DIMENSIONS==3
      _F[2][3]=v02;
      _F[2][4]=v12;
      _F[2][5]=v22;
      _F[2][6]=v32;
      _F[2][7]=v42;
      _F[2][8]=v52;
      #endif
    }
    #if DIMENSIONS==2
    void sigma(double v00, double v01,
               double v10, double v11,
               double v20, double v21,
               double v30, double v31,
               double v40, double v41,
               double v50, double v51) {
      _F[0][3]=v00;
      _F[0][4]=v10;
      _F[0][5]=v20;
      _F[0][6]=v30;
      _F[0][7]=v40;
      _F[0][8]=v50;
      _F[1][3]=v01;
      _F[1][4]=v11;
      _F[1][5]=v21;
      _F[1][6]=v31;
      _F[1][7]=v41;
      _F[1][8]=v51;
    }
    #endif


}; // end of Fluxes

// NamingSchemes:


#endif
