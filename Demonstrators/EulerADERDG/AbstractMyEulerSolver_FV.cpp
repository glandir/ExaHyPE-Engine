// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include "AbstractMyEulerSolver_FV.h"

#include "kernels/finitevolumes/commons/c/commons.h"
#include "kernels/finitevolumes/godunov/c/godunov.h"
#include "kernels/finitevolumes/riemannsolvers/c/riemannsolvers.h"

#include "MyEulerSolver_FV.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include <stdio.h>
#include <cstdlib> // abort()
#include "kernels/KernelUtils.h" // idx

#include "exahype/disableOptimization.h" // we experience compiler bugs sometimes.

EulerADERDG::MyEulerSolver_FV::MyEulerSolver_FV(const double maximumMeshSize,const exahype::solvers::Solver::TimeStepping timeStepping):
  AbstractMyEulerSolver_FV::AbstractMyEulerSolver_FV(maximumMeshSize,timeStepping) {
}

EulerADERDG::AbstractMyEulerSolver_FV::AbstractMyEulerSolver_FV(const double maximumMeshSize,const exahype::solvers::Solver::TimeStepping timeStepping):
  exahype::solvers::FiniteVolumesSolver("MyEulerSolver_FV",NumberOfVariables,NumberOfParameters,PatchSize,
                                        GhostLayerWidth,maximumMeshSize,timeStepping) {
}

void EulerADERDG::AbstractMyEulerSolver_FV::constantsToString(std::ostream& os) {
	// This string is used in the --version output to identify compile time constants
	os << "EulerADERDG::AbstractMyEulerSolver_FV("
	   << "nVar=" << NumberOfVariables << ", "
	   << "nParam=" << NumberOfParameters << ", "
	   << "PatchSize=" << PatchSize << ", "
	   << "GhostLayerWidth=" << GhostLayerWidth
	   << ")";
}

void EulerADERDG::AbstractMyEulerSolver_FV::abortWithMsg(const char* const msg) {
	// verbosily fail even without assertions turned on
	puts(msg);
	abort();
}

void EulerADERDG::AbstractMyEulerSolver_FV::solutionUpdate(double* const luhNew,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt,double& maxAdmissibleDt) {
  maxAdmissibleDt = kernels::finitevolumes::godunov::c::solutionUpdate<false, false, true, MyEulerSolver_FV>(*static_cast<MyEulerSolver_FV*>(this),luhNew,luh,dx,dt);
}


double EulerADERDG::AbstractMyEulerSolver_FV::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx) {
  double maxAdmissibleDt = kernels::finitevolumes::commons::c::stableTimeStepSize<MyEulerSolver_FV,false>(*static_cast<MyEulerSolver_FV*>(this),luh,dx);
  return maxAdmissibleDt;
}

void EulerADERDG::AbstractMyEulerSolver_FV::adjustSolution(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) {
  kernels::finitevolumes::commons::c::solutionAdjustment<MyEulerSolver_FV>(*static_cast<MyEulerSolver_FV*>(this),luh,center,dx,t,dt);
}

void EulerADERDG::AbstractMyEulerSolver_FV::boundaryConditions(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const tarch::la::Vector<DIMENSIONS, int>& posCell,const tarch::la::Vector<DIMENSIONS, int>& posBoundary) {
  constexpr int cellsPerFace = PatchSize*GhostLayerWidth;
  constexpr int sizeLuhbnd = (NumberOfVariables+NumberOfParameters)*cellsPerFace;
  
  const int indexLuhbndInside        = exahype::DataHeap::getInstance().createData(
       sizeLuhbnd,sizeLuhbnd,exahype::DataHeap::Allocation::UseRecycledEntriesIfPossibleCreateNewEntriesIfRequired);
  const int indexLuhbndOutside       = exahype::DataHeap::getInstance().createData(
       sizeLuhbnd,sizeLuhbnd,exahype::DataHeap::Allocation::UseRecycledEntriesIfPossibleCreateNewEntriesIfRequired);
  double* luhbndInside               = exahype::DataHeap::getInstance().getData(indexLuhbndInside).data();
  double* luhbndOutside              = exahype::DataHeap::getInstance().getData(indexLuhbndOutside).data();
  
  const int direction   = tarch::la::equalsReturnIndex(posCell, posBoundary);
  const int orientation = (1 + posBoundary(direction) - posCell(direction))/2;
  const int faceIndex   = 2*direction+orientation;
  
  boundaryLayerExtraction(luhbndInside,luh,posBoundary-posCell);
  kernels::finitevolumes::commons::c::boundaryConditions<MyEulerSolver_FV>(*static_cast<MyEulerSolver_FV*>(this),luhbndOutside,luhbndInside,cellCentre,cellSize,t,dt,faceIndex,direction);
  ghostLayerFillingAtBoundary(luh,luhbndOutside,posBoundary-posCell);
  
  exahype::DataHeap::getInstance().deleteData(indexLuhbndInside,true);
  exahype::DataHeap::getInstance().deleteData(indexLuhbndOutside,true);
}


void EulerADERDG::AbstractMyEulerSolver_FV::ghostLayerFilling(double* const luh,const double* const luhNeighbour,const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) {
  kernels::finitevolumes::commons::c::ghostLayerFilling<MyEulerSolver_FV>(*static_cast<MyEulerSolver_FV*>(this),luh,luhNeighbour,neighbourPosition);
}

void EulerADERDG::AbstractMyEulerSolver_FV::ghostLayerFillingAtBoundary(double* const luh,const double* const luhbnd,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::commons::c::ghostLayerFillingAtBoundary<MyEulerSolver_FV>(*static_cast<MyEulerSolver_FV*>(this),luh,luhbnd,boundaryPosition);
}

void EulerADERDG::AbstractMyEulerSolver_FV::boundaryLayerExtraction(double* const luhbnd,const double* const luh,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::commons::c::boundaryLayerExtraction<MyEulerSolver_FV>(*static_cast<MyEulerSolver_FV*>(this),luhbnd,luh,boundaryPosition);
}


double EulerADERDG::AbstractMyEulerSolver_FV::riemannSolver(double* const fL, double* const fR, const double* const qL, const double* const qR, int direction) {
  // Default FV Riemann Solver
  return kernels::finitevolumes::riemannsolvers::c::rusanov<false, true, false, MyEulerSolver_FV>(*static_cast<MyEulerSolver_FV*>(this), fL,fR,qL,qR,direction);
}


/**
 * Fallback implementations of joined functions. Users can either safely ignore this
 * or overwrite with their own implementations.
 **/
 // @todo Can we remove this one?
#include "kernels/fusedMethods.cpph"