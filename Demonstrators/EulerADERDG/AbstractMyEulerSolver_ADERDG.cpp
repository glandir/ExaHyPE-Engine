// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "AbstractMyEulerSolver_ADERDG.h"

#include "kernels/aderdg/generic/Kernels.h"

#include "MyEulerSolver_ADERDG.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include <stdio.h>

// We define the constructor of the actual solver here in order to regenerate it easily.
EulerADERDG::MyEulerSolver_ADERDG::MyEulerSolver_ADERDG(
  const double maximumMeshSize,
  const int maximumMeshDepth,
  const int haloCells,
  const int regularisedFineGridLevels,
  const exahype::solvers::Solver::TimeStepping timeStepping,
  const int DMPObservables
)
  :
  AbstractMyEulerSolver_ADERDG::AbstractMyEulerSolver_ADERDG(
      maximumMeshSize,
      maximumMeshDepth,
      haloCells,
      regularisedFineGridLevels,
      timeStepping,
      DMPObservables
) {
}


EulerADERDG::AbstractMyEulerSolver_ADERDG::AbstractMyEulerSolver_ADERDG(
    const double maximumMeshSize,
    const int maximumMeshDepth,
    const int haloCells,
    const int regularisedFineGridLevels,
    const exahype::solvers::Solver::TimeStepping timeStepping,
    const int DMPObservables
)
  :
  exahype::solvers::ADERDGSolver(
      "MyEulerSolver_ADERDG",
      NumberOfVariables,
      NumberOfParameters,
      Order+1,
      maximumMeshSize,
      maximumMeshDepth,
      haloCells,
      regularisedFineGridLevels,
      timeStepping,
      DMPObservables
) {
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::constantsToString(std::ostream& os) {
  // This string is used in the --version output to identify compile time constants
  os << "EulerADERDG::AbstractMyEulerSolver_ADERDG("
     << "nVar=" << NumberOfVariables << ", "
     << "nParam=" << NumberOfParameters << ", "
     << "Order=" << Order
     << ")";
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::abortWithMsg(const char* const msg) {
  // verbosily fail even without assertions turned on
  puts(msg);
  abort();
}

int EulerADERDG::AbstractMyEulerSolver_ADERDG::fusedSpaceTimePredictorVolumeIntegral(double* const lduh, double* const lQhbnd, double* const lFhbnd, const double* const luh, const tarch::la::Vector<DIMENSIONS, double>& center, const tarch::la::Vector<DIMENSIONS, double>& dx, const double t ,const double dt) {
  constexpr int spaceBasisSize     = (Order+1)*(Order+1);
  constexpr int spaceTimeBasisSize = spaceBasisSize*(Order+1);
  constexpr int sizeLQi   = (NumberOfVariables+NumberOfParameters)*spaceTimeBasisSize;
  constexpr int sizeRhs   = sizeLQi;
  constexpr int sizeLFi   = (DIMENSIONS + 1)*NumberOfVariables*spaceTimeBasisSize;
  constexpr int sizeGradQ = DIMENSIONS*NumberOfVariables*spaceBasisSize;
  
  constexpr int sizeLQhi = (NumberOfVariables+NumberOfParameters)*spaceBasisSize;
  constexpr int sizeLFhi = (DIMENSIONS + 1)*NumberOfVariables*spaceBasisSize;

  
  constexpr int totalSize = sizeLQi + sizeRhs + sizeLFi + sizeGradQ +
                        sizeLQhi + sizeLFhi;

  
  double* block = new double[totalSize];
  double* memory = block;
      
  double* lQi   = memory; memory+=sizeLQi;
  double* rhs   = memory; memory+=sizeRhs;
  double* lFi   = memory; memory+=sizeLFi;
  double* gradQ = memory; memory+=sizeGradQ;
  
  double* lQhi = memory; memory+=sizeLQhi;
  double* lFhi = memory; memory+=sizeLFhi;

  const int picardIterations = kernels::aderdg::generic::c::spaceTimePredictorNonlinear<false, true, false, false, false, MyEulerSolver_ADERDG>(*static_cast<MyEulerSolver_ADERDG*>(this), lQhbnd, lFhbnd, lQi, rhs, lFi, gradQ, lQhi, lFhi, luh, tarch::la::invertEntries(dx), dt);
  kernels::aderdg::generic::c::volumeIntegralNonlinear<false, true, false, NumberOfVariables, Order+1>(lduh,lFhi,dx);

  delete[] block;
  return picardIterations;
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::solutionUpdate(double* const luh,const double* const lduh,const double dt) {
  kernels::aderdg::generic::c::solutionUpdate<MyEulerSolver_ADERDG>(*static_cast<MyEulerSolver_ADERDG*>(this),luh,lduh,dt);
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::faceIntegral(double* const lduh,const double* const lFhbnd,const int direction, const int orientation,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex,const int levelDelta,const tarch::la::Vector<DIMENSIONS, double>& cellSize) {
  if ( levelDelta > 0 ) {
    constexpr int basisSize = (Order+1);
    constexpr int sizeFlux  = NumberOfVariables*basisSize;
  
    double* lFhbndCoarse = new double[sizeFlux];
    kernels::aderdg::generic::c::faceUnknownsRestriction<NumberOfVariables,Order+1>(lFhbndCoarse,lFhbnd,subfaceIndex,levelDelta);
    
    tarch::la::Vector<DIMENSIONS,double> coarseGridCellSize = tarch::la::aPowI(levelDelta,3) * 1.0 * cellSize;
    kernels::aderdg::generic::c::faceIntegralNonlinear<NumberOfVariables, Order+1>(lduh,lFhbndCoarse,direction,orientation,coarseGridCellSize);  
    delete[] lFhbndCoarse;
    
  } else {
    kernels::aderdg::generic::c::faceIntegralNonlinear<NumberOfVariables, Order+1>(lduh,lFhbnd,direction,orientation,cellSize);
  }
  
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::riemannSolver(double* const FL,double* const FR,const double* const QL,const double* const QR,const double dt,const int direction,bool isBoundaryFace, int faceIndex) {
  assertion2(direction>=0,dt,direction);
  assertion2(direction<DIMENSIONS,dt,direction);
    kernels::aderdg::generic::c::riemannSolverNonlinear<false,MyEulerSolver_ADERDG>(*static_cast<MyEulerSolver_ADERDG*>(this),FL,FR,QL,QR,dt,direction);
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::boundaryConditions(double* const update, double* const fluxIn,const double* const stateIn,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int direction,const int orientation) {
  constexpr int basisSize     = (Order+1);
  constexpr int sizeStateOut = (NumberOfVariables+NumberOfParameters)*basisSize;
  constexpr int sizeFluxOut  = NumberOfVariables*basisSize;
  
  constexpr int totalSize = sizeStateOut + sizeFluxOut;
  
  double* block = new double[totalSize];
  double* memory = block;

  double* stateOut = memory; memory+=sizeStateOut;
  double* fluxOut  = memory; memory+=sizeFluxOut;

  const int faceIndex = 2*direction+orientation;
  
  kernels::aderdg::generic::c::boundaryConditions<MyEulerSolver_ADERDG>(*static_cast<MyEulerSolver_ADERDG*>(this),fluxOut,stateOut,fluxIn,stateIn,cellCentre,cellSize,t,dt,faceIndex,direction);
  if ( orientation==0 ) {
    double* FL = fluxOut; const double* const QL = stateOut;
    double* FR = fluxIn;  const double* const QR = stateIn;
  
    riemannSolver(FL,FR,QL,QR,dt,direction,true,faceIndex);
  
    kernels::aderdg::generic::c::faceIntegralNonlinear<NumberOfVariables, Order+1>(update,fluxIn,direction,orientation,cellSize);
  }
  else {
    double* FL = fluxIn;  const double* const QL = stateIn;
    double* FR = fluxOut; const double* const QR = stateOut;

    riemannSolver(FL,FR,QL,QR,dt,direction,true,faceIndex);
    
    kernels::aderdg::generic::c::faceIntegralNonlinear<NumberOfVariables, Order+1>(update,fluxIn,direction,orientation,cellSize);
  }
  delete[] block;
}

double EulerADERDG::AbstractMyEulerSolver_ADERDG::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx) {
  double d = kernels::aderdg::generic::c::stableTimeStepSize<MyEulerSolver_ADERDG,false>(*static_cast<MyEulerSolver_ADERDG*>(this),luh,dx);
  return d;
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::adjustSolution(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) {
  kernels::aderdg::generic::c::solutionAdjustment<MyEulerSolver_ADERDG>(*static_cast<MyEulerSolver_ADERDG*>(this),luh,center,dx,t,dt);
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::faceUnknownsProlongation(double* const lQhbndFine,double* const lFhbndFine,const double* const lQhbndCoarse,const double* const lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
  kernels::aderdg::generic::c::faceUnknownsProlongation<NumberOfVariables,NumberOfParameters,Order+1>(lQhbndFine,lFhbndFine,lQhbndCoarse,lFhbndCoarse,coarseGridLevel,fineGridLevel,subfaceIndex);
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::volumeUnknownsProlongation(double* const luhFine,const double* const luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
  kernels::aderdg::generic::c::volumeUnknownsProlongation<NumberOfVariables,NumberOfParameters,Order+1>(luhFine,luhCoarse,coarseGridLevel,fineGridLevel,subcellIndex);
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::volumeUnknownsRestriction(double* const luhCoarse,const double* const luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
  kernels::aderdg::generic::c::volumeUnknownsRestriction<NumberOfVariables,NumberOfParameters,Order+1>(luhCoarse,luhFine,coarseGridLevel,fineGridLevel,subcellIndex);
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::flux(const double* const Q,double** const F) {
      abortWithMsg("flux: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::viscousFlux(const double* const Q,const double* const gradQ, double** const F) {
      abortWithMsg("viscous flux: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::viscousEigenvalues(const double* const Q,const int d,double* const lambda) {
      abortWithMsg("viscous eigenvalues: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::algebraicSource(const double* const Q,double* const S) {
      abortWithMsg("algebraicSource: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}
        
void EulerADERDG::AbstractMyEulerSolver_ADERDG::nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) {
      abortWithMsg("nonConservativeProduct: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void EulerADERDG::AbstractMyEulerSolver_ADERDG::pointSource(const double* const Q,const double* const x,const double t,const double dt, double* const forceVector,int n) {
      abortWithMsg("pointSource: If this operation is entered, you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

/**
 * Fallback implementations of joined functions. Users can either safely ignore this
 * or overwrite with their own implementations.
 **/
#include "kernels/fusedMethods.cpph"