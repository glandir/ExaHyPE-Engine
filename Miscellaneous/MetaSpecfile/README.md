# The ExaHyPE meta specfile language

This directory holds the exahype meta specfile language, also abbreveated
as `exapar` (exahype parameter files) or `mexa`.

Small example (kitchen sink):

```
# arbitrarily structured parameters
ExaHyPE::project::name = "GRMHD"
ExaHyPE::paths::peano_kernel_path = "./Peano"
ExaHyPE::architecture = "noarch"
ExaHyPE::logfile = "whatever.log"

Solver::type = "Finite-Volumes"
Solver::patch-size = 8

BasePlotter::time = 0.0
BasePlotter::repeat = 0.001
Paths::output_folder = "./vtk-output"

# inheritance:
IntegralPlotter <= BasePlotter
IntegralPlotter::output = "@{Paths/output_folder}/foo.txt"

# include files:
Solver::plotter_list << "solver-list.txt"

# lists
Domain::exclude  = "left"
Domain::exclude += "right"
Domain::exclude += "top"

# references
ExaHyPE::Solver = Solver
ExaHyPE::plotter_list = Solver::plotter_list

# hierarchies: "Parameters" gets three children
Parameters += ExaHyPE
Parameters += Domain
Parameters += IntegralPlotter
```

## Usage

The `mexa.py` reference implementation serves as a swiss army knife
to convert between the mexa file format and something else. We support
the creation of both *JSON* and *YAML* and both *structured* and *flat*
output files. Here, *structured* means that a nested dictioniary structure
is created while *flat* means the parameters are in one long list.

Thanks to JSON, one can for instance use the `jq` query tool to write
Queries to ask for certain values in the parameter file (*todo: examples*).

Of course, also ExaHyPE specification files can be generated. We either
propose to *serialize* (i.e. embed) the extensive parameters which can
not be stored in ExaHyPE in certain specfile fields or to let a trimmed
down Mexa file go along a specification file.

In any case, we probably want to write a simple C parser for Mexa parameters.

Mexa can also dump an *evaluated* version of the Mexa files where all
operations *except* the assignment where carried out, including string
variable substitution. Thus, the remaining Mexa file format can be parsed
trivially line by line without taking any logic into account.

## Concepts at a glance:

 * Every command is always a single line.
 * All assignments are immutable (pi=3.14 is always 3.14)
 * The order of the lines is interchangable.
 * Variables can be sorted hierarchically.
 * Native support for Int, Float, String
 * Symbolic/Lazy variables: References can always be put.
 * Principle of least surprise: Always does what is expected.

### Principles, from top down

 * Variables can be sorted hierarchically. The seperator is
   either "/" or "::". Hierarchy can just be used as it occurs
   without previous definition.
 * Lists can be composed with "+=" over several lines.
 * Inline variables in strings can be evaluated. For instance,
   in "foo @bar baz", @bar is replaced by the variable "bar".
   For more complex names, "@{name::too:foo}bar" is evaluated
   accordingly.

### Principles, from bottom up:

 * All variables live on a hierarchy. No prefix means root.
 * There are only five commands:
   1. The immutable assignment `a = b`
   2. The list creation (appending): `a += b`
   3. Datastructure extension (inheritance): `a <= b`
   4. Inclusion of files at any level: `a << b`
   5. The overwritable (non-immutable) assignment `a := b`

## Rationale

ExaHyPE ships with a sophisticated specification language, defined by its
own grammar. Two distinct parsers are implemented, a fuzzy C parser and
a full Java parser generated by SableCC.

However, this language is hard to parse and compose. It is also not
extensible at all. User parameters can hardly be specified.

Therefore, we propose here a language which compiles to ExaHyPE specification
files plus parameters which cannot be mapped to the ExaHyPE specfiles.

### Design of an ExaHyPE specfile

The ExaHyPE specification language can be approximated as an XMLish
structure,

```
begin section unnamed-parameter1 unnamed-parameter2
   assignment1 decorator = right hand side
   assignment2 decorator = right hand side
   assignment3 decorator = weird:embedded,lists:here
   assignment4 decorator = {which:sometimes,are:enclosed}
end section
```

This can be mapped for instance onto an XML ontology

```
<section some-name1="unnamed-parameter1" some-name2="unnamed-parameter2">
   <assignment1 some-name="decorator">right hand side</assignemnt1>
   <assignment2 some-name="decorator">right hand side</assignemnt2>
   <assignment3 some-name="decorator">weird:embedded,lists:here</assignemnt3>
   <assignment3 some-name="decorator">{which:sometimes,are:enclosed}</assignemnt3>
</section>
```

That is, we would need a node tree, text leafs and attributes to describe an
ExaHyPe specfile. We don't take the weird embedded lists into account.

Note that in XML, the order of the tags is relevant. The same is true for the
ExaHyPE specfiles. This is a quite weird decision in parameter file formats.

### The Mexa approach

Mexa can represent an arbitrary graph of parameters, however there is no support
for node attributes. Since in general one should but doesn't need to pay attention
to the order of assignments, we decided not to build ExaHyPE specification
files dynamically from a Mexa graph but instead fill them out from a template.
This is much less dynamic but quite safe in terms of ExaHyPE portability.