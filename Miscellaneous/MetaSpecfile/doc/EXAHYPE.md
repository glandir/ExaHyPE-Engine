# The Meta ExaHyPE in Mexa

ExaHyPE ships with a sophisticated specification language, defined by its
own grammar. Two distinct parsers are implemented, a fuzzy C parser and
a full Java parser generated by SableCC.

However, this language is hard to parse and compose. It is also not
extensible at all. User parameters can hardly be specified.

Therefore, we proposed with mexa a language system which

  * allows users to write readable and robust parameter files
  * which are immune against ordering and changes of the specfile grammar
  * and which keep relevant parameters close to each other;
  * compiles to ExaHyPE specification files with solver constants,
  * are human readable and editable after compilation (*got richer*),
  * are also usable and composable *independently* of the mexa-prestep,
  * but offer an abstraction layer to shield embedding issues from the user,
  * and allow in the ExaHyPE user solver to transparently access the variables.
  * including backtracing of errnous entries to the source line

This overall ecosystem is modular: Users can use the full stack from the 
meta parameter language down to the ExaHyPE runtime parsing, but they don't
need to. Instead, we will go into detail of these steps in this document.

In the appendix some design decision arguments are given, subsequently.

## Using the Mexa language




### Step 1: Meta-Specification file

### Step 2: Plain specification file

### Step 3: Evaluation of ExaHyPE specfile template

## Embedded Mexa file inside an ExaHyPE specfile

### Formats

## Reading hierarchic parameters inside ExaHyPE


## Appendix: Design Rationale

### Design of an ExaHyPE specfile

The ExaHyPE specification language can be approximated as an XMLish
structure,

```
begin section unnamed-parameter1 unnamed-parameter2
   assignment1 decorator = right hand side
   assignment2 decorator = right hand side
   assignment3 decorator = weird:embedded,lists:here
   assignment4 decorator = {which:sometimes,are:enclosed}
end section
```

This can be mapped for instance onto an XML ontology (1):

```
<section some-name1="unnamed-parameter1" some-name2="unnamed-parameter2">
   <assignment1 some-name="decorator">right hand side</assignemnt1>
   <assignment2 some-name="decorator">right hand side</assignemnt2>
   <assignment3 some-name="decorator">weird:embedded,lists:here</assignemnt3>
   <assignment3 some-name="decorator">{which:sometimes,are:enclosed}</assignemnt3>
</section>
```

or XML ontology (2):

```
<block name="section">
   <parameter>unnamed-parameter1</parameter>
   <parameter>unnamed-parameter2</parameter>

   <assignment>
       <key>assignment1</key>
       <decorator>decorator</decorator>
       <value>right hand side</value>
   </assignment>
   <!-- ... -->
   <assignment>
       <key>assignment4</key>
       <decorator>decorator</decorator>
       <value>
         <list enclosing="curly"> <!--For the enclosing -->
            <key>weird</key><value>embedded</value>
            <key>lists</key><value>here</value>
         </list>
       </value>
    </assignment>
</section>
```

That is, we would need a node tree, text leafs and attributes to describe an
ExaHyPE specfile. (We don't take the weird embedded lists into account)

Note that in XML, the order of the tags is relevant. The same is true for the
ExaHyPE specfiles. This is a quite weird decision in parameter file formats.

### The Mexa approach

Mexa can represent an arbitrary graph of parameters, however there is no support
for node attributes. Since in general one should but doesn't need to pay attention
to the order of assignments, we decided not to build ExaHyPE specification
files dynamically from a Mexa graph but instead fill them out from a template.
This is much less dynamic but quite safe in terms of ExaHyPE portability.

In principle, our approach would allow us to encode node attributes as meta data,
allowing a 1:1 translation of a dictionary tree to an exahype file.

However, instead, we decided to template an ExaHyPE specification file. This
decision was just made for brevity.
