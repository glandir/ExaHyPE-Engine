// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================

#include <sstream>
#include <ostream>
#include "exahype/plotters/Plotter.h"
#include "exahype/profilers/ProfilerFactory.h"
#include "exahype/solvers/Solver.h"
#include "exahype/solvers/SolverCoupling.h"

#include "kernels/KernelCalls.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/GaussLobattoQuadrature.h"
#include "kernels/LimiterProjectionMatrices.h"
#include "kernels/DGMatrices.h"
#include "kernels/DGBasisFunctions.h"

#include "exahype/solvers/LimitingADERDGSolver.h"
#include "LimitingADERDG_ADERDG.h"
#include "LimitingADERDG_FV.h"
#include "Plotter.h"



void kernels::initSolvers(exahype::Parser& parser, std::vector<std::string>& cmdlineargs) {
  {

  // Create and register solver
  exahype::solvers::Solver* solver = nullptr;

  {
  solver = new Euler::LimitingADERDG_ADERDG(parser.getMaximumMeshSize(0), parser.getTimeStepping(0), cmdlineargs);
  }
  std::unique_ptr<exahype::solvers::ADERDGSolver> aderdgSolver(static_cast<exahype::solvers::ADERDGSolver*>(solver));
  {
  solver = new Euler::LimitingADERDG_FV(2*(aderdgSolver->getNodesPerCoordinateAxis()-1)+1, parser.getMaximumMeshSize(0), parser.getTimeStepping(0));
  }
  std::unique_ptr<exahype::solvers::FiniteVolumesSolver> finiteVolumesSolver(static_cast<exahype::solvers::FiniteVolumesSolver*>(solver));
  
  exahype::solvers::RegisteredSolvers.push_back(
    new exahype::solvers::LimitingADERDGSolver("LimitingADERDG",std::move(aderdgSolver),std::move(finiteVolumesSolver),parser.getDMPRelaxationParameter(0),parser.getDMPDifferenceScaling(0)) );
  parser.checkSolverConsistency(0);
  }

  
  exahype::plotters::RegisteredPlotters.push_back( new exahype::plotters::Plotter(0,0,parser,new Euler::Plotter(  *static_cast<exahype::solvers::LimitingADERDGSolver*>(exahype::solvers::RegisteredSolvers[0])) ));


  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::initGaussLegendreNodesAndWeights(orders);
  kernels::initGaussLobattoNodesAndWeights(orders);
  kernels::initLimiterProjectionMatrices(orders);
  kernels::initDGMatrices(orders);
  kernels::initBasisFunctions(orders);
}


void kernels::finalise() {
  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::freeGaussLegendreNodesAndWeights(orders);
  kernels::freeGaussLobattoNodesAndWeights(orders);
  kernels::freeLimiterProjectionMatrices(orders);
  kernels::freeDGMatrices(orders);
  kernels::freeBasisFunctions(orders);

  for (auto solver : exahype::solvers::RegisteredSolvers) {
    delete solver;
  }
  exahype::solvers::RegisteredSolvers.clear();

  for (auto plotter : exahype::plotters::RegisteredPlotters) {
    delete plotter;
  }
  exahype::plotters::RegisteredPlotters.clear();
  for (auto coupling : exahype::solvers::RegisteredSolverCouplings) {
    delete coupling;
  }
  exahype::solvers::RegisteredSolverCouplings.clear();
}



void kernels::toString(std::ostream& ostream) {
/* Generated SolverRegistration code by the toolkit */

  ostream << "projectName: Euler\n";
  ostream << "useOptimisedKernels: no\n";
  ostream << "Kernel[0].registration: LimitingAderdgSolver\n";
  ostream << "Kernel[0].type: ";
  exahype::solvers::RegisteredSolvers[0]->toString(ostream);
  ostream << "\n";
  ostream << "Kernel[0].name: Euler::LimitingADERDG{_ADERDG, _FV}\n";
  ostream << "Kernel[0].hasConstants: false\n";
  ostream << "Kernel[1].Plotter[0]: Euler::Plotter\n";
}


