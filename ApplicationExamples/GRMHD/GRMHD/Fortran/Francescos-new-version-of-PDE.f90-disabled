SUBROUTINE PDEFlux(f,g,h,Q,gradQ,x,time) 
  USE MainVariables, ONLY : EQN, nVar, gamma2, alpha, beta, DivCleaning_a, d, StiffParam
  IMPLICIT NONE
  REAL :: f(nVar), g(nVar), h(nVar), Q(nVar), gradQ(nVar,d), V(nVar)  
  REAL :: time, x(d)
  REAL, PARAMETER :: epsilon = 1e-14 
  INTENT(IN)  :: Q,gradQ
  INTENT(OUT) :: f,g,h 
  ! Local Variables 
  INTEGER :: i, iErr, ii, jj, mm, kk, ll ,m
  REAL :: rho,vx,vy,vz,p,bx,by,bz,ex,ey,ez
  REAL :: v2,b2,e2,lf,LF2,w,ww,wwx,wwy,wwz,uem,gamma1
  REAL :: irho,ps,pg,rho0,k0,kappa,sigma,psi,phi,falpha
  REAL :: uu,vv,Bx2,By2,Bz2,B28P,vB,ru2,rv2,rw2,a2,pMag,hh 
  REAL :: lapse, gp, gm, rhoE, ep, em, eps, gABp(3,3), gABm(3,3) 
  REAL :: g_contr(3,3), g_cov(3,3), AA(3), PP(3), GG(3), DD(3,3,3), traceB, DetGamma
  REAL :: shift(3), shift_cov(3), vf(3), vf_cov(3), Bv(3), Ev(3), vxB(3), ExB(3), J(3)
  REAL :: A(3,3), devG(3,3), GT(3,3), Id(3,3), detA, check, TT(3,3), ET(3,3), AU(3)
  REAL :: vxE(3), lui(3), detvEB, qd(3), A_st(3,0:3), g_cov_st(0:3,0:3), g_contr_st(0:3,0:3), rhoA   
  REAL :: Fv(nVar), Gv(nVar), Hv(nVar), gAB_contr(3,3), gAB(3,3), kAB(3,3), kAB_contr(3,3), eta_mix(3,3), eta_cov(3,3)    
  REAL :: I1,I2,detgAB, piAB(3,3), piAB1(3,3), piAB2(3,3), piAB_st(0:3,0:3), pi_mix_st(0:3,0:3), pi_scalar, f1, f2   
  REAL :: uux,vvx,Tx,dcs,dc0, pi_work(3) 
  REAL :: uuy,vvy,Ty 
  REAL :: uuz,vvz,Tz
  REAL :: Y1x,Y1y,Y1z
  REAL :: Y2x,Y2y,Y2z 
  REAL :: divV,divV23,mu,icv,T,cs,cl,c0,temp(3,3),S,rhos,rhol,pl,evv,es,el,alphas,alphal  
  REAL :: iRho2,iRho3
  REAL :: dTdW1,dTdW2,dTdW3,dTdW4
  REAL :: AlphaPhi2, contraction18x, contraction18y, contraction18z
  REAL :: AlphaPhi2RijPlus_NablaiNablaj_flux_x(3,3), AlphaPhi2RijPlus_NablaiNablaj_flux_y(3,3), AlphaPhi2RijPlus_NablaiNablaj_flux_z(3,3)
  REAL :: NablaiNablaiAlpha_flux_x, NablaiNablaiAlpha_flux_y, NablaiNablaiAlpha_flux_z
  REAL :: AlphaRplusTwoNablaZ_flux_x, AlphaRplusTwoNablaZ_flux_y, AlphaRplusTwoNablaZ_flux_z
  REAL :: gcontr_xrPr, gcontr_yrPr, gcontr_zrPr 
  REAL :: gcontr_xlAl, gcontr_ylAl, gcontr_zlAl
  REAL :: Ldi(3), Lbi(3), EMT(3,3), pem, ggd1, ggd2, ggd3, QSave(nVar), Qmo(nVar)   
  REAL :: k1, k2, k3, ff, e, c, det, fa, s1, s2, s3, s4, s5, s6, s7, s8, s9, xi
  REAL :: QG(3), Z(3), Zup(3), traceA, Atildeup(3,3), Gtilde(3), ggg, fff, ds, sk , lam        
  REAL :: FTens(nVar,3), beta0(3) 
  REAL, PARAMETER         :: Pi = ACOS(-1.0) 
  REAL, PARAMETER         :: iPi  = .31830988618379
  REAL, PARAMETER         :: iPi4 = .79577471545948e-1
  REAL, PARAMETER         :: iPi8 = .39788735772974e-1
  REAL, PARAMETER         :: onethird = 0.33333333333333333
  REAL :: ComputeDet, BQ(3), Vtr(3), Fij(3,3), Qv_contr(3),QB_contr(3),vxB_contr(3),BV_contr(3)
  ! 
  !    f = Q  
  !    g = 0. 
  !    h = 0. 
  !    RETURN 
  ! 
  CALL PDECons2Prim(V,Q,x,time,iErr)
  !
  gamma1 = EQN%gamma/(EQN%gamma-1.0)
  rho    = V(1)
  vf_cov = V(2:4)
  p      = V(5)
  !
  BV_contr(1:3) = V(6:8)  ! B is contravariant
  QB_contr(1:3) = Q(6:8)  ! B is contravariant
  psi = V(9)
  lapse = V(10)
  shift = V(11:13)
  !
  !gammaij = V(14:19) 
  g_cov(1,1) = V(14)
  g_cov(1,2) = V(15)
  g_cov(1,3) = V(16)
  g_cov(2,2) = V(17)
  g_cov(2,3) = V(18)
  g_cov(3,3) = V(19)
  g_cov(2,1) = V(15)
  g_cov(3,1) = V(16)
  g_cov(3,2) = V(18)
  !
  !IF(MAXVAL(ABS(g_cov)).LT.1e-14) THEN
  !      print *, 'FATAL ERROR: MAXVAL(ABS(g_cov))'
  !      WRITE(*,*) g_cov(1,1:3)
  !      WRITE(*,*) g_cov(2,1:3)
  !      WRITE(*,*) g_cov(3,1:3)
  !      print *, 'q'
  !      WRITE(*,*)  Q
  !      STOP
  !  ENDIF
  CALL MatrixInverse3x3(g_cov,g_contr,gp)
  gp = SQRT(gp)
  gm = 1./gp
  ! 
  !CALL METRIC(x, lapse, gp, gm, shift, g_cov, g_contr)
  !
  vf = MATMUL(g_contr,vf_cov)
  Qv_contr = MATMUL(g_contr,Q(2:4))
  BQ = MATMUL(g_cov,QB_contr)
  BV = MATMUL(g_cov,BV_contr)
  !
  !vxB(1) = vf_cov(2)*BV(3) - vf_cov(3)*BV(2)
  !vxB(2) = vf_cov(3)*BV(1) - vf_cov(1)*BV(3)
  !vxB(3) = vf_cov(1)*BV(2) - vf_cov(2)*BV(1)
  ! COVARIANT =>
  vxB(1) = vf(2)*BV_contr(3) - vf(3)*BV_contr(2)
  vxB(2) = vf(3)*BV_contr(1) - vf(1)*BV_contr(3)
  vxB(3) = vf(1)*BV_contr(2) - vf(2)*BV_contr(1)
  vxB(1:3) = gp*vxB(1:3)
  !
  !vxB_contr(1) = vf(2)*BV_contr(3) - vf(3)*BV_contr(2)
  !vxB_contr(2) = vf(3)*BV_contr(1) - vf(1)*BV_contr(3)
  !vxB_contr(3) = vf(1)*BV_contr(2) - vf(2)*BV_contr(1)
  ! CONTRAVARIANT =>
  vxB_contr(1) = vf_cov(2)*BV(3) - vf_cov(3)*BV(2)
  vxB_contr(2) = vf_cov(3)*BV(1) - vf_cov(1)*BV(3)
  vxB_contr(3) = vf_cov(1)*BV(2) - vf_cov(2)*BV(1)
  vxB_contr(1:3) = gm*vxB_contr(1:3)
  !
  !vxB_contr = MATMUL(g_contr,vxB(1:3))   !!! I think this is wrong: vxB is NOT a vector, but a pseudo-vector. It does not follow the canonical cov/contr transformation rules.
  !
  !v2     = vx**2 + vy**2 + vz**2
  !b2     = bx**2 + by**2 + bz**2
  !e2     = ex**2 + ey**2 + ez**2 
  v2     = vf(1)*vf_cov(1) + vf(2)*vf_cov(2) + vf(3)*vf_cov(3)
  e2     = vxB_contr(1)*vxB(1) + vxB_contr(2)*vxB(2) + vxB_contr(3)*vxB(3)
  b2     = BV_contr(1)*BV(1) + BV_contr(2)*BV(2) + BV_contr(3)*BV(3)
  !
  uem    = 0.5*(b2 + e2) 
  !
  lf     = 1.0/sqrt(1.0 - v2)
  w      = rho + gamma1*p   ! rho*hentalpy
  ww     = w*lf**2
  wwx    = ww*vf(1)
  wwy    = ww*vf(2)
  wwz    = ww*vf(3) 
  !
  ! transport velocity
  Vtr(1:3) = lapse*vf(1:3)-shift(1:3)   ! this is contravariant !!!!
  !
  !    Fij(1,1:3) =  (/ f1, g1, h1 /) for Q(6)  
  !    Fij(2,1:3) =  (/ f2, g2, h2 /) for Q(7)  ... without divergence cleaning
  !    Fij(3,1:3) =  (/ f3, g3, h3 /) for Q(8)  
  !
  DO m=1,3
      DO i=1,3
          Fij(i,m) = -Vtr(i)*QB_contr(m)+Vtr(m)*QB_contr(i)  ! Fij(i,i) = 0 !!!! ! NB: this is contravariant !!!!
      ENDDO
  ENDDO
  !
  f(1)   = vf(1)*Q(1) !rho*lf   !Q(1) ! rho*lf 
  f(2)   = wwx*vf_cov(1) - vxB_contr(1)*vxB(1) - BV_contr(1)*BV(1) + p + uem
  f(3)   = wwx*vf_cov(2) - vxB_contr(1)*vxB(2) - BV_contr(1)*BV(2) 
  f(4)   = wwx*vf_cov(3) - vxB_contr(1)*vxB(3) - BV_contr(1)*BV(3) 
  f(5)   = Qv_contr(1)-f(1) !wwx - f(1)         ! ADD MAGNETIC COMPONENT
  ! ADD MAGNETIC FIELD and DIV. CLEANING
  f(6)   = Fij(1,1) + V(9)  ! V(9)
  f(7)   = Fij(2,1)         !-ez
  f(8)   = Fij(3,1)         ! ey  
  f(9)   = EQN%ch**2*QB_contr(1)    ! ! NB: B is contravariant ! All derivatives are COVARIANT. psi is scalar.
  !  lapse&shift&metric fluxes 
  f(10:19) = 0.
  !
  g(1)   = vf(2)*Q(1) !rho*lf   ! rho*lf
  g(2)   = wwy*vf_cov(1) - vxB_contr(2)*vxB(1) - BV_contr(2)*BV(1) 
  g(3)   = wwy*vf_cov(2) - vxB_contr(2)*vxB(2) - BV_contr(2)*BV(2) + p + uem
  g(4)   = wwy*vf_cov(3) - vxB_contr(2)*vxB(3) - BV_contr(2)*BV(3) 
  g(5)   = Qv_contr(2)-g(1) !wwy - g(1)   ! ADD MAGNETIC COMPONENT
  ! ADD MAGNETIC FIELD and DIV. CLEANING
  g(6)   = Fij(1,2) !ez 
  g(7)   = Fij(2,2) + V(9) !V(9) 
  g(8)   = Fij(3,2) !-ex   
  g(9)   = EQN%ch**2*QB_contr(2)    ! ! NB: B is contravariant ! All derivatives are COVARIANT. psi is scalar.
  !  lapse&shift&metric fluxes 
  g(10:19) = 0.
  !
  !
  !
  h(1)   = vf(3)*Q(1) !rho*lf   ! rho*lf   !
  h(2)   = wwz*vf_cov(1) - vxB_contr(3)*vxB(1) - BV_contr(3)*BV(1) 
  h(3)   = wwz*vf_cov(2) - vxB_contr(3)*vxB(2) - BV_contr(3)*BV(2)  
  h(4)   = wwz*vf_cov(3) - vxB_contr(3)*vxB(3) - BV_contr(3)*BV(3) + p + uem
  h(5)   = Qv_contr(3)-h(1) ! wwz - h(1)   !ADD MAGNETIC COMPONENT
  ! ADD MAGNETIC FIELD and DIV. CLEANING
  h(6)   = Fij(1,3)  !-ey  
  h(7)   = Fij(2,3) !ex   
  h(8)   = Fij(3,3) + V(9) !V(9)   
  h(9)   = EQN%ch**2*QB_contr(3)    ! ! NB: B is contravariant ! All derivatives are COVARIANT => d_i * B^i is scalar.
  !  lapse&shift&metric fluxes 
  h(10:19) = 0.
  ! 
  f(2:4)   = f(2:4)*gp
  g(2:4)   = g(2:4)*gp
  h(2:4)   = h(2:4)*gp
  ! Remember that Q(:) below contains already the factor gp, which is ok!
  f(1:5)   = lapse*f(1:5) - shift(1)*Q(1:5)
  g(1:5)   = lapse*g(1:5) - shift(2)*Q(1:5)
  h(1:5)   = lapse*h(1:5) - shift(3)*Q(1:5)
  !
  !   
END SUBROUTINE PDEFlux


SUBROUTINE PDENCP(AQx,BQy,CQz,Q,Qx,Qy,Qz,x) 
   USE MainVariables, ONLY : EQN, nVar, d, x0_000
   IMPLICIT NONE
   REAL :: AQx(nVar), BQy(nVar), CQz(nVar), Q(nVar), Qx(nVar), Qy(nVar), Qz(nVar), x(d) 
   INTENT(IN)  :: Q,Qx,Qy,Qz,x
   INTENT(OUT) :: AQx,BQy,CQz  
   INTEGER :: i, j, l, m, n, iErr, ip,iq, qq, ii, jj, kk, ll, mm, nn, count
   REAL :: uu, vv, ww, vtr(3), rho0, kappa, rho, Vp(nVar), k, sigma     
   REAL, PARAMETER :: epsilon = 1e-14
   REAL :: p, ih,h,pg, A(3,3), gradQ(nVar,d), BgradQ(nVar)     
   REAL :: vx,vy,vz,cs,cl,ff, MD12, irho, lam, mu   
   REAL :: k1,k2,k3,fff,ggg,e,c,ds,xi,sk,sknl,bs,g_cov(3,3),g_contr(3,3),dgup(3,3,3)
   REAL :: det, alpha, fa, k0, dk0(3), beta0(3), b0(3), u(3), ialpha 
   REAL :: s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, eta, itau    
   REAL :: lapse, shift(3), gammaij(6), delta(3,3), bv(3), vxb(3), vxb_contr(3), psi, qv_contr(3), qb_contr(3), bv_contr(3) 
   REAL :: v2,vf(3),uem,b2,e2,gp,gm,vc(nVar),lf,w,gamma1,vf_cov(3), s_contr(3), w_ij, wim 
   REAL :: QGRMHD(19), gradQGRMHD(19,d), BgradQGRMHD(19), ov(3) 
   REAL :: Christoffel(3,3,3), RiemannNCP(3,3,3,3), RiemannSrc(3,3,3,3), dChristoffelNCP(3,3,3,3), dChristoffel_tildeNCP(3,3,3,3), dChristoffelSrc(3,3,3,3), DD(3,3,3), dDD(3,3,3,3)  
   REAL :: AA(3), dAA(3,3), BB(3,3), dBB(3,3,3), beta(3), Kex(3,3), Kmix(3,3), Kup(3,3), Z(3), dZ(3,3), nablaZNCP(3,3), nablaZSrc(3,3), RplusNablaZNCP, RplusNablaZSrc  
   REAL :: Theta, dTheta(3), nablaijalphaNCP(3,3), nablaijalphaSrc(3,3), Ricci(3,3), RicciNCP(3,3), RicciSrc(3,3), dtraceK(3), dtraceKNCP(3), dKtempNCP(3), dZNCP(3,3), dZSrc(3,3)  
   REAL :: dtgamma(3,3), dtK(3,3), dK(3,3,3), dtTheta, dtZ(3), dtalpha, dtGhat(3), dtbeta(3), dtbb(3), dxbb(3,3), dtA(3), dtB(3,3), dtD(3,3,3)  
   REAL :: Aupdown, Aex(3,3), dAex(3,3,3), Amix(3,3), Aup(3,3), Ghat(3), Gtilde(3), dGhat(3,3), traceK, Kupdown, phi, dphi(3), PP(3), dPP(3,3), TwoNablaZNCP, TwoNablaZSrc, dKex(3,3,3)      
   REAL :: dGtildeSrc(3,3), dGtildeNCP(3,3), RiccitildeNCP(3,3), RicciphiNCP(3,3), RiccitildeSrc(3,3), RicciphiSrc(3,3), Mom(3), Ham, Pup(3), DDcontr(3)   
   REAL :: Christoffel_tilde(3,3,3), Christoffel_kind1(3,3,3), Zup(3), RicciPlusNablaZNCP(3,3), RicciPlusNablaZSrc(3,3), traceA, traceB, QG(3), b(3), faa, temp   
   REAL :: SecondOrderTermsNCP(3,3), SecondOrderTermsSrc(3,3), traceNCP, traceSrc, dtphi, dtTraceK, dtP(3), dtX(3), XX(3), dXX(3,3), nablaXNCP(3,3)     
   REAL :: RPlusTwoNablaZNCP, RNCP, RSrc, RPlusTwoNablaZSrc, nablanablaalpha, nablanablaalphaNCP, nablanablaalphaSrc, Riemann(3,3,3,3), dChristoffel(3,3,3,3), divAupNCP(3), divAupSrc(3) 
   ! 
   AQx = 0.   
   BQy = 0. 
   CQz = 0. 
   !  
  lapse = Q(10)
  shift = Q(11:13)
  !
  gammaij = Q(14:19) 
  g_cov(1,1) = Q(14)
  g_cov(1,2) = Q(15)
  g_cov(1,3) = Q(16)
  g_cov(2,2) = Q(17)
  g_cov(2,3) = Q(18)
  g_cov(3,3) = Q(19)
  g_cov(2,1) = Q(15)
  g_cov(3,1) = Q(16)
  g_cov(3,2) = Q(18)
  !
  delta = 0.
  DO i=1,3
      delta(i,i) = 1.0
  ENDDO 
  !
  CALL MatrixInverse3x3(g_cov,g_contr,gp)
  gp = SQRT(gp)
  gm = 1./gp
  ! 
  CALL PDECons2Prim(Vc,Q,x0_000,0.,iErr)
  gamma1 = EQN%gamma/(EQN%gamma-1.0)
  rho    = Vc(1)
  vf_cov = Vc(2:4)
  vf     = MATMUL(g_contr,vf_cov)
  p      = Vc(5)
  !
  !BV(1:3) = Vc(6:8) ! wrong: B is contravatiant
  !BV_contr = MATMUL(g_contr,BV(1:3))
  !QB_contr = MATMUL(g_contr,Q(6:8)) ! wrong: B is contravatiant
  BV_contr(1:3) = Vc(6:8) ! contravariant!
  QB_contr = Q(6:8)
  BV = MATMUL(g_cov,BV_contr)
  psi = Vc(9) 
  !
  Qv_contr = MATMUL(g_contr,Q(2:4))
  !
  !vxB(1) = vf_cov(2)*BV(3) - vf_cov(3)*BV(2)
  !vxB(2) = vf_cov(3)*BV(1) - vf_cov(1)*BV(3)
  !vxB(3) = vf_cov(1)*BV(2) - vf_cov(2)*BV(1)
  ! COVARIANT =>
  vxB(1) = vf(2)*BV_contr(3) - vf(3)*BV_contr(2)
  vxB(2) = vf(3)*BV_contr(1) - vf(1)*BV_contr(3)
  vxB(3) = vf(1)*BV_contr(2) - vf(2)*BV_contr(1)
  vxB(1:3) = gp*vxB(1:3)
  !
  !vxB_contr(1) = vf(2)*BV_contr(3) - vf(3)*BV_contr(2)
  !vxB_contr(2) = vf(3)*BV_contr(1) - vf(1)*BV_contr(3)
  !vxB_contr(3) = vf(1)*BV_contr(2) - vf(2)*BV_contr(1)
  ! CONTRAVARIANT =>
  vxB_contr(1) = vf_cov(2)*BV(3) - vf_cov(3)*BV(2)
  vxB_contr(2) = vf_cov(3)*BV(1) - vf_cov(1)*BV(3)
  vxB_contr(3) = vf_cov(1)*BV(2) - vf_cov(2)*BV(1)
  vxB_contr(1:3) = gm*vxB_contr(1:3)
  !
  !v2     = vx**2 + vy**2 + vz**2
  !b2     = bx**2 + by**2 + bz**2
  !e2     = ex**2 + ey**2 + ez**2 
  v2     = vf(1)*vf_cov(1) + vf(2)*vf_cov(2) + vf(3)*vf_cov(3)
  e2     = vxB_contr(1)*vxB(1) + vxB_contr(2)*vxB(2) + vxB_contr(3)*vxB(3)
  b2     = BV_contr(1)*BV(1) + BV_contr(2)*BV(2) + BV_contr(3)*BV(3)
  !
  uem    = 0.5*(b2 + e2) 
  !
  S_contr = MATMUL(g_contr,Q(2:4))
  !gv_contr = MATMUL(g_contr,gv)
  lf     = 1.0/sqrt(1.0 - v2)
  w      = rho + gamma1*p   ! rho*hentalpy
  ww     = w*lf**2          ! rho*hentalpy*Lorentz^2 
  !
  !DO j=1,3
  AQx = 0.
  BQy = 0.
  CQz = 0.
      count=0
      DO i=1,3 
                !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                j=1
                !------ 
                W_ij = ww*vf_cov(i)*vf(j)-vxB(i)*vxB_contr(j)-BV(i)*BV_contr(j)+(p+uem)*delta(i,j)
                !
                AQx(1+j) = AQx(1+j) - Q(1+i)*Qx(10+i)  ! Q(11:13)  shift(i) or shift_contr(i)
                AQx(5) = AQx(5) - gp*W_ij*Qx(10+i)     ! Q(11:13)  shift(i) or shift_contr(i)
                !
                !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                j=2
                !------ 
                W_ij = ww*vf_cov(i)*vf(j)-vxB(i)*vxB_contr(j)-BV(i)*BV_contr(j)+(p+uem)*delta(i,j)
                !
                BQy(1+j) = BQy(1+j) - Q(1+i)*Qy(10+i)   ! Q(11:13)  shift(i) or shift_contr(i)
                BQy(5) = BQy(5) - gp*W_ij*Qy(10+i)     ! Q(11:13)  shift(i) or shift_contr(i)
                !
                !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                j=3
                !------
                W_ij = ww*vf_cov(i)*vf(j)-vxB(i)*vxB_contr(j)-BV(i)*BV_contr(j)+(p+uem)*delta(i,j)
                !
                CQz(1+j) = CQz(1+j) - Q(1+i)*Qz(10+i)   ! Q(11:13)  shift(i) or shift_contr(i)
                CQz(5) = CQz(5) - gp*W_ij*Qz(10+i)     ! Q(11:13)  shift(i) or shift_contr(i)
                !
          DO m=1,3
            IF(m.GE.i) THEN  
                count=count+1
                !
                Wim = ww*vf(i)*vf(m)-vxB_contr(i)*vxB_contr(m)-BV_contr(i)*BV_contr(m)+(p+uem)*g_contr(i,m)
                Wim = Wim + (1.0 - delta(i,m))*(ww*vf(m)*vf(i)-vxB_contr(m)*vxB_contr(i)-BV_contr(m)*BV_contr(i)+(p+uem)*g_contr(m,i))  ! account also of the remaining symmetric components of gamma for i.NE.m.
                !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                j=1
                !------ 
                AQx(1+j) = AQx(1+j) - 0.5*gp*lapse*Wim*Qx(13+count)  ! Q(14:19) gammaij(count) or  g_cov(i,m)
                AQx(5) = AQx(5) - 0.5*gp*Wim*shift(j)*Qx(13+count)   ! Q(14:19) gammaij(count) or  g_cov(i,m)
                !
                !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                j=2
                !------ 
                BQy(1+j) = BQy(1+j) - 0.5*gp*lapse*Wim*Qy(13+count)  ! Q(14:19) gammaij(count) or  g_cov(i,m)
                BQy(5) = BQy(5) - 0.5*gp*Wim*shift(j)*Qy(13+count)   ! Q(14:19) gammaij(count) or  g_cov(i,m)
                !
                !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                j=3
                !------
                CQz(1+j) = CQz(1+j) - 0.5*gp*lapse*Wim*Qz(13+count)  ! Q(14:19) gammaij(count) or  g_cov(i,m)
                CQz(5) = CQz(5) - 0.5*gp*Wim*shift(j)*Qz(13+count)   ! Q(14:19) gammaij(count) or  g_cov(i,m)
                !
            ENDIF
          ENDDO
      ENDDO
    !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    j=1
    !------ 
    AQx(1+j) = AQx(1+j) + (Q(5)+Q(1))*Qx(10)    ! Q(10) or lapse
    AQx(5) = AQx(5) + S_contr(j)*Qx(10)         !  Q(10) or lapse
    !
    !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    j=2
    !------ 
    BQy(1+j) = BQy(1+j) + (Q(5)+Q(1))*Qy(10)    ! Q(10) or lapse
    BQy(5) = BQy(5) + S_contr(j)*Qy(10)         !  Q(10) or lapse
    !
    !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    j=3
    !------
    CQz(1+j) = CQz(1+j) + (Q(5)+Q(1))*Qz(10)    ! Q(10) or lapse
    CQz(5) = CQz(5) + S_contr(j)*Qz(10)         !  Q(10) or lapse
    ! 
  !
END SUBROUTINE PDENCP
  
    
SUBROUTINE PDEEigenvalues(L,Q,n,xg)
  USE MainVariables, ONLY : EQN, nVar, nParam, gamma2, alpha, beta, DivCleaning_a, d 
  USE recipies_mod, ONLY : RG, svdcmp 
  !USE mkl95_lapack   
  IMPLICIT NONE
  REAL :: L(nVar), n(3), Q(nVar), V(nVar)
  REAL :: ltime, xg(d)
  INTENT(IN)  :: Q,n,xg
  INTENT(OUT) :: L 
  ! Local Variables 
  INTEGER :: i, j, zero, iErr, itemp(nVar), ml(2)  
  REAL :: rho,vx,vy,vz,p
  REAL :: cs2, cs, c0, v2, w, gamma1, vn, den
  REAL :: u, c, irho, Pi, dcs,dc0
  REAL :: bx, by, bz, ex, ey, ez, t2, rho0, kappa, k0, uu,vv,ww,vs
  REAL :: a2, b2, e2, ca2, vf1, vf2, a, ca, cf, QRot(nVar),AA(nVar,nVar), AAread(nVar,nVar), AAdiff(nVar,nVar)     
  REAL :: sv(3),tv(3),VPR(3),BVR(3),iPi,B28P,b_x,b_y,b_z,b
  REAL :: t1, t7, t9, t13, t19, t21
  REAL :: lapse, gp, gm, Qr(nVar) 
  REAL :: g_contr(3,3), g_cov(3,3)
  REAl :: shift(3), vf(3), vf_cov(3)
  REAL :: av(2), ux(2)
  REAL :: us,ul,ps,cl,pl
  REAL :: sft, gg, Vp(nVar) 
  REAL :: Qp(nVar),Qm(nVar),fpp(nVar),gpp(nVar),hpp(nVar),fmm(nVar),gmm(nVar),hmm(nVar),tempGJ(nVar,nVar)  
  REAL :: Lambda(nVar), GradQ(nVar,d), R(nVar,nVar), eps, time, nv(d), iR(nVar,nVar)      
  REAL :: dfdQ(nVar,nVar), ImLambda(nVar), rtemp(nVar),  ialpha, lam, mu 
  INTEGER, PARAMETER :: LWMAX = 10000 
  INTEGER            :: INFO, LWORK
  REAL :: WORK( LWMAX ) 
  REAL, PARAMETER :: epsilon = 1e-14  
  REAL :: ComputeDet, psi, BV(3),BV_contr(3)
  REAL :: b2_4, lf, lf2M, VdotB
  !
  !    L = 1.
  !    RETURN 
  ! 
  Pi = ACOS(-1.0)
  L(:) = 0.0
  !
    ! Eigenvalues as given by Olindo 
    CALL PDECons2Prim(V,Q,xg,ltime,iErr)
    rho    = V(1)
    vf_cov = V(2:4)
    p      = V(5)
    !
    !BV(1:3) = V(6:8)   ! wrong!
    BV_contr(1:3) = V(6:8)
    psi = V(9)
    lapse = V(10)
    shift = V(11:13)
    !
    !gammaij = V(14:19) 
    g_cov(1,1) = V(14)
    g_cov(1,2) = V(15)
    g_cov(1,3) = V(16)
    g_cov(2,2) = V(17)
    g_cov(2,3) = V(18)
    g_cov(3,3) = V(19)
    g_cov(2,1) = V(15)
    g_cov(3,1) = V(16)
    g_cov(3,2) = V(18)
    !
    CALL MatrixInverse3x3(g_cov,g_contr,gp)
    gp = SQRT(gp)
    gm = 1./gp
    !  evaluate contr. cov. variables
    vf      = MATMUL(g_contr,vf_cov)
    BV      = MATMUL(g_cov,BV_contr)
    !  evaluate useful quantities
    v2     = vf(1)*vf_cov(1) + vf(2)*vf_cov(2) + vf(3)*vf_cov(3)
    lf     = 1.0/sqrt(1.0 - v2)
    lf2m   = 1.0 - v2
    b2     = BV_contr(1)*BV(1) + BV_contr(2)*BV(2) + BV_contr(3)*BV(3)
    VdotB     = vf(1)*BV(1) + vf(2)*BV(2) + vf(3)*BV(3)
    b2_4 = b2*lf2m + VdotB  ! this is b^2
    gamma1 = EQN%gamma/(EQN%gamma-1.0) 
    w      = rho + gamma1*p + b2_4 ! this is rho*h + b^2
    cs2    = (EQN%gamma*p + b2_4)/w
    !
    vn     = vf(1)*n(1) + vf(2)*n(2) + vf(3)*n(3)
    sft    = shift(1)*n(1) + shift(2)*n(2) + shift(3)*n(3) 
    gg     = g_contr(1,1)*ABS(n(1)) + g_contr(2,2)*ABS(n(2)) + g_contr(3,3)*ABS(n(3))
    den    = 1.0/(1.0 - v2*cs2)
    IF(SUM(n**2).EQ.0.) THEN  
       u = SQRT( v2) 
       WRITE(*,*)'Impossible error!'
       STOP
    ELSE
       u = vn 
    ENDIF
    L(1)   = ( u*(1.0-cs2) - SQRT( cs2*lf2m*( (1.0-v2*cs2)*gg - u**2*(1.0-cs2) )) )*den
    L(2:4) = u
    L(5)   = ( u*(1.0-cs2) + SQRT( cs2*lf2m*( (1.0-v2*cs2)*gg - u**2*(1.0-cs2) )) )*den 
    L(1:5)   = lapse*L(1:5) - sft
    !
    L(6:) = 0.
    !
    ! ADD MAGNETIC FIELD!!!!
    ! see ECHO1 and CAFE (from Alejandro)
    !
    L(9) =  EQN%ch   !1.  !EQN%ch
    !
END SUBROUTINE PDEEigenvalues


SUBROUTINE PDEPrim2Cons(Q,V,x,time) 
  USE MainVariables, ONLY: EQN, nVar, d 
  IMPLICIT NONE
  ! Argument list declaration
  REAL :: Q(nVar), V(nVar)
  REAL :: x(d), time 
  INTENT(IN)  :: V
  INTENT(OUT) :: Q 
  ! Local variable declaration
  INTEGER :: i, ii, jj, kk, ll 
  REAL :: Prim(nVar), Buf(nVar)
  REAL :: rho,vx,vy,vz,p,bx,by,bz,ex,ey,ez,cs,c0,cl
  REAL :: v2,b2,e2,lf,w,ww,uem,gamma1
  REAL :: lapse, gp, gm, dcs, dc0, eel 
  REAL :: g_contr(3,3), g_cov(3,3), rhoE 
  REAl :: shift(3), vf(3), vf_cov(3), Ev(3), Bv(3), ExB(3)
  REAL :: A(3,3), devG(3,3), G(3,3), temp(3,3), Id(3,3), detA, eh, S, evv, T, falpha  
  REAL :: alphas, alphal, rhos, rhol, us, vs, ul, vl, es, el
  REAL :: EE(3),BB(3),vv(3),detvEB, vxE(3), vxB(3)
  REAL :: psi, ComputeDet,gammaij(6),BV_contr(3),QV_contr(3),QB_contr(3),vxB_contr(3),b2_cov,b2_contr,vb_cov,vb_contr 
  REAL :: A_st(3,0:3), vtr(3), g_cov_st(0:3,0:3), g_contr_st(0:3,0:3), shift_cov(3), rhoA, kAB(3,3), kAB_contr(3,3)    
  REAL :: gAB(3,3), gAB_contr(3,3), f1, f2, I1, I2, piAB(3,3), piAB1(3,3), piAB2(3,3), piAB_st(0:3,0:3), pi_work(3) 
  REAL :: pi_scalar, pi_mix_st(0:3,0:3), eta_mix(3,3), eta_cov(3,3), detgAB    


  rho     = V(1)
  vf_cov  = V(2:4)
  p       = V(5)
  !
  !BV(1:3) = V(6:8)  !wrong
  BV_contr(1:3) = V(6:8)  !wrong
  psi = V(9)
  lapse = V(10)
  shift = V(11:13)          ! NB: we choose V() and Q() being the shift_controvariant!
  !
  !gammaij = V(14:19) 
  g_cov(1,1) = V(14)
  g_cov(1,2) = V(15)
  g_cov(1,3) = V(16)
  g_cov(2,2) = V(17)
  g_cov(2,3) = V(18)
  g_cov(3,3) = V(19)
  g_cov(2,1) = V(15)
  g_cov(3,1) = V(16)
  g_cov(3,2) = V(18)
  !
  CALL MatrixInverse3x3(g_cov,g_contr,gp)
  gp = SQRT(gp)
  gm = 1./gp
  !  
  !CALL METRIC(x, lapse, gp, gm, shift, g_cov, g_contr)
  !
  vf      = MATMUL(g_contr,vf_cov)
  BV = MATMUL(g_cov,BV_contr(1:3))
  Qv_contr = MATMUL(g_contr,Q(2:4))
  QB_contr = MATMUL(g_contr,Q(6:8))
  !vxB(1) = vf_cov(2)*BV(3) - vf_cov(3)*BV(2)
  !vxB(2) = vf_cov(3)*BV(1) - vf_cov(1)*BV(3)
  !vxB(3) = vf_cov(1)*BV(2) - vf_cov(2)*BV(1)
  ! COVARIANT =>
  vxB(1) = vf(2)*BV_contr(3) - vf(3)*BV_contr(2)
  vxB(2) = vf(3)*BV_contr(1) - vf(1)*BV_contr(3)
  vxB(3) = vf(1)*BV_contr(2) - vf(2)*BV_contr(1)
  vxB(1:3) = gp*vxB(1:3)
  !
  !vxB_contr(1) = vf(2)*BV_contr(3) - vf(3)*BV_contr(2)
  !vxB_contr(2) = vf(3)*BV_contr(1) - vf(1)*BV_contr(3)
  !vxB_contr(3) = vf(1)*BV_contr(2) - vf(2)*BV_contr(1)
  ! CONTRAVARIANT =>
  vxB_contr(1) = vf_cov(2)*BV(3) - vf_cov(3)*BV(2)
  vxB_contr(2) = vf_cov(3)*BV(1) - vf_cov(1)*BV(3)
  vxB_contr(3) = vf_cov(1)*BV(2) - vf_cov(2)*BV(1)
  vxB_contr(1:3) = gm*vxB_contr(1:3)
  !
  !v2     = vx**2 + vy**2 + vz**2
  !b2     = bx**2 + by**2 + bz**2
  !e2     = ex**2 + ey**2 + ez**2 
  vb_cov      = vf_cov(1)*BV_contr(1) + vf_cov(2)*BV_contr(2) + vf_cov(3)*BV_contr(3)    ! VERIFY! unuseful. this is covariant
  !vb_contr      = vf(1)*BV_contr(1) + vf(2)*BV_contr(2) + vf(3)*BV_contr(3)    ! VERIFY. this is contravariant
  v2     = vf(1)*vf_cov(1) + vf(2)*vf_cov(2) + vf(3)*vf_cov(3)
  e2     = vxB_contr(1)*vxB(1) + vxB_contr(2)*vxB(2) + vxB_contr(3)*vxB(3)
  b2     = BV_contr(1)*BV(1) + BV_contr(2)*BV(2) + BV_contr(3)*BV(3)
  !
  uem    = 0.5*(b2 + e2) 
  !
  !
  b2_cov      = SUM(BV(1:3)**2)
  lf     = 1.0 / sqrt(1.0 - v2)
  gamma1 = EQN%gamma/(EQN%gamma-1.0)
  w      = rho + gamma1*p
  ww     = w*lf**2
  !
  Q(1)    = rho*lf
  Q(2:4)  = ww*vf_cov(1:3) + b2*vf_cov(1:3) - vb_cov*BV(1:3) ! covariant!!!!
  !Q(2:4)  = ww*vf(1:3) + b2_contr*vf(1:3) - vb_contr*BV_contr(1:3) ! contravariant
  Q(5)    = ww - p + uem - Q(1)     !!!!! we subtract PDE(Q(1))!!!!
  Q(6:8) = V(6:8)
  Q(1:8)    = gp*Q(1:8)
  Q(9:)    = V(9:)
  !
END SUBROUTINE PDEPrim2Cons

SUBROUTINE PDECons2Prim(V,Q,x,time,iErr)
  USE InterfaceDefinitions
  USE MainVariables, ONLY: EQN, nVar, alpha, beta, gamma2, IC, p_floor, rho_floor
  IMPLICIT NONE
  !--------------------------------------------!
  ! Argument list declaration
  REAL :: Q(nVar), V(nVar)
  REAL :: x(3), time
  INTEGER :: iErr
  INTENT(IN)  :: Q
  INTENT(OUT) :: V 
  ! Local variable declaration
  REAL        :: iRho
  REAL, PARAMETER :: epsilon = 1e-14
  INTEGER     :: ii,jj,kk,ll, i, iter, indx_nr(2)
  REAL        :: sx, sy, sz, bx, by, bz
  REAL        :: v2, sb, den, vb, zeta, cs, cl     
  REAL        :: gamma1, G1, G12, x1, x2, eps
  REAL        :: rho, vx, vy, vz, p, rhou(3) 
  REAL        :: lf, lf2, lf3, lf4, gam,d,e,s2,b2,e2,sb2,w,ww
  REAL        :: RTSAFE_C2P_RMHD1,RTSAFE_C2P_RMHD2, RTSAFE_C2P_RHD1, RTSAFE_C2P_RHD2 ! 
  REAL        :: k(3), B(3), vel(3)
  REAL        :: p1,q1,dd,phi,temp1, Gamma, H, k2, kB, T2
  REAL        :: epsilon0, mu0, f, df, drho
  REAL        :: iPi,B28P, dcs, dc0
  REAL        :: dv2, c0, dw
  REAL        :: ri,qi,kappa,z,kappa_max
  REAL        :: ZBRENT_C2P_RHD2, ZBRENT_LF_POLY
  REAL        :: lapse, gp, gm
  REAL        :: g_contr(3,3), g_cov(3,3)
  REAL        :: shift(3), sm(3), sm_cov(3), vf_cov(3), vf(3), Ev(3), Bv(3)
  REAL        :: dQ(nVar), Qloc(nVar)
  REAL        :: ExB(3),ExB_up(3), U2e(3), S_up(3)  
  REAL        :: LFsolutions(4), cLF(5), C2, C3 
  COMPLEX     :: LFsolutionsC(4)
  REAL        :: xi(2), alpha_nr(2,2), beta_nr(2), d_nr, S  
  REAL        :: A(3,3), devG(3,3), G(3,3), tempp(3,3), Id(3,3), detA, ehh, evv
  REAL        :: EE(3), vv(3), BB(3), eel, detvEB, vxE(3), vxB(3)  
  REAL        :: vs,vl,us,ul,rhos,rhol,rhoeh,rhoe,alphas,alphal
  REAL        :: xx(9), temp(3) 
  LOGICAL     :: FAILED
  REAL, PARAMETER    :: tol = 1e-12, third=1.0/3.0 !, p_floor = 1.0e-12, rho_floor = 1.0e-11
  REAL        :: psi, gammaij(6),ComputeDet, BV_contr(3)
  REAL        :: vtr(3), vtr_old(3), res, A_st(3,0:3), g_cov_st(0:3,0:3), g_contr_st(0:3,0:3), gAB(3,3), gAB_contr(3,3)   
  REAL        :: shift_cov(3), rhoA, piAB1(3,3), piAB2(3,3), I1, I2, f1, f2, eta_mix(3,3), eta_cov(3,3) 
  REAL        :: piAB_st(0:3,0:3), piAB(3,3), kAB(3,3), kAB_contr(3,3), detGAB, pi_work(3), pi_scalar  
  !
  iErr = 0
#ifndef NDIM3D
  x(3) = 0.
#endif  
  !
  !  
  psi = Q(9)
  lapse = Q(10)
  shift = Q(11:13)
  !
  gammaij = Q(14:19) 
  g_cov(1,1) = Q(14)
  g_cov(1,2) = Q(15)
  g_cov(1,3) = Q(16)
  g_cov(2,2) = Q(17)
  g_cov(2,3) = Q(18)
  g_cov(3,3) = Q(19)
  g_cov(2,1) = Q(15)
  g_cov(3,1) = Q(16)
  g_cov(3,2) = Q(18)
  !
  CALL MatrixInverse3x3(g_cov,g_contr,gp)
  
    IF(ISNAN(gp)) THEN
      continue
    ENDIF
    IF(gp.LE.0.) THEN
      continue
    ENDIF
  gp = SQRT(gp)
    IF(ISNAN(gp)) THEN
      continue
    ENDIF
  gm = 1./gp
  ! 
  !CALL METRIC(x, lapse, gp, gm, shift, g_cov, g_contr)  
  Qloc(1:8)  = gm*Q(1:8)
  !
  !BV(1:3) = Qloc(6:8) ! !wrong: magnetic field is contravariant
  BV_contr(1:3) = Qloc(6:8) ! !wrong: magnetic field is contravariant
  !
  gamma1 = EQN%gamma/(EQN%gamma - 1.0)
  gam    = 1.0/gamma1
  ! Solve for p
  FAILED  = .FALSE.
  d       = Qloc(1)
  sm_cov  = Qloc(2:4)
  !
  sm   = MATMUL (g_contr, sm_cov)
  !BV_contr   = MATMUL (g_contr, BV)
  BV   = MATMUL (g_cov, BV_contr)
  s2   = sm_cov(1)*sm(1) + sm_cov(2)*sm(2) + sm_cov(3)*sm(3)
  b2   = BV_contr(1)*BV(1) + BV_contr(2)*BV(2) + BV_contr(3)*BV(3)
  sb   = sm_cov(1)*BV_contr(1) + sm_cov(2)*BV_contr(2) + sm_cov(3)*BV_contr(3)
  sb2  = sb**2
  eps  = 1.e-10 !8
  !!! RHD
  !!e       = Qloc(5) 
  !!x1   = eps      ! min pressure
  !!x2   = 1.0d+5   ! max pressure
  !!p    = RTSAFE_C2P_RHD1(x1,x2,tol,d,e,s2,FAILED)
  !!IF (FAILED) THEN
  !!   p = 1.0e-20
  !!ENDIF
  !!rho  = d / (e + p + d) * SQRT((e + p + d)**2 - s2)
  !!den  = 1.0 / (e + p + d)
  !!!
  !!vf_cov(1:3) = sm_cov(1:3)*den
  !!
  ! First option [Del Zanna et al. (2007) A&A, 473, 11-30 (method 3)]
  e    = Qloc(5) + d  ! Q(5) = gamma^1/2 ( U - D )
  x1   = 0.      ! 
  x2   = 1.0-eps ! 
  w=0
  IF(ANY(ISNAN((/x1,x2,tol,gam,d,e,s2,b2,sb2,w/)))) THEN
      iErr = -2 
      continue
  ENDIF
  !
  v2   = RTSAFE_C2P_RMHD1(x1,x2,tol,gam,d,e,s2,b2,sb2,w,FAILED) 
  !
  IF (FAILED) THEN
     iErr = -1
     p    = p_floor
     rho  = rho_floor
     vx   = 0.0
     vy   = 0.0
     vz   = 0.0
     bx   = bx
     by   = by
     bz   = bz
  ELSE
     den  = 1.0/(w+b2)
     vb   = sb/w
     !
     rho  = d*sqrt(1.-v2)
     vf_cov(1) = (sm_cov(1) + vb*BV(1))*den
     vf_cov(2) = (sm_cov(2) + vb*BV(2))*den
     vf_cov(3) = (sm_cov(3) + vb*BV(3))*den
     p = max(1.e-15, gam*(w*(1.-v2)-rho))
  ENDIF
  !
  V(1:19) = (/ rho, vf_cov(1:3), p, BV_contr(1:3), psi , lapse, shift(1:3), gammaij(1:6)/)
  ! 
  IF(ANY(ISNAN((/x1,x2,tol,gam,d,e,s2,b2,sb2,w/)))) THEN
      iErr = -3 
      continue
  ENDIF
  !
END SUBROUTINE PDECons2Prim

  
    
SUBROUTINE PDEVarName(Name) 
  USE MainVariables, ONLY: nVar  
  IMPLICIT NONE     
  CHARACTER(LEN=10):: Name(nVar)

  Name(1) = 'rho' 
  Name(2) = 'u' 
  Name(3) = 'v'
  Name(4) = 'w'
  Name(5) = 'p' 
  Name(6) = 'Bx' 
  Name(7) = 'By' 
  Name(8) = 'Bz' 
  Name(9) = 'psi' 
  Name(10) = 'lapse' 
  Name(11) = 'Shift^1' 
  Name(12) = 'Shift^2' 
  Name(13) = 'Shift^3' 
  Name(14) = 'Gamma_11' 
  Name(15) = 'Gamma_12' 
  Name(16) = 'Gamma_13' 
  Name(17) = 'Gamma_22' 
  Name(18) = 'Gamma_23' 
  Name(19) = 'Gamma_33' 
  
END SUBROUTINE PDEVarName

SUBROUTINE PDEJacobian(An,Q,gradQ,nv) 
  USE MainVariables, ONLY : EQN, nVar, d, x0_000
  IMPLICIT NONE
  ! Argument list 
  REAL :: An(nVar,nVar)
  REAL :: Q(nVar), gradQ(nVar,d), nv(d) 
  INTENT(IN)  :: Q, gradQ, nv
  INTENT(OUT) :: An  
  ! Local variables
  INTEGER :: i,j,iErr,count,m
  REAL :: A(nVar,nVar), B(nVar,nVar), C(nVar,nVar), Vp(nVar) 
  REAL :: AQx(nVar), BQy(nVar), CQz(nVar), AQx0(nVar), eu(nVar), eu0(nVar), ev(nVar,d), uv(3)  
  REAL :: AQxp(nVar), AQxm(nVar), BQyp(nVar), BQym(nVar), temp(nVar)  
  REAL :: vx, vy, vz, cs, cl 
  REAL :: u,v,h,pg,k,sigma, vtr(3) 
  REAL :: nx, ny, uu, vv, ww, MD12, rho   
  REAL :: t1,t2,t3,t5,t8,t11,t13,t17,t25,t29
  REAL :: g_cov(3,3), g_contr(3,3), g_covx(3,3), g_covy(3,3), g_covz(3,3)
  REAL :: k1,k2,k3,ff,e,det, alpha, fa, s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,k0,beta0(3),b0(3) 
  REAL :: Gtilde(3), Christoffel(3,3,3), Z(3), Zup(3), traceA, Atildeup(3,3), ggg, fff, QG(3), dgup(3,3,3), xi, ds, sk, sknl
  REAL :: lam, mu, irho, ialpha 
  REAL, PARAMETER :: epsilon = 1e-7  
  REAL :: S_contr(3),psi,gammaij(6),lapse,shift(3),gp,gm,ComputeDet,delta(3,3),Wim,W_ij,gamma1,Vc(nVar),vf(3),vf_cov(3),BV(3),p,v2,lf,w !,gv(3),gv_contr(3)
  REAL :: Qv_contr(3),vxB(3),vxB_contr(3),BV_contr(3),e2,b2,uem ! QB_contr(3),
  ! 
  A = 0. 
  B = 0. 
  C = 0.
  An = 0. 
  !
  !psi = Q(9)
  lapse = Q(10)
  !gS(1:3) = Q(2:4) 
  shift = Q(11:13)
  !
  gammaij = Q(14:19) 
  g_cov(1,1) = Q(14)
  g_cov(1,2) = Q(15)
  g_cov(1,3) = Q(16)
  g_cov(2,2) = Q(17)
  g_cov(2,3) = Q(18)
  g_cov(3,3) = Q(19)
  g_cov(2,1) = Q(15)
  g_cov(3,1) = Q(16)
  g_cov(3,2) = Q(18)
  !
  delta = 0.
  DO i=1,3
      delta(i,i) = 1.0
  ENDDO 
  !
  CALL MatrixInverse3x3(g_cov,g_contr,gp)
  gp = SQRT(gp)
  gm = 1./gp
  ! 
  CALL PDECons2Prim(Vc,Q,x0_000,0.,iErr)
  gamma1 = EQN%gamma/(EQN%gamma-1.0)
  rho    = Vc(1)
  vf_cov = Vc(2:4)
  p      = Vc(5)
  !
  !BV(1:3) = Vc(6:8)
  BV_contr(1:3) = Vc(6:8)
  BV = MATMUL(g_cov,BV_contr(1:3))
  !QB_contr(1:3) = Q(6:8) 
  psi = Vc(9) 
  !
  vf     = MATMUL(g_contr,vf_cov)
  S_contr = MATMUL(g_contr,Q(2:4))
  !QB_cov = MATMUL(g_contr,Q(6:8))
  !vxB(1) = vf_cov(2)*BV(3) - vf_cov(3)*BV(2)
  !vxB(2) = vf_cov(3)*BV(1) - vf_cov(1)*BV(3)
  !vxB(3) = vf_cov(1)*BV(2) - vf_cov(2)*BV(1)
  ! COVARIANT =>
  vxB(1) = vf(2)*BV_contr(3) - vf(3)*BV_contr(2)
  vxB(2) = vf(3)*BV_contr(1) - vf(1)*BV_contr(3)
  vxB(3) = vf(1)*BV_contr(2) - vf(2)*BV_contr(1)
  vxB(1:3) = gp*vxB(1:3)
  !
  !vxB_contr(1) = vf(2)*BV_contr(3) - vf(3)*BV_contr(2)
  !vxB_contr(2) = vf(3)*BV_contr(1) - vf(1)*BV_contr(3)
  !vxB_contr(3) = vf(1)*BV_contr(2) - vf(2)*BV_contr(1)
  ! CONTRAVARIANT =>
  vxB_contr(1) = vf_cov(2)*BV(3) - vf_cov(3)*BV(2)
  vxB_contr(2) = vf_cov(3)*BV(1) - vf_cov(1)*BV(3)
  vxB_contr(3) = vf_cov(1)*BV(2) - vf_cov(2)*BV(1)
  vxB_contr(1:3) = gm*vxB_contr(1:3)
  !BV_contr = MATMUL(g_contr,BV(1:3))
  !
  !v2     = vx**2 + vy**2 + vz**2
  !b2     = bx**2 + by**2 + bz**2
  !e2     = ex**2 + ey**2 + ez**2 
  v2     = vf(1)*vf_cov(1) + vf(2)*vf_cov(2) + vf(3)*vf_cov(3)
  e2     = vxB_contr(1)*vxB(1) + vxB_contr(2)*vxB(2) + vxB_contr(3)*vxB(3)
  b2     = BV_contr(1)*BV(1) + BV_contr(2)*BV(2) + BV_contr(3)*BV(3)
  !
  uem    = 0.5*(b2 + e2) 
  !
  !gv_contr = MATMUL(g_contr,gv)
  lf     = 1.0/sqrt(1.0 - v2)
  w      = rho + gamma1*p   ! rho*hentalpy
  ww     = w*lf**2          ! rho*hentalpy*Lorentz^2 
  !
  !DO j=1,3
  A = 0.
  B = 0.
  C = 0.
    !lapse
    !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    j=1
    !------ 
    A(1+j,10) = + (Q(5)+Q(1))   ! Q(10) or lapse
    A(5,10) =  S_contr(j)     !  Q(10) or lapse
    !
    !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    j=2
    !------ 
    B(1+j,10) = + (Q(5)+Q(1))   ! Q(10) or lapse
    B(5,10) =  S_contr(j)     !  Q(10) or lapse
    ! 
    !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    j=3
    !------
    C(1+j,10) = + (Q(5)+Q(1))   ! Q(10) or lapse
    C(5,10) =  S_contr(j)     !  Q(10) or lapse
    ! 
    count=0
    DO i=1,3
        ! shift
        !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
        j=1
        !------ 
        W_ij = ww*vf_cov(i)*vf(j)-vxB(i)*vxB_contr(j)-BV(i)*BV_contr(j)+(p+uem)*delta(i,j)
        !
        A(1+j,10+i) = - Q(1+i)  ! Q(11:13)  shift(i) or shift_contr(i)
        A(5,10+i) = - gp*W_ij    ! Q(11:13)  shift(i) or shift_contr(i)
        !
        !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
        j=2
        !------ 
        W_ij = ww*vf_cov(i)*vf(j)-vxB(i)*vxB_contr(j)-BV(i)*BV_contr(j)+(p+uem)*delta(i,j)
        !
        B(1+j,10+i) = - Q(1+i)  ! Q(11:13)  shift(i) or shift_contr(i)
        B(5,10+i) = - gp*W_ij    ! Q(11:13)  shift(i) or shift_contr(i)
        ! 
        !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
        j=3
        !------
        W_ij = ww*vf_cov(i)*vf(j)-vxB(i)*vxB_contr(j)-BV(i)*BV_contr(j)+(p+uem)*delta(i,j)
        !
        C(1+j,10+i) = - Q(1+i)  ! Q(11:13)  shift(i) or shift_contr(i)
        C(5,10+i) = - gp*W_ij    ! Q(11:13)  shift(i) or shift_contr(i)
        ! 
          DO m=1,3
            IF(m.GE.i) THEN  
                !metric
                count=count+1
                !
                Wim = ww*vf(i)*vf(m)-vxB_contr(i)*vxB_contr(m)-BV_contr(i)*BV_contr(m)+(p+uem)*g_contr(i,m)
                Wim = Wim + (1.0 - delta(i,m))*(ww*vf(m)*vf(i)-vxB_contr(m)*vxB_contr(i)-BV_contr(m)*BV_contr(i)+(p+uem)*g_contr(m,i))  ! account also of the remaining symmetric components of gamma for i.NE.m.
                !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                j=1
                !------ 
                A(1+j,13+count) = - 0.5*gp*lapse*Wim  ! Q(14:19) gammaij(count) or  g_cov(i,m)
                A(5,13+count) = - 0.5*gp*Wim*shift(j)   ! Q(14:19) gammaij(count) or  g_cov(i,m)
                !
                !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                j=2
                !------ 
                B(1+j,13+count) = - 0.5*gp*lapse*Wim  ! Q(14:19) gammaij(count) or  g_cov(i,m)
                B(5,13+count) = - 0.5*gp*Wim*shift(j)   ! Q(14:19) gammaij(count) or  g_cov(i,m)
                ! 
                !xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                j=3
                !------
                C(1+j,13+count) = - 0.5*gp*lapse*Wim  ! Q(14:19) gammaij(count) or  g_cov(i,m)
                C(5,13+count) = - 0.5*gp*Wim*shift(j)   ! Q(14:19) gammaij(count) or  g_cov(i,m)
                ! 
            ENDIF
          ENDDO
      ENDDO
  !ENDDO 
  !
  An = A*nv(1) + B*nv(2) + C*nv(3) 
  !
END SUBROUTINE PDEJacobian
  


