
template<int nVar, int leadingDimSize>
inline void AoS2SoA(const double* const restrict AoS, double* restrict SoA) {
  for(int n=0; n<nVar; n++) {
    #pragma omp simd aligned(SoA,AoS:ALIGNMENT)
    for(int p=0; p<4; p++) {
      SoA[p+4*n] = AoS[n+leadingDimSize*p];
    }
  }
}

template<int nVar, int leadingDimSize>
inline void SoA2AoS(const double* const restrict SoA, double* restrict AoS) {
  for(int p=0; p<4; p++) {
    #pragma omp simd aligned(SoA,AoS:ALIGNMENT)
    for(int n=0; n<nVar; n++) {
      AoS[n+leadingDimSize*p] = SoA[p+4*n];
    }
  }
}

template<int nVar, int leadingDimSize, int restSize>
inline void AoS2SoA_rest(const double* const restrict AoS, double* restrict SoA) {
  for(int n=0; n<nVar; n++) {
    #pragma omp simd aligned(SoA,AoS:ALIGNMENT)
    for(int p=0; p<restSize; p++) {
      SoA[p+4*n] = AoS[n+leadingDimSize*p];
    }
    for(int p=restSize; p<4; p++) { //pad missing point with valid values from first point
      SoA[p+4*n] = AoS[n];
    }
  }
}

template<int nVar, int leadingDimSize, int restSize>
inline void SoA2AoS_rest(const double* const restrict SoA, double* restrict AoS) {
  for(int p=0; p<restSize; p++) { //ignore the padding
    #pragma omp simd aligned(SoA,AoS:ALIGNMENT)
    for(int n=0; n<nVar; n++) {
      AoS[n+leadingDimSize*p] = SoA[p+4*n];
    }
  }
}