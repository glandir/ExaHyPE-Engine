// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include <cmath>
#include <map>

#include "EulerSolver.h"
#include "stableDiffusiveTimeStepSize.h"
#if DIMENSIONS == 2
#include "diffusiveRiemannSolver2d.h"
#elif DIMENSIONS == 3
#include "diffusiveRiemannSolver3d.h"
#endif

#include "kernels/aderdg/generic/Kernels.h"
#include "EulerSolver_Variables.h"
#include "kernels/KernelUtils.h"

#include "Scenarios/Scenario.h"
#include "Scenarios/SodShockTube.h"
#include "Scenarios/DoubleShockTube.h"
#include "Scenarios/SmoothWave.h"
#include "Scenarios/TaylorGreen.h"
#include "Scenarios/Stokes.h"
#include "Scenarios/TwoBubbles.h"
#include "Scenarios/ConvergenceTest/ConvergenceTest.h"

tarch::logging::Log Euler::EulerSolver::_log( "Euler::EulerSolver" );

void Euler::EulerSolver::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
  // Check that parameters are valid.
  assert(constants.isValueValidDouble("viscosity"));
  assert(constants.isValueValidString("scenario"));

  const std::string scenarioName = constants.getValueAsString("scenario");

  if (scenarioName == "sod-shock-tube") {
    scenario = std::unique_ptr<NavierStokes::Scenario>(new NavierStokes::SodShockTube());
  } else if (scenarioName == "double-shock-tube") {
    scenario = std::unique_ptr<NavierStokes::Scenario>(new NavierStokes::DoubleShockTube());
  } else if (scenarioName == "smooth-wave") {
    scenario = std::unique_ptr<NavierStokes::Scenario>(new NavierStokes::SmoothWave());
  } else if (scenarioName == "stokes") {
    scenario = std::unique_ptr<NavierStokes::Scenario>(new NavierStokes::Stokes());
  } else if (scenarioName == "taylor-green") {
    scenario = std::unique_ptr<NavierStokes::Scenario>(new NavierStokes::TaylorGreen());
  } else if (scenarioName == "two-bubbles") {
    scenario = std::unique_ptr<NavierStokes::Scenario>(new NavierStokes::TwoBubbles());
  } else if (scenarioName == "convergence") {
    scenario = std::unique_ptr<NavierStokes::Scenario>(new NavierStokes::ConvergenceTest());
  } else {
    _log.error("EulerSolver::init", "Unknown scenario: " + scenarioName);
    std::abort();
  }

  const auto referenceT = 0.1;
  const auto referenceViscosity = constants.getValueAsDouble("viscosity");
  const auto sutherlandC = 0.0;

  ns = NavierStokes::NavierStokes(referenceT, referenceViscosity, sutherlandC);
}

void Euler::EulerSolver::adjustPointSolution(const double* const x,const double t,const double dt,double* Q) {
  // @todo Please implement/augment if required
  if (tarch::la::equals(t, 0.0)) {
    Variables vars(Q);
    scenario->initialValues(x, ns, vars);
    for (int i = 0; i < vars.variables(); ++i) {
      assertion2(std::isfinite(Q[i]), i, Q[i]);

    }
  }
}

void Euler::EulerSolver::algebraicSource(const tarch::la::Vector<DIMENSIONS, double>& x, double t, const double *const Q, double *S) {
   scenario->source(x, t, ns, Q, S);
}

void Euler::EulerSolver::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,
					const double * const fluxIn,const double* const stateIn, const double* const gradStateIn,
  double *fluxOut,double* stateOut) {
  constexpr auto basisSize = Order + 1;
  constexpr auto gradSize = NumberOfVariables * DIMENSIONS;

  auto gradStateOut = std::array<double, gradSize>{{0.0}};
  kernels::idx2 idxGradQ(DIMENSIONS,NumberOfVariables);

  std::fill_n(fluxOut, NumberOfVariables, 0.0);
  std::fill_n(stateOut, NumberOfVariables, 0.0);

  double _F[DIMENSIONS][NumberOfVariables]={0.0};
#if DIMENSIONS == 2
  double* F[2] = {_F[0], _F[1]};
#elif DIMENSIONS == 3
  double* F[3] = {_F[0], _F[1], _F[2]};
#endif


  if (scenario->getBoundaryType(faceIndex) == NavierStokes::BoundaryType::analytical) {
    // Integrate over time.
    auto curStateOut = std::array<double, NumberOfVariables>{0.0};
    Variables curVarsOut(curStateOut.data());
    for (int i = 0; i < basisSize; ++i) {
      // TODO(Lukas): Check if we need to reset this data here.
      std::fill(curStateOut.begin(), curStateOut.end(), 0.0);
      std::fill(gradStateOut.begin(), gradStateOut.end(), 0.0);

      const double weight = kernels::gaussLegendreWeights[Order][i];
      const double xi = kernels::gaussLegendreNodes[Order][i];
      const double ti = t + xi * dt;

      scenario->analyticalSolution(x, ti, ns, curVarsOut, gradStateOut.data());

      //flux(curStateOut.data(), gradStateOut.data(), F);
      ns.evaluateFlux(curStateOut.data(), gradStateOut.data(), F, true);

      for (int j = 0; j < NumberOfVariables; ++j) {
        stateOut[j] += weight * curStateOut[j];
        fluxOut[j] += weight * F[normalNonZero][j];
      }

    }
    return;
  }

  assert(scenario->getBoundaryType(faceIndex) == NavierStokes::BoundaryType::wall);

  // Set no slip wall boundary conditions.

  ReadOnlyVariables varsIn(stateIn);
  Variables varsOut(stateOut);

  // Rho/E extrapolated, velocity mirrored.
  // Leads to zero velocity after Riemann solver.
  std::copy_n(stateIn, NumberOfVariables, stateOut);
  varsOut.j(0) = -varsIn.j(0);
  varsOut.j(1) = -varsIn.j(1);
#if DIMENSIONS == 3
  varsOut.j(2) = -varsIn.j(2);
#endif

  // Extrapolate gradient.
  std::copy_n(gradStateIn, gradSize, gradStateOut.data());

  // TODO(Lukas): Do sth about heat conduction.
  ns.evaluateFlux(stateOut, gradStateOut.data(), F, true);
  std::copy_n(F[normalNonZero], NumberOfVariables, fluxOut);
}

exahype::solvers::Solver::RefinementControl Euler::EulerSolver::refinementCriterion(
    const double* luh,
    const tarch::la::Vector<DIMENSIONS, double>& center,
    const tarch::la::Vector<DIMENSIONS, double>& dx,
    const double t,
    const int level) {

  return exahype::solvers::Solver::RefinementControl::Keep;
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void Euler::EulerSolver::eigenvalues(const double* const Q,const int d,double* lambda) {
  ns.evaluateEigenvalues(Q, d, lambda);
}

void Euler::EulerSolver::diffusiveEigenvalues(const double* const Q,const int d,double* lambda) {
  ns.evaluateDiffusiveEigenvalues(Q, d, lambda);
}

// TODO(Lukas) remove, currently called in boundaryValues!
void Euler::EulerSolver::flux(const double* const Q, double** F) {
  assert(false); // Make sure it never gets called!
}

void Euler::EulerSolver::flux(const double* const Q,const double* const gradQ, double** F) {
  ns.evaluateFlux(Q, gradQ, F);
}

double Euler::EulerSolver::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx) {
  return stableDiffusiveTimeStepSize<EulerSolver>(*static_cast<EulerSolver*>(this),luh,dx);
  //return kernels::aderdg::generic::c::stableTimeStepSize<EulerSolver>(*static_cast<EulerSolver*>(this),luh,dx);
}

void Euler::EulerSolver::riemannSolver(double* FL,double* FR,const double* const QL,const double* const QR,const double dt,const tarch::la::Vector<DIMENSIONS, double>& lengthScale, const int direction, bool isBoundaryFace, int faceIndex) {
  assertion2(direction>=0,dt,direction);
  assertion2(direction<DIMENSIONS,dt,direction);
  //kernels::aderdg::generic::c::riemannSolverNonlinear<false, EulerSolver>(*static_cast<EulerSolver*>(this),FL,FR,QL,QR,dt,direction);
  riemannSolverNonlinear<false,EulerSolver>(*static_cast<EulerSolver*>(this),FL,FR,QL,QR,lengthScale, dt,direction);

}

void Euler::EulerSolver::boundaryConditions(double* const update, double* const fluxIn,const double* const stateIn, const double* const gradStateIn, const double* const luh, const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int direction,const int orientation) {
  constexpr int basisSize     = (Order+1)*(Order+1);
  constexpr int sizeStateOut = (NumberOfVariables+NumberOfParameters)*basisSize;
  constexpr int sizeFluxOut  = (DIMENSIONS + 1)*NumberOfVariables*basisSize;

  constexpr int totalSize = sizeStateOut + sizeFluxOut;
  double* block = new double[totalSize];
  double* memory = block;

  double* stateOut = memory; memory+=sizeStateOut;
  double* fluxOut  = memory; memory+=sizeFluxOut;

  const int faceIndex = 2*direction+orientation;
  
  kernels::aderdg::generic::c::boundaryConditions<true, EulerSolver>(*static_cast<EulerSolver*>(this),fluxOut,stateOut,fluxIn,stateIn,gradStateIn, cellCentre,cellSize,t,dt,faceIndex,direction);

  if (orientation==0 ) {
    double* FL = fluxOut; const double* const QL = stateOut;
    double* FR = fluxIn;  const double* const QR = stateIn;

    riemannSolverNonlinear<false,EulerSolver>(*static_cast<EulerSolver*>(this),FL,FR,QL,QR,cellSize, dt,direction);

    kernels::aderdg::generic::c::faceIntegralNonlinear<NumberOfVariables, Order+1>(update,fluxIn,direction,orientation,cellSize);
  }
  else {
    double* FL = fluxIn;  const double* const QL = stateIn;
    double* FR = fluxOut; const double* const QR = stateOut;

    riemannSolverNonlinear<false,EulerSolver>(*static_cast<EulerSolver*>(this),FL,FR,QL,QR,cellSize, dt,direction);

    kernels::aderdg::generic::c::faceIntegralNonlinear<NumberOfVariables, Order+1>(update,fluxIn,direction,orientation,cellSize);
  }

  delete[] block;
}
