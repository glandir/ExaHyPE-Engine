#ifndef __MyEulerSolver_CLASS_HEADER__
#define __MyEulerSolver_CLASS_HEADER__

// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include "exahype/Parser.h"
#include "exahype/solvers/FiniteVolumesSolver.h"


namespace EulerFVM{
  class MyEulerSolver;

  class State;
  class Flux;
}

class EulerFVM::MyEulerSolver : public exahype::solvers::FiniteVolumesSolver {
  public:
    MyEulerSolver(int cellsPerCoordinateAxis,double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping);
    
    double stableTimeStepSize(const double* const luh,double* tempEigenvalues,const tarch::la::Vector<DIMENSIONS,double>& dx) override;
    void solutionAdjustment(double* luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) override;
    bool hasToAdjustSolution(const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) override;
    exahype::solvers::Solver::RefinementControl refinementCriterion(const double* luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int level) override;
    void solutionUpdate(double* luhNew,const double* luh,double** tempStateSizedArrays,double** tempUnknowns,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt,double& maxAdmissibleDt) override;
    void ghostLayerFilling(double* luh,const double* luhNeighbour,const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) override;
    void ghostLayerFillingAtBoundary(double* luh,const double* luhbnd,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) override;
    void boundaryLayerExtraction(double* luhbnd,const double* luh,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) override;
    void boundaryConditions(double* stateOut,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) override;
	
    void boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,const double* const stateIn,double* stateOut);
  private:
  	void init(std::vector<std::string>& cmdlineargs);
    static void adjustedSolutionValues(const double* const x,const double w,const double t,const double dt,double* Q);
    static void eigenvalues(const double* const Q,const int normalNonZeroIndex,double* lambda);
    static void flux(const double* const Q,double** F);
    static void source(const double* const Q,double* S);
};

class EulerFVM::State {
private:
  double _rho;
  tarch::la::Vector<3,double> _u; // u has dim 3 for 2.5D Euler formulation
  double _E;
public:
  double rho() {
    return _rho;
  }
  const tarch::la::Vector<3,double>& u() {
    return _u;
  }
  double E() {
    return _E;
  }

  State(const double* const Q) {
    _rho  = Q[0];
    for (int i=0; i<3; ++i) {
      _u[i] = Q[i+1];
    }
    _E = Q[1+3];
  }
};

class EulerFVM::Flux {
private:
  double** _F;
  static constexpr int _variables = 5;
public:
  Flux(double** F) : _F(F) {}

  void writeRow(int index, const tarch::la::Vector<2,double>& rowVector) { // We need this method for 2D applications
    assertion2(index>-1,index,_variables);
    assertion1(index<_variables,_variables);
    _F[0][index] = rowVector[0];
    _F[1][index] = rowVector[1];
  }

  void writeRow(int index, const tarch::la::Vector<3,double>& rowVector) { // We need this method for 2.5D applications
    assertion2(index>-1,index,_variables);
    assertion1(index<_variables,_variables);
    _F[0][index] = rowVector[0];
    _F[1][index] = rowVector[1];
#if DIMENSIONS==3
    _F[2][index] = rowVector[2];
#endif
  }
};

#endif // __MyEulerSolver_CLASS_HEADER__
